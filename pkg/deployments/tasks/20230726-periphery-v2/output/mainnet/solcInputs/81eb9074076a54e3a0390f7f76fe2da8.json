{"language":"Solidity","sources":{"src/Versioning.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity  0.8.15;\n\ncontract Versioning {\n    string public version;\n    constructor(string memory _version){\n        version = _version;\n    }\n}\n"},"src/index.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@sense-finance/v1-core/src/Divider.sol\";\nimport \"@sense-finance/v1-core/src/Periphery.sol\";\nimport \"@sense-finance/v1-core/src/adapters/abstract/BaseAdapter.sol\";\nimport \"@sense-finance/v1-core/src/adapters/implementations/compound/CFactory.sol\";\nimport \"@sense-finance/v1-core/src/adapters/implementations/fuse/FFactory.sol\";\nimport \"@sense-finance/v1-core/src/adapters/implementations/lido/WstETHAdapter.sol\";\nimport \"@sense-finance/v1-core/src/adapters/implementations/lido/OwnableWstETHAdapter.sol\";\nimport \"@sense-finance/v1-core/src/adapters/implementations/claimers/PingPongClaimer.sol\";\nimport \"@sense-finance/v1-core/src/adapters/abstract/factories/ERC4626Factory.sol\";\nimport \"@sense-finance/v1-core/src/adapters/abstract/factories/ERC4626CropsFactory.sol\";\nimport \"@sense-finance/v1-core/src/adapters/abstract/factories/ERC4626CropFactory.sol\";\nimport \"@sense-finance/v1-core/src/adapters/abstract/factories/OwnableERC4626Factory.sol\";\nimport \"@sense-finance/v1-core/src/adapters/abstract/factories/OwnableERC4626CropFactory.sol\";\nimport \"@sense-finance/v1-core/src/adapters/implementations/oracles/ChainlinkPriceOracle.sol\";\nimport \"@sense-finance/v1-core/src/adapters/implementations/oracles/MasterPriceOracle.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/fuse/MockOracle.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/fuse/MockComptroller.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/fuse/MockFuseDirectory.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/MockAdapter.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/MockToken.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/MockTarget.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/MockFactory.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/MockERC4626.sol\";\nimport { Permit2Clone } from \"@sense-finance/v1-core/src/tests/test-helpers/Permit2Clone.sol\";\nimport { CAdapter } from \"@sense-finance/v1-core/src/adapters/implementations/compound/CAdapter.sol\";\nimport { FAdapter } from \"@sense-finance/v1-core/src/adapters/implementations/fuse/FAdapter.sol\";\nimport { AuraAdapter } from \"@sense-finance/v1-core/src/adapters/implementations/aura/AuraAdapter.sol\";\nimport { OwnableAuraAdapter } from \"@sense-finance/v1-core/src/adapters/implementations/aura/OwnableAuraAdapter.sol\";\nimport { AuraVaultWrapper } from \"@sense-finance/v1-core/src/adapters/implementations/aura/AuraVaultWrapper.sol\";\nimport { PoolManager } from \"@sense-finance/v1-fuse/src/PoolManager.sol\";\nimport { NoopPoolManager } from \"@sense-finance/v1-fuse/src/NoopPoolManager.sol\";\nimport { EmergencyStop } from \"@sense-finance/v1-utils/src/EmergencyStop.sol\";\nimport { MultiRewardsDistributor } from \"@sense-finance/v1-core/src/external/MultiRewardsDistributor.sol\";\n\nimport { EulerERC4626WrapperFactory } from \"@sense-finance/v1-core/src/adapters/abstract/erc4626/yield-daddy/euler/EulerERC4626WrapperFactory.sol\";\nimport { RewardsDistributor } from \"../lib/morpho-core-v1/contracts/common/rewards-distribution/RewardsDistributor.sol\";\n\nimport { AutoRollerFactory } from \"../lib/auto-roller/src/AutoRollerFactory.sol\";\nimport { AutoRoller, RollerUtils } from \"../lib/auto-roller/src/AutoRoller.sol\";\nimport { RollerPeriphery } from \"../lib/auto-roller/src/RollerPeriphery.sol\";\nimport { MockOwnableAdapter } from \"../lib/auto-roller/src/test/utils/MockOwnedAdapter.sol\";\n\nimport \"./Versioning.sol\";"},"lib/auto-roller/src/AutoRollerFactory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\n\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\n\nimport { AutoRoller, DividerLike, OwnedAdapterLike, RollerUtils, PeripheryLike } from \"./AutoRoller.sol\";\nimport { BaseSplitCodeFactory } from \"./BaseSplitCodeFactory.sol\";\n\ninterface RollerPeripheryLike {\n    function approve(ERC20,address) external;\n}\n\ncontract AutoRollerFactory is Trust, BaseSplitCodeFactory {\n    error RollerQuantityLimitExceeded();\n\n    DividerLike internal immutable divider;\n    address     internal immutable balancerVault;\n\n    PeripheryLike       public periphery;\n    RollerPeripheryLike public rollerPeriphery;\n    RollerUtils         public utils;\n\n    mapping(address => AutoRoller[]) public rollers;\n\n    constructor(\n        DividerLike _divider,\n        address _balancerVault,\n        address _periphery,\n        address _rollerPeriphery,\n        RollerUtils _utils\n    ) Trust(msg.sender) BaseSplitCodeFactory(type(AutoRoller).creationCode) {\n        divider         = _divider;\n        balancerVault   = _balancerVault;\n        periphery       = PeripheryLike(_periphery);\n        rollerPeriphery = RollerPeripheryLike(_rollerPeriphery);\n        utils           = _utils;\n    }\n\n    function create(\n        OwnedAdapterLike adapter,\n        address rewardRecipient,\n        uint256 targetDuration\n    ) external returns (AutoRoller autoRoller) {\n        ERC20 target = ERC20(address(adapter.target()));\n\n        uint256 id = rollers[address(adapter)].length;\n\n        if (id > 0 && !isTrusted[msg.sender]) revert RollerQuantityLimitExceeded();\n\n        bytes memory constructorArgs = abi.encode(\n            target,\n            divider,\n            address(periphery),\n            address(periphery.spaceFactory()),\n            address(balancerVault),\n            adapter,\n            utils,\n            rewardRecipient\n        );\n        bytes32 salt = keccak256(abi.encode(constructorArgs, id));\n\n        autoRoller = AutoRoller(super._create(constructorArgs, salt));\n\n        // Factory must have adapter auth so that it can give auth to the roller\n        adapter.setIsTrusted(address(autoRoller), true);\n\n        autoRoller.setParam(\"TARGET_DURATION\", targetDuration);\n        autoRoller.setParam(\"OWNER\", msg.sender);\n\n        // Allow the new roller to move the roller periphery's target\n        rollerPeriphery.approve(target, address(autoRoller));\n\n        // Allow the adapter to move the roller periphery's underlying & target if it can't already\n        ERC20 underlying = ERC20(adapter.underlying());\n        if (underlying.allowance(address(rollerPeriphery), address(adapter)) == 0) {\n            rollerPeriphery.approve(underlying, address(adapter));\n        }\n        if (target.allowance(address(rollerPeriphery), address(adapter)) == 0) {\n            rollerPeriphery.approve(target, address(adapter));\n        }\n\n        rollers[address(adapter)].push(autoRoller);\n\n        emit RollerCreated(address(adapter), address(autoRoller));\n    }\n\n    /// @notice Update the address for the Periphery\n    /// @param newPeriphery The Periphery addresss to set\n    function setPeriphery(address newPeriphery) external requiresTrust {\n        emit PeripheryChanged(address(periphery), newPeriphery);\n        periphery = PeripheryLike(newPeriphery);\n    }\n\n    /// @notice Update the address for the Roller Periphery\n    /// @param newRollerPeriphery The Roller Periphery addresss to set\n    function setRollerPeriphery(address newRollerPeriphery) external requiresTrust {\n        emit RollerPeripheryChanged(address(rollerPeriphery), newRollerPeriphery);\n        rollerPeriphery = RollerPeripheryLike(newRollerPeriphery);\n    }\n\n    /// @notice Update the address for the Utils\n    /// @param newUtils The Utils addresss to set\n    function setUtils(address newUtils) external requiresTrust {\n        emit UtilsChanged(address(utils), newUtils);\n        utils = RollerUtils(newUtils);\n    }\n\n    event PeripheryChanged(address indexed adapter, address autoRoller);\n    event RollerPeripheryChanged(address indexed adapter, address autoRoller);\n    event UtilsChanged(address indexed adapter, address autoRoller);\n    event RollerCreated(address indexed adapter, address autoRoller);\n}"},"lib/auto-roller/src/RollerPeriphery.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { ERC4626 } from \"solmate/src/mixins/ERC4626.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\n\nimport { AutoRoller } from \"./AutoRoller.sol\";\n\ninterface AdapterLike {\n    function scale() external view returns (uint256);\n    function underlying() external view returns (address);\n    function wrapUnderlying(uint256) external returns (uint256);\n    function unwrapTarget(uint256) external returns (uint256);\n}\n\n// Inspired by https://github.com/fei-protocol/ERC4626/blob/main/src/ERC4626Router.sol\ncontract RollerPeriphery is Trust {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /// @notice thrown when amount of assets received is below the min set by caller.\n    error MinAssetError();\n\n    /// @notice thrown when amount of underlying received is below the min set by caller.\n    error MinUnderlyingError();\n\n    /// @notice thrown when amount of shares received is below the min set by caller.\n    error MinSharesError();\n\n    /// @notice thrown when amount of assets received is above the max set by caller.\n    error MaxAssetError();\n\n    /// @notice thrown when amount of underlying received is above the max set by caller.\n    error MaxUnderlyingError();\n\n    /// @notice thrown when amount of shares received is above the max set by caller.\n    error MaxSharesError();\n\n    /// @notice thrown when amount of assets or excess received is below the max set by caller.\n    error MinAssetsOrExcessError();\n\n    constructor() Trust(msg.sender) {}\n\n    /// @notice Redeem vault shares with slippage protection \n    /// @param roller ERC4626 vault\n    /// @param shares Number of shares to redeem\n    /// @param receiver Destination address for the returned assets\n    /// @param minAmountOut Minimum amount of assets returned\n    /// @return assets Amount of asset redeemable by the given number of shares\n    function redeem(AutoRoller roller, uint256 shares, address receiver, uint256 minAmountOut) external returns (uint256 assets) {\n        if ((assets = roller.redeem(shares, receiver, msg.sender)) < minAmountOut) {\n            revert MinAssetError();\n        }\n    }\n\n    /// @notice Redeem vault shares and convert to underlying, with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param shares Number of shares to redeem\n    /// @param receiver Destination address for the returned assets\n    /// @param minAmountOut Minimum amount of underlying returned\n    /// @return underlyingOut Amount of underlying converted from Target redeemable by the given number of shares\n    function redeemForUnderlying(AutoRoller roller, uint256 shares, address receiver, uint256 minAmountOut) external returns (uint256 underlyingOut) {\n        AdapterLike adapter = AdapterLike(address(roller.adapter()));\n\n        if ((underlyingOut = adapter.unwrapTarget(roller.redeem(shares, address(this), msg.sender))) < minAmountOut) {\n            revert MinUnderlyingError();\n        }\n\n        ERC20(adapter.underlying()).safeTransfer(receiver, underlyingOut);\n    }\n\n    /// @notice Withdraw asset from vault with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param assets Amount of asset requested for withdrawal\n    /// @param receiver Destination address for the returned assets\n    /// @param maxSharesOut Maximum amount of shares burned\n    /// @return shares Number of shares to redeem\n    function withdraw(AutoRoller roller, uint256 assets, address receiver, uint256 maxSharesOut) external returns (uint256 shares) {\n        if ((shares = roller.withdraw(assets, receiver, msg.sender)) > maxSharesOut) {\n            revert MaxSharesError();\n        }\n    }\n\n    /// @notice Withdraw asset from vault and convert to underlying, with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param underlyingOut Amount of underlying requested for withdrawal\n    /// @param receiver Destination address for the returned underlying\n    /// @param maxSharesOut Maximum amount of shared burned\n    /// @return shares Number of shares to redeem\n    function withdrawUnderlying(AutoRoller roller, uint256 underlyingOut, address receiver, uint256 maxSharesOut) external returns (uint256 shares) {\n        AdapterLike adapter = AdapterLike(address(roller.adapter()));\n\n        // asset converted from underlying (round down)\n        uint256 assetOut = underlyingOut.divWadDown(adapter.scale());\n\n        if ((shares = roller.withdraw(assetOut, address(this), msg.sender)) > maxSharesOut) {\n            revert MaxSharesError();\n        }\n\n        uint256 underlyingOut = adapter.unwrapTarget(roller.asset().balanceOf(address(this)));\n        ERC20(adapter.underlying()).safeTransfer(receiver, underlyingOut);\n    }\n\n    /// @notice Mint vault shares with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param shares Number of shares to mint\n    /// @param receiver Destination address for the returned shares\n    /// @param maxAmountIn Maximum amount of assets pulled from msg.sender\n    /// @return assets Amount of asset pulled from msg.sender and used to mint vault shares\n    function mint(AutoRoller roller, uint256 shares, address receiver, uint256 maxAmountIn) external returns (uint256 assets) {\n        ERC20(roller.asset()).safeTransferFrom(msg.sender, address(this), roller.previewMint(shares));\n\n        if ((assets = roller.mint(shares, receiver)) > maxAmountIn) {\n            revert MaxAssetError();\n        }\n    }\n\n    /// @notice Convert underlying to asset and mint vault shares with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param shares Number of shares to mint\n    /// @param receiver Destination address for the returned shares\n    /// @param maxAmountIn Maximum amount of underlying pulled from msg.sender\n    /// @return underlyingIn Amount of underlying pulled from msg.sender and used to mint vault shares\n    function mintFromUnderlying(AutoRoller roller, uint256 shares, address receiver, uint256 maxAmountIn) external returns (uint256 underlyingIn) {\n        AdapterLike adapter = AdapterLike(address(roller.adapter()));\n\n        ERC20(adapter.underlying()).safeTransferFrom(\n            msg.sender,\n            address(this),\n            underlyingIn = roller.previewMint(shares).mulWadUp(adapter.scale()) // underlying converted from asset (round up)\n        );\n\n        adapter.wrapUnderlying(underlyingIn); // convert underlying to asset\n\n        uint256 assetIn = roller.mint(shares, receiver);\n        if ((underlyingIn = assetIn.mulWadDown(adapter.scale())) > maxAmountIn) {\n            revert MaxUnderlyingError();\n        }\n    }\n\n    /// @notice Deposit asset into vault with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param assets Amount of asset pulled from msg.sender and used to mint vault shares\n    /// @param receiver Destination address for the returned shares\n    /// @param minSharesOut Minimum amount of returned shares\n    /// @return shares Number of shares minted by the vault and returned to msg.sender\n    function deposit(AutoRoller roller, uint256 assets, address receiver, uint256 minSharesOut) external returns (uint256 shares) {\n        ERC20(roller.asset()).safeTransferFrom(msg.sender, address(this), assets);\n\n        if ((shares = roller.deposit(assets, receiver)) < minSharesOut) {\n            revert MinSharesError();\n        }\n    }\n\n    /// @notice Convert underlying to asset and deposit into vault with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param underlyingIn Amount of underlying pulled from msg.sender and used to mint vault shares\n    /// @param receiver Destination address for the returned shares\n    /// @param minSharesOut Minimum amount of returned shares\n    /// @return shares Number of shares minted by the vault and returned to msg.sender\n    function depositUnderlying(AutoRoller roller, uint256 underlyingIn, address receiver, uint256 minSharesOut) external returns (uint256 shares) {\n        AdapterLike adapter = AdapterLike(address(roller.adapter()));\n\n        ERC20(adapter.underlying()).safeTransferFrom(msg.sender, address(this), underlyingIn);\n\n        if ((shares = roller.deposit(adapter.wrapUnderlying(underlyingIn), receiver)) < minSharesOut) {\n            revert MinSharesError();\n        }\n    }\n\n    /// @notice Quick exit into the constituent assets with slippage protection\n    /// @param roller AutoRoller vault.\n    /// @param shares Number of shares to eject with.\n    /// @param receiver Destination address for the constituent assets.\n    /// @param minAssetsOut Minimum amount of assets returned\n    /// @param minExcessOut Minimum excess PT/YT returned\n    /// @return assets Amount of asset redeemable by the given number of shares.\n    /// @return excessBal Amount of excess PT or YT redeemable by the given number of shares.\n    /// @return isExcessPTs Whether the excess token is a YT or PT.\n    function eject(AutoRoller roller, uint256 shares, address receiver, uint256 minAssetsOut, uint256 minExcessOut)\n        external returns (uint256 assets, uint256 excessBal, bool isExcessPTs)\n    {\n        (assets, excessBal, isExcessPTs) = roller.eject(shares, receiver, msg.sender);\n\n        if (assets < minAssetsOut || excessBal < minExcessOut) {\n            revert MinAssetsOrExcessError();\n        }\n    }\n\n    function approve(ERC20 token, address to) public payable requiresTrust {\n        token.safeApprove(to, type(uint256).max);\n    }\n}"},"lib/auto-roller/src/AutoRoller.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\nimport { ReentrancyGuard } from \"solmate/src/utils/ReentrancyGuard.sol\";\nimport { ERC4626 } from \"solmate/src/mixins/ERC4626.sol\";\n\nimport { DateTime } from \"./external/DateTime.sol\";\n\nimport { SafeCast } from \"./SafeCast.sol\";\n\nimport { BalancerVault } from \"./interfaces/BalancerVault.sol\";\nimport { Space } from \"./interfaces/Space.sol\";\n\ninterface SpaceFactoryLike {\n    function divider() external view returns (address);\n    function create(address, uint256) external returns (address);\n    function pools(address, uint256) external view returns (Space);\n}\n\ninterface DividerLike {\n    function series(address, uint256) external returns (address, uint48, address, uint96, address, uint256, uint256, uint256, uint256);\n    function issue(address, uint256, uint256) external returns (uint256);\n    function settleSeries(address, uint256) external;\n    function mscale(address, uint256) external view returns (uint256);\n    function redeem(address, uint256, uint256) external;\n    function combine(address, uint256, uint256) external;\n}\n\ninterface YTLike {\n    function approve(address, uint256) external;\n    function transfer(address, uint256) external;\n    function collect() external returns (uint256);\n    function balanceOf(address) external view returns (uint256);\n}\n\ninterface PeripheryLike {\n    function sponsorSeries(address, uint256, bool) external returns (ERC20, YTLike);\n    function swapYTsForTarget(address, uint256, uint256) external returns (uint256);\n    function create(address, uint256) external returns (address);\n    function spaceFactory() external view returns (SpaceFactoryLike);\n    function MIN_YT_SWAP_IN() external view returns (uint256);\n}\n\ninterface OwnedAdapterLike {\n    function target() external view returns (address);\n    function underlying() external view returns (address);\n    function ifee() external view returns (uint256);\n    function openSponsorWindow() external;\n    function scale() external returns (uint256);\n    function scaleStored() external view returns (uint256);\n    function getStakeAndTarget() external view returns (address,address,uint256);\n    function setIsTrusted(address,bool) external;\n}\n\ncontract AutoRoller is ERC4626, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n    using SafeCast for *;\n\n    /* ========== ERRORS ========== */\n\n    error ActivePhaseOnly();\n    error UnrecognizedParam(bytes32 what);\n    error InsufficientLiquidity();\n    error RollWindowNotOpen();\n    error OnlyAdapter();\n    error InvalidSettler();\n\n    /* ========== CONSTANTS ========== */\n\n    uint32 internal constant MATURITY_NOT_SET = type(uint32).max;\n    int256 internal constant WITHDRAWAL_GUESS_OFFSET = 0.95e18; // Offset from the number of assets in this contract the first withdrawal guess will be made.\n\n    /* ========== IMMUTABLES ========== */\n\n    DividerLike      internal immutable divider;\n    BalancerVault    internal immutable balancerVault;\n    OwnedAdapterLike public   immutable adapter;\n\n    uint256 internal immutable ifee; // Cached issuance fee.\n    uint256 internal immutable minSwapAmount; // Min number of PTs that can be swapped out when exiting.\n    uint256 internal immutable firstDeposit; // Size of the first deposit that gets locked in the contract permanently.\n    uint256 internal immutable maxError; // A conservative buffer for \"rounding\" swap previews that accounts for compounded pow of imprecision.\n    address internal immutable rewardRecipient; // Recipient address for any unexpected tokens that end up in this contract.\n\n    /* ========== MUTABLE STORAGE ========== */\n\n    PeripheryLike    internal periphery;\n    SpaceFactoryLike internal spaceFactory;\n    address          internal owner; // Admin that can set params.\n    RollerUtils      internal utils; // Utility contract with convenience getter functions.\n\n    // Active Series\n    YTLike  internal yt;\n    ERC20   internal pt;\n    Space   internal space;\n    bytes32 internal poolId;\n    address internal lastRoller; // Last address to call roll.\n\n    // Separate slots to meet contract size limits.\n    uint256 public   maturity = MATURITY_NOT_SET;\n    uint256 internal initScale;\n    uint256 internal pti;\n\n    uint256 internal maxRate        = 53144e19; // Max implied rate stretched to Space pool's TS period. (531440% over 12 years ≈ 200% APY)\n    uint256 internal targetedRate   = 2.9e18; // Targeted implied rate stretched to Space pool's TS period. (2.9% over 12 years ≈ 0.12% APY)\n    uint256 internal targetDuration = 3; // Number of months or weeks in the future newly sponsored Series should mature.\n\n    uint256 public cooldown         = 10 days; // Length of mandatory cooldown period during which LPs can withdraw without slippage.\n    uint256 public lastSettle; // Timestamp from when settlement was last called.\n\n    constructor(\n        ERC20 _target,\n        DividerLike _divider,\n        address _periphery,\n        address _spaceFactory,\n        address _balancerVault,\n        OwnedAdapterLike _adapter,\n        RollerUtils _utils,\n        address _rewardRecipient\n    ) ERC4626(\n        _target,\n        string(abi.encodePacked(_target.name(), \" Sense Auto Roller\")),\n        string(abi.encodePacked(_target.symbol(), \"-sAR\"))\n    ) {\n        divider       = _divider;\n        periphery     = PeripheryLike(_periphery);\n        spaceFactory  = SpaceFactoryLike(_spaceFactory);\n        balancerVault = BalancerVault(_balancerVault);\n\n        // Allow the Divder to move this contract's Target for PT/YT issuance.\n        _target.safeApprove(address(_divider), type(uint256).max);\n\n        // Allow Balancer to move this contract's Target for Space pools joins.\n        _target.safeApprove(address(_balancerVault), type(uint256).max);\n\n        uint256 scalingFactor = 10**(18 - decimals);\n\n        minSwapAmount = (periphery.MIN_YT_SWAP_IN() - 1) / scalingFactor + 1; // Rounds up to cover low decimal tokens.\n        maxError      = (1e7 - 1) / scalingFactor + 1;\n        firstDeposit  = (0.01e18 - 1) / scalingFactor + 1;\n\n        adapter = _adapter;\n        ifee    = _adapter.ifee(); // Assumption: ifee will not change. Don't break this assumption and expect good things.\n        owner   = msg.sender;\n        utils   = _utils;\n        rewardRecipient = _rewardRecipient;\n    }\n\n    /* ========== SERIES MANAGEMENT ========== */\n\n    /// @notice Roll into the next Series if there isn't an active series and the cooldown period has elapsed.\n    function roll() external {\n        if (maturity != MATURITY_NOT_SET) revert RollWindowNotOpen();\n\n        if (lastSettle == 0) {\n            // If this is the first roll, lock some shares in by minting them for the zero address.\n            // This prevents the contract from reaching an empty state during future active periods.\n            deposit(firstDeposit, address(0));\n        } else if (lastSettle + cooldown > block.timestamp) {\n            revert RollWindowNotOpen();\n        }\n\n        lastRoller = msg.sender;\n        adapter.openSponsorWindow();\n    }\n\n    /// @notice Sponsor a new Series, issue PTs, and migrate liquidity into the new Space pool.\n    /// @dev We only expect this function to be called by this roller's adapter in the callback triggered within the adapter.openSponsorWindow call.\n    ///      Assumption: all of this Vault's LP shares will have been exited before this function is called.\n    /// @param stake the adapter's stake token address.\n    /// @param stakeSize the adapter's stake size.\n    function onSponsorWindowOpened(ERC20 stake, uint256 stakeSize) external {\n        if (msg.sender != address(adapter)) revert OnlyAdapter();\n\n        stake.safeTransferFrom(lastRoller, address(this), stakeSize);\n\n        // Allow the Periphery to move stake for sponsoring the Series.\n        stake.safeApprove(address(periphery), stakeSize);\n\n        uint256 _maturity = utils.getFutureMaturity(targetDuration);\n\n        // Assign Series data.\n        (ERC20 _pt, YTLike _yt) = periphery.sponsorSeries(address(adapter), _maturity, true);\n        (Space _space, bytes32 _poolId, uint256 _pti, uint256 _initScale) = utils.getSpaceData(periphery, OwnedAdapterLike(msg.sender), _maturity);\n\n        // Allow Balancer to move the new PTs for joins & swaps.\n        _pt.approve(address(balancerVault), type(uint256).max);\n\n        // Allow Periphery to move the new YTs for swaps.\n        _yt.approve(address(periphery), type(uint256).max);\n\n        ERC20 _asset = asset;\n\n        ERC20[] memory tokens = new ERC20[](2);\n        tokens[1 - _pti] = _asset;\n        tokens[_pti] = _pt;\n\n        uint256 targetBal = _asset.balanceOf(address(this));\n\n        // Get the reserve balances that would imply the given targetedRate in the Space pool,\n        // assuming that we we're going to deposit the amount of Target currently in this contract.\n        // In other words, this function simulating the reserve balances that would result from the actions:\n        // 1) Use the some Target to issue PTs/YTs\n        // 2) Deposit some amount of Target\n        // 3) Swap PTs into the pool to initialize the targeted rate\n        // 4) Deposit the rest of the PTs and Target in this contract (which remain in the exact ratio the pool expects)\n        // Since we're determining the resulting reserve balances of these operations, we can issue exactly the amount of PTs we'll need to keep the ratio in the pool.\n        (uint256 eqPTReserves, uint256 eqTargetReserves) = _space.getEQReserves(\n            targetedRate < 0.01e18 ? 0.01e18 : targetedRate, // Don't let the pool start below 0.01% stretched yield\n            _maturity,\n            0, // PT reserves, starting with 0\n            targetBal, // Target reserves, starting with the entire Target balance in this contract.\n            targetBal.mulWadDown(_initScale), // Total supply, starting with Target * initScale, since that's the BPT supply if once deposit all of the Target.\n            _space.g2() // Space fee, g2 because the swap we'll make to initialize these reserve balances is PT -> Target (see https://yield.is/YieldSpace.pdf section \"5 Fees\").\n        );\n\n        // Calculate & issue an amount of PTs, such that all PTs are used to add liquidity while preserving the PT:Target reserve ratio in the Space Pool.\n        uint256 targetForIssuance = _getTargetForIssuance(eqPTReserves, eqTargetReserves, targetBal, _initScale);\n        divider.issue(address(adapter), _maturity, targetForIssuance);\n\n        uint256[] memory balances = new uint256[](2);\n        balances[1 - _pti] = targetBal - targetForIssuance;\n\n        // Initialize the targeted rate in the Space pool with a join, a swap, and another join.\n        _joinPool(\n            _poolId,\n            BalancerVault.JoinPoolRequest({\n                assets: tokens,\n                maxAmountsIn: balances,\n                userData: abi.encode(balances, 0), // No min BPT out: first join.\n                fromInternalBalance: false\n            })\n        );\n        _swap(\n            BalancerVault.SingleSwap({\n                poolId: _poolId,\n                kind: BalancerVault.SwapKind.GIVEN_IN,\n                assetIn: address(_pt),\n                assetOut: address(tokens[1 - _pti]),\n                amount: eqPTReserves.mulDivDown(balances[1 - _pti], targetBal),\n                userData: hex\"\"\n            })\n        );\n\n        balances[_pti    ] = _pt.balanceOf(address(this));\n        balances[1 - _pti] = _asset.balanceOf(address(this));\n\n        _joinPool(\n            _poolId,\n            BalancerVault.JoinPoolRequest({\n                assets: tokens,\n                maxAmountsIn: balances,\n                userData: abi.encode(balances, 0), // No min BPT out: the pool was created in this tx and the join can't be sandwiched.\n                fromInternalBalance: false\n            })\n        );\n\n        // Cache Series data.\n        space  = _space;\n        poolId = _poolId;\n        pt     = _pt;\n        yt     = _yt;\n\n        // Combined single SSTORE.\n        initScale = _initScale;\n        maturity  = _maturity; // OK until Feb 07, 2106\n        pti       = _pti;\n\n        emit Rolled(_maturity, uint256(_initScale), address(_space), msg.sender);\n    }\n\n    /// @notice Settle the active Series, transfer stake and ifees to the settler, and enter a cooldown phase.\n    /// @dev Because the auto-roller is the series sponsor from the Divider's perspective, this.settle is the only entrypoint for athe lastRoller to settle during the series' sponsor window.\n    ///      More info on the series lifecylce: https://docs.sense.finance/docs/series-lifecycle-detail/#phase-3-settling.\n    function settle() public {\n        if(msg.sender != lastRoller) revert InvalidSettler();\n\n        uint256 assetBalPre = asset.balanceOf(address(this));\n        divider.settleSeries(address(adapter), maturity); // Settlement will fail if maturity hasn't been reached.\n        uint256 assetBalPost = asset.balanceOf(address(this));\n\n        asset.safeTransfer(msg.sender, assetBalPost - assetBalPre); // Send issuance fees to the sender.\n\n        (, address stake, uint256 stakeSize) = adapter.getStakeAndTarget();\n        if (stake != address(asset)) {\n            ERC20(stake).safeTransfer(msg.sender, stakeSize);\n        }\n\n        startCooldown();\n    }\n\n    /// @notice Enter a cooldown phase where users can redeem without slippage. Often this will be initiated by this.settle,\n    ///         but it can be called externally if the Series was settled externally.\n    function startCooldown() public {\n        require(divider.mscale(address(adapter), maturity) != 0);\n\n        ERC20[] memory tokens = new ERC20[](2);\n        tokens[1 - pti] = asset;\n        tokens[pti    ] = pt;\n\n        _exitPool(\n            poolId,\n            BalancerVault.ExitPoolRequest({\n                assets: tokens,\n                minAmountsOut: new uint256[](2),\n                userData: abi.encode(space.balanceOf(address(this))),\n                toInternalBalance: false\n            })\n        );\n\n        divider.redeem(address(adapter), maturity, pt.balanceOf(address(this))); // Burns the PTs.\n        yt.collect(); // Burns the YTs.\n\n        // Calculate the initial market fixed rate for the upcoming series, using the historical avg Target rate across the previous series.\n        targetedRate = utils.getNewTargetedRate(targetedRate, address(adapter), maturity, space);\n\n        maturity   = MATURITY_NOT_SET;\n        lastSettle = uint32(block.timestamp);\n        delete pt; delete yt; delete space; delete pti; delete poolId; delete initScale; // Re-set variables to defaults, collect gas refund.\n    }\n\n    /* ========== 4626 SPEC ========== */\n    // see: https://eips.ethereum.org/EIPS/eip-4626\n\n    /// @dev Collect asset from roller's YT balance & densify shares before depositing\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\n        if (maturity != MATURITY_NOT_SET) yt.collect();\n        return super.deposit(assets, receiver);\n    }\n\n    /// @dev Collect asset from roller's YT balance & densify shares before minting\n    function mint(uint256 shares, address receiver) public override returns (uint256) {\n        if (maturity != MATURITY_NOT_SET) yt.collect();\n        return super.mint(shares, receiver);\n    }\n\n    function redeem(uint256 shares, address receiver, address owner) public override returns (uint256) {\n        if (maturity != MATURITY_NOT_SET) yt.collect();\n        return super.redeem(shares, receiver, owner);\n    }\n\n    function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {\n        if (maturity != MATURITY_NOT_SET) yt.collect();\n        return super.withdraw(assets, receiver, owner);\n    }\n\n    /// @dev exit LP shares commensurate the given number of shares, and sell the excess PTs or YTs into Target if possible.\n    function beforeWithdraw(uint256, uint256 shares) internal override {\n        if (maturity != MATURITY_NOT_SET) {\n            (uint256 excessBal, bool isExcessPTs) = _exitAndCombine(shares);\n\n            if (excessBal < minSwapAmount) return;\n\n            if (isExcessPTs) {\n                _swap(\n                    BalancerVault.SingleSwap({\n                        poolId: poolId,\n                        kind: BalancerVault.SwapKind.GIVEN_IN,\n                        assetIn: address(pt),\n                        assetOut: address(asset),\n                        amount: excessBal,\n                        userData: hex\"\"\n                    })\n                );\n            } else {\n                periphery.swapYTsForTarget(address(adapter), maturity, excessBal); // Swapping YTs will fail if there isn't enough liquidity.\n            }\n        }\n    }\n\n    /// @dev Joins the Space pool, issuing PTs in order to match the current pool's ratio of Target:PT\n    function afterDeposit(uint256, uint256 shares) internal override {\n        if (maturity != MATURITY_NOT_SET) {\n            uint256 _supply = totalSupply; // Saves extra SLOADs.\n            bytes32 _poolId = poolId;\n            uint256 _pti    = pti;\n\n            (ERC20[] memory tokens, uint256[] memory balances, ) = balancerVault.getPoolTokens(_poolId);\n\n            uint256 assetBal = asset.balanceOf(address(this));\n            uint256 targetToJoin = _supply - shares == 0 ? // _supply - shares b/c this is after minting new shares.\n                shares.mulDivUp(balances[1 - _pti], space.adjustedTotalSupply()) :\n                assetBal - _getTargetForIssuance(balances[_pti], balances[1 - _pti], assetBal, adapter.scaleStored());\n\n            balances[1 - _pti] = targetToJoin;\n\n            if (assetBal - targetToJoin > 0) { // Assumption: this is false if Space has only Target liquidity.\n                balances[_pti] = divider.issue(address(adapter), maturity, assetBal - targetToJoin);\n            }\n\n            _joinPool(\n                _poolId,\n                BalancerVault.JoinPoolRequest({\n                    assets: tokens,\n                    maxAmountsIn: balances,\n                    userData: abi.encode(balances, 0),\n                    fromInternalBalance: false\n                })\n            );\n        }\n    }\n\n    /// @notice Calculates the total assets of this vault using the current spot prices, with no regard for slippage.\n    function totalAssets() public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return asset.balanceOf(address(this));\n        }\n        else {\n            Space _space = space;\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n\n            (uint256 targetBal, uint256 ptBal, uint256 ytBal, ) = _decomposeShares(ptReserves, targetReserves, totalSupply, true);\n\n            uint256 ptSpotPrice = _space.getPriceFromImpliedRate(\n                (ptReserves + _space.adjustedTotalSupply()).divWadDown(targetReserves.mulWadDown(initScale)) - 1e18\n            ); // PT price in Target.\n\n            uint256 scale = adapter.scaleStored();\n\n            if (ptBal >= ytBal) {\n                // Target + combined PTs/YTs + PT spot value in Target.\n                return targetBal + ytBal.divWadDown(scale) + ptSpotPrice.mulWadDown(ptBal - ytBal);\n            } else {\n                uint256 ytSpotPrice = (1e18 - ptSpotPrice.mulWadDown(scale)).divWadDown(scale);\n\n                // Target + combined PTs/YTs + YT spot value in Target.\n                return targetBal + ptBal.divWadDown(scale) + ytSpotPrice.mulWadDown(ytBal - ptBal);\n            }\n        }\n    }\n\n    /// @notice The same as convertToShares, except that slippage is considered.\n    /// @dev Preview the number of new LP shares that would be minted by joining with the given amount of Target, then use that\n    ///      as a percentage of the total number of LP shares held in this contract to preview the number of new roller shares.\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return super.previewDeposit(assets);\n        } else {\n            Space _space = space;\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n\n            // Calculate how much Target we'll end up joining the pool with, and use that to preview minted LP shares.\n            uint256 previewedLPBal = (assets - _getTargetForIssuance(ptReserves, targetReserves, assets, adapter.scaleStored()))\n                .mulDivDown(_space.adjustedTotalSupply(), targetReserves);\n\n            uint256 assetBal = asset.balanceOf(address(this));\n            uint256 assetBalLP = space.balanceOf(address(this)).mulDivDown(assets, previewedLPBal);\n            uint256 assetBalPT = pt.balanceOf(address(this)).divWadUp(adapter.scaleStored().mulWadDown(1e18 - ifee));\n\n            // Shares represent proportional ownership of LP shares the vault holds.\n            return previewedLPBal.mulDivDown(totalSupply, _space.balanceOf(address(this)))\n                .mulDivDown(assetBalLP, assetBalPT + assetBalLP + assetBal);\n        }\n    }\n\n    /// @dev Preview the amount of Target needed to mint the given number of shares by determining how much of\n    ///      each asset in this contract the given number of shares represent, then conver that all into Target.\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return super.previewMint(shares);\n        } else {\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n\n            (uint256 targetToJoin, uint256 ptsToJoin, , ) = _decomposeShares(ptReserves, targetReserves, shares, true);\n\n            return targetToJoin + ptsToJoin.divWadUp(adapter.scaleStored().mulWadDown(1e18 - ifee)) + 1; // targetToJoin + targetToIssue\n        }\n    }\n\n    /// @notice The same as convertToAssets, except that slippage is considered.\n    function previewRedeem(uint256 shares) public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return super.previewRedeem(shares);\n        } else {\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n\n            (uint256 targetBal, uint256 ptBal, uint256 ytBal, uint256 lpBal) = _decomposeShares(ptReserves, targetReserves, shares, false);\n\n            uint256 scale = adapter.scaleStored();\n\n            ptReserves     = ptReserves - ptBal;\n            targetReserves = targetReserves - targetBal;\n\n            // Adjust balances for loose asset share.\n            ptBal     = ptBal     + shares.mulDivDown(pt.balanceOf(address(this)), totalSupply);\n            targetBal = targetBal + shares.mulDivDown(asset.balanceOf(address(this)), totalSupply);\n            uint256 spaceSupply = space.adjustedTotalSupply() - lpBal;\n\n            if (ptBal > ytBal) {\n                unchecked {\n                    // If there isn't enough liquidity to sell all of the PTs, the swap preview will fail.\n                    uint256 ptsToSell = ptBal - ytBal;\n\n                    uint256 targetOut = ptsToSell > minSwapAmount ?\n                        space.onSwapPreview(\n                            true,\n                            true,\n                            ptsToSell,\n                            ptReserves,\n                            targetReserves,\n                            spaceSupply,\n                            scale\n                        ) : 0;\n\n                    // target + combined PTs/YTs + sold PTs - buffer for pow of discrepencies.\n                    return targetBal + ytBal.divWadDown(scale) + targetOut - maxError;\n                }\n            } else {\n                unchecked {\n                    // Safety: an inequality check is done before ytBal - ptBal.\n                    //         shares must be lte total supply, so ptReserves & targetReserves wil always be gte ptBal & targetBal.\n                    uint256 ytsToSell = ytBal - ptBal;\n\n                    // Target from combining YTs with PTs - target needed to buy PTs.\n                    uint256 targetOut = ytsToSell > minSwapAmount ?\n                        ytsToSell.divWadDown(scale) - space.onSwapPreview(\n                            false,\n                            false,\n                            ytsToSell,\n                            targetReserves,\n                            ptReserves,\n                            spaceSupply,\n                            scale\n                        ) : 0;\n\n                    // target + combined PTs/YTs + sold YTs - buffer for pow of discrepencies.\n                    return targetBal + ptBal.divWadDown(scale) + targetOut - maxError;\n                }\n            }\n        }\n    }\n\n    /// @notice Amount of shares needed to redeem the given assets, erring on the side of overestimation.\n    ///         The calculation for previewWithdraw is quite imprecise and expensive, so previewRedeem & redeem\n    ///         should be favored over previewWithdraw & withdraw.\n    function previewWithdraw(uint256 assets) public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return super.previewWithdraw(assets);\n        } else {\n            uint256 _supply = totalSupply - firstDeposit;\n\n            int256 prevGuess  = _min(assets, _supply).safeCastToInt();\n            int256 prevAnswer = previewRedeem(prevGuess.safeCastToUint()).safeCastToInt() - assets.safeCastToInt();\n\n            int256 guess = prevGuess * WITHDRAWAL_GUESS_OFFSET / 1e18;\n\n            int256 supply = _supply.safeCastToInt();\n\n            // Find the root or get very close to it using the secant method, which is slightly more efficient than Newton's\n            // method if the cost of evaluating f and f' is similar.\n            for (uint256 i = 0; i < 20;) { // 20 chosen as a safe bound for convergence from practical trials.\n                if (guess > supply) {\n                    guess = supply;\n                }\n                int256 answer = previewRedeem(guess.safeCastToUint()).safeCastToInt() - assets.safeCastToInt();\n\n                if (answer > 0 && answer <= assets.mulWadDown(0.001e18).safeCastToInt() || (prevAnswer == answer)) { // Err on the side of overestimating shares needed. Could reduce precision for gas efficiency.\n                    break;\n                }\n\n                if (guess == supply && answer < 0) revert InsufficientLiquidity();\n\n                int256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\n                prevGuess  = guess;\n                prevAnswer = answer;\n                guess      = nextGuess;\n\n                unchecked { ++i; }\n            }\n\n            return guess.safeCastToUint() + maxError; // Buffer for pow discrepancies.\n        }\n    }\n\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return super.maxWithdraw(owner);\n        } else {\n            return previewRedeem(maxRedeem(owner));\n        }\n    }\n\n    /// @notice Maximum number of shares the given owner can redeem, given Space pool liquidity constraints and the maxRate guard.\n    function maxRedeem(address owner) public view override returns (uint256) { // No idiosyncratic owner restrictions.\n        if (maturity == MATURITY_NOT_SET) {\n            return super.maxRedeem(owner);\n        } else {\n            uint256 shares = balanceOf[owner];\n\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n\n            (uint256 targetBal, uint256 ptBal, uint256 ytBal, uint256 lpBal) = _decomposeShares(ptReserves, targetReserves, shares, false);\n\n            ptReserves     = ptReserves - ptBal;\n            targetReserves = targetReserves - targetBal;\n\n            ptBal     = ptBal     + shares.mulDivDown(pt.balanceOf(address(this)), totalSupply);\n            targetBal = targetBal + shares.mulDivDown(asset.balanceOf(address(this)), totalSupply);\n            uint256 spaceSupply = space.adjustedTotalSupply() - lpBal;\n\n            bool isExcessPTs = ptBal > ytBal;\n            uint256 diff = isExcessPTs ? ptBal - ytBal : ytBal - ptBal;\n\n            if (isExcessPTs) {\n                uint256 maxPTSale = _maxPTSell(ptReserves, targetReserves, spaceSupply);\n\n                if (maxPTSale >= diff) {\n                    // We have enough liquidity to handle the sale.\n                    return shares;\n                } else {\n                    // For every unit of LP Share, the excess PT balance grows by \"hole\".\n                    uint256 hole = diff.divWadDown(lpBal);\n\n                    // Determine how many shares we can redeem without exceeding sell limits.\n                    return maxPTSale.divWadDown(hole).mulDivDown(totalSupply, space.balanceOf(address(this)));\n                }\n            } else {\n                if (ptReserves >= diff) { // We can redeem YTs up to the point where there are PTs in Space to swap for.\n                    // We have enough liquidity to handle the sale.\n                    return shares;\n                } else {\n                    // For every unit of LP Share, the excess YT balance grows by \"hole\".\n                    uint256 hole = diff.divWadDown(lpBal);\n\n                    // Determine how many shares we can redeem without exceeding sell limits.\n                    return ptReserves.divWadDown(hole).mulDivDown(totalSupply, space.balanceOf(address(this)));\n                }\n            }\n        }\n    }\n\n    /* ========== 4626 EXTENSIONS ========== */\n\n    /// @notice Quick exit into the constituent assets.\n    /// @param shares Number of shares to eject with.\n    /// @param receiver Destination address for the constituent assets.\n    /// @param owner Onwer of the shares.\n    /// @return assets Amount of asset redeemable by the given number of shares.\n    /// @return excessBal Amount of excess PT or YT redeemable by the given number of shares.\n    /// @return isExcessPTs Whether the excess token is a YT or PT.\n    function eject(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public returns (uint256 assets, uint256 excessBal, bool isExcessPTs) {\n        if (maturity == MATURITY_NOT_SET) revert ActivePhaseOnly();\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        yt.collect();\n\n        uint256 assetBalPre = asset.balanceOf(address(this));\n        assets = shares.mulDivDown(assetBalPre, totalSupply);\n        (excessBal, isExcessPTs) = _exitAndCombine(shares);\n\n        _burn(owner, shares); // Burn after percent ownership is determined in _exitAndCombine.\n\n        if (isExcessPTs) {\n            pt.transfer(receiver, excessBal);\n        } else {\n            yt.transfer(receiver, excessBal);\n        }\n\n        asset.transfer(receiver, assets = assets + asset.balanceOf(address(this)) - assetBalPre);\n        emit Ejected(msg.sender, receiver, owner, assets, shares,\n            isExcessPTs ? excessBal : 0,\n            isExcessPTs ? 0 : excessBal\n        );\n    }\n\n    /* ========== GENERAL UTILS ========== */\n\n    /// @dev Exit Assets from the Space pool and combine the PTs with YTs we have reserved for the given number of shares.\n    /// @param shares number of shares to exit and combine with.\n    /// @return excessBal Amount of excess PT or YT redeemable by the given number of shares.\n    /// @return isExcessPTs Whether the excess token is a YT or PT.\n    function _exitAndCombine(uint256 shares) internal returns (uint256, bool) {\n        uint256 supply = totalSupply; // Save extra SLOAD.\n\n        uint256 lpBal      = shares.mulDivDown(space.balanceOf(address(this)), supply);\n        uint256 totalPTBal = pt.balanceOf(address(this));\n        uint256 ptShare    = shares.mulDivDown(totalPTBal, supply);\n\n        ERC20[] memory tokens = new ERC20[](2);\n        tokens[1 - pti] = asset;\n        tokens[pti    ] = pt;\n\n        _exitPool(\n            poolId,\n            BalancerVault.ExitPoolRequest({\n                assets: tokens,\n                minAmountsOut: new uint256[](2),\n                userData: abi.encode(lpBal),\n                toInternalBalance: false\n            })\n        );\n\n        ptShare += pt.balanceOf(address(this)) - totalPTBal;\n        uint256 ytBal = shares.mulDivDown(yt.balanceOf(address(this)), supply);\n        unchecked {\n            // Safety: an inequality check is done before subtraction.\n            if (ptShare > ytBal) {\n                divider.combine(address(adapter), maturity, ytBal);\n                return (ptShare - ytBal, true);\n            } else { // Set excess PTs to false if the balances are exactly equal.\n                divider.combine(address(adapter), maturity, ptShare);\n                return (ytBal - ptShare, false);\n            }\n        }\n    }\n\n    /// @notice Transfer any token not included in the set {asset,yt,pt,space} to the rewards recipient.\n    /// @param coin address of the coin to transfer out.\n    function claimRewards(ERC20 coin) external nonReentrant {\n        require(coin != asset);\n        if (maturity != MATURITY_NOT_SET) {\n            require(coin != ERC20(address(yt)) && coin != pt && coin != ERC20(address(space)));\n        }\n        coin.safeTransfer(rewardRecipient, coin.balanceOf(address(this)));\n    }\n\n    /* ========== BALANCER UTILS ========== */\n\n    function _joinPool(bytes32 _poolId, BalancerVault.JoinPoolRequest memory request) internal {\n        balancerVault.joinPool(_poolId, address(this), address(this), request);\n    }\n\n    function _exitPool(bytes32 _poolId, BalancerVault.ExitPoolRequest memory request) internal {\n        balancerVault.exitPool(_poolId, address(this), payable(address(this)), request);\n    }\n\n    function _swap(BalancerVault.SingleSwap memory request) internal {\n        BalancerVault.FundManagement memory funds = BalancerVault.FundManagement({\n            sender: address(this),\n            fromInternalBalance: false,\n            recipient: payable(address(this)),\n            toInternalBalance: false\n        });\n\n        balancerVault.swap(request, funds, 0, type(uint256).max);\n    }\n\n    /* ========== NUMERICAL UTILS ========== */\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n\n    /* ========== INTERNAL VIEWS ========== */\n\n    /// @dev Calculates the amount of Target needed for issuance such that the PT:Target ratio in\n    ///      the Space pool will be preserved after issuing and joining issued PTs and remaining Target.\n    /// @return asset Amount of Target that should be used for issuance.\n    function _getTargetForIssuance(uint256 ptReserves, uint256 targetReserves, uint256 targetBal, uint256 scale)\n        internal view returns (uint256)\n    {\n        return targetBal.mulWadUp(ptReserves.divWadUp(\n            scale.mulWadDown(1e18 - ifee).mulWadDown(targetReserves) + ptReserves\n        ));\n    }\n\n    /// @dev Get PT and Target reserve balances for the current Space pool.\n    /// @return ptReserves PT reserve amount.\n    /// @return targetReserves Target reserve amount.\n    function _getSpaceReserves() internal view returns (uint256, uint256) {\n        (, uint256[] memory balances, ) = balancerVault.getPoolTokens(poolId);\n        uint256 _pti = pti;\n        return (balances[_pti], balances[1 - _pti]);\n    }\n\n    /// @dev DecomposeShares works to break shares into their constituent parts,\n    ///      and also preview the assets required to mint a given number of shares.\n    /// @return targetAmount Target the number of shares has a right to.\n    /// @return ptAmount PTs the number of shares has a right to.\n    /// @return ytAmount YTs the number of shares has a right to.\n    /// @return lpAmount Space LP shares the number of shares has a right to.\n    function _decomposeShares(uint256 ptReserves, uint256 targetReserves, uint256 shares, bool withLoose)\n        internal view returns (uint256, uint256, uint256, uint256)\n    {\n        uint256 supply      = totalSupply;\n        uint256 totalLPBal  = space.balanceOf(address(this));\n        uint256 spaceSupply = space.adjustedTotalSupply();\n\n        // Shares have a right to a portion of the PTs/asset floating around unencombered in this contract.\n        return (\n            shares.mulDivDown(totalLPBal.mulDivUp(targetReserves, spaceSupply) + (withLoose ? asset.balanceOf(address(this)) : 0), supply),\n            shares.mulDivDown(totalLPBal.mulDivUp(ptReserves, spaceSupply) + (withLoose ? pt.balanceOf(address(this)) : 0), supply),\n            shares.mulDivDown(yt.balanceOf(address(this)), supply),\n            shares.mulDivDown(totalLPBal, supply)\n        );\n    }\n\n    /* ========== SPACE POOL SOLVERS ========== */\n\n    /// @notice Determine the maximum number of PTs we can sell into the current space pool without\n    ///         exceeding the current `maxRate`.\n    /// @return ptAmount Maximum number of PTs.\n    function _maxPTSell(uint256 ptReserves, uint256 targetReserves, uint256 spaceSupply) internal view returns (uint256) {\n        (uint256 eqPTReserves, ) = space.getEQReserves(\n            maxRate, // Max acceptable implied rate.\n            maturity,\n            ptReserves,\n            targetReserves,\n            spaceSupply,\n            space.g2()\n        );\n\n        return ptReserves >= eqPTReserves ? 0 : eqPTReserves - ptReserves; // Edge case: the pool is already above the max rate.\n    }\n\n    /* ========== ADMIN ========== */\n\n    /// @notice Set address-based admin params, only callable by the owner.\n    /// @param what Admin param to update.\n    /// @param data Address to set the param to.\n    function setParam(bytes32 what, address data) external {\n        require(msg.sender == owner);\n        if (what == \"SPACE_FACTORY\") spaceFactory = SpaceFactoryLike(data);\n        else if (what == \"PERIPHERY\") periphery = PeripheryLike(data);\n        else if (what == \"OWNER\") owner = data;\n        else revert UnrecognizedParam(what);\n        emit ParamChanged(what, data);\n    }\n\n    /// @notice Set uint-based admin params, only callable by the owner.\n    /// @param what Admin param to update.\n    /// @param data Uint to set the param to.\n    function setParam(bytes32 what, uint256 data) external {\n        require(msg.sender == owner);\n        if (what == \"MAX_RATE\") maxRate = data;\n        else if (what == \"TARGET_DURATION\") targetDuration = data;\n        else if (what == \"COOLDOWN\") {\n            require(lastSettle == 0 || maturity != MATURITY_NOT_SET); // Can't update cooldown during cooldown period.\n            cooldown = data;\n        }\n        else revert UnrecognizedParam(what);\n        emit ParamChanged(what, data);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event ParamChanged(bytes32 what, address newData);\n    event ParamChanged(bytes32 what, uint256 newData);\n\n    event Rolled(uint256 nextMaturity, uint256 initScale, address space, address roller);\n    event Ejected(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares,\n        uint256 pts,\n        uint256 yts\n    );\n}\n\ncontract RollerUtils {\n    using FixedPointMathLib for uint256;\n\n    uint256 internal constant SECONDS_PER_YEAR = 31536000;\n    uint256 internal constant ONE = 1e18;\n\n    address internal immutable divider;\n\n    constructor(address _divider) { divider = _divider; }\n\n    /// @notice Calculate a maturity timestamp around x months in the future on exactly the top of the month.\n    /// @param monthsForward Number of months in to advance forward.\n    /// @return timestamp The timestamp around the number of months forward given, exactly at 00:00 UTC on the top of the month.\n    function getFutureMaturity(uint256 monthsForward) public view returns (uint256) {\n        (uint256 year, uint256 month, ) = DateTime.timestampToDate(DateTime.addMonths(block.timestamp, monthsForward));\n        return DateTime.timestampFromDateTime(year, month, 1 /* top of the month */, 0, 0, 0);\n    }\n\n    /// @notice Calculate a maturity timestamp around x months in the future on exactly the top of the month.\n    /// @param periphery Currently active Sense Periphery contract.\n    /// @param adapter Adapter associated with the Series who's Space data this function is fetching.\n    /// @param maturity Maturity associated with the Series who's Space data this function is fetching.\n    /// @return space Space pool object associated with the given adapter and maturity.\n    /// @return poolId Balancer pool ID associated with the Space pool.\n    /// @return pti Index of the PT token in the Space pool.\n    /// @return scale Current adapter scale value.\n    function getSpaceData(PeripheryLike periphery, OwnedAdapterLike adapter, uint256 maturity)\n        public returns (Space, bytes32, uint256, uint256)\n    {\n        Space _space = periphery.spaceFactory().pools(address(adapter), maturity);\n        return (_space, _space.getPoolId(), _space.pti(), adapter.scale());\n    }\n\n    /// @notice Calculate the APY implied by the change in scale over the Series term (from issuance to maturity), and stretch it to the Space pools' TS period.\n    /// @ param fallbackTargetedRate Optional Target rate to fallback on if nothing can be computed.\n    /// @param adapter Adapter associated with the matured Series to analyze.\n    /// @param prevMaturity Maturity for the maturied Series to analyze.\n    /// @param space Maturity associated with the Series who's Space data this function is fetching.\n    /// @return stretchedRate Rate implied by the previous Series stretched to the Space pool's timestretch period.\n    function getNewTargetedRate(uint256 /* fallbackTargetedRate */, address adapter, uint256 prevMaturity, Space space) public returns (uint256) {\n        (, uint48 prevIssuance, , , , , uint256 iscale, uint256 mscale, ) = DividerLike(divider).series(adapter, prevMaturity);\n\n        require(mscale != 0);\n\n        if (mscale <= iscale) return 0;\n\n        // Calculate the rate implied via the growth in scale over the previous Series term.\n        uint256 rate = (_powWad(\n            (mscale - iscale).divWadDown(iscale) + ONE, ONE.divWadDown((prevMaturity - prevIssuance) * ONE)\n        ) - ONE).mulWadDown(SECONDS_PER_YEAR * ONE);\n\n        // Stretch the targeted rate to match the Space pool's timeshift period.\n        // e.g. if the timestretch is 1/12 years in seconds, then the rate will be transformed from a yearly rate to a 12-year rate.\n        return _powWad(rate + ONE, ONE.divWadDown(space.ts().mulWadDown(SECONDS_PER_YEAR * ONE))) - ONE;\n    }\n\n    /// @dev Safe wad pow function for uint256s.\n    function _powWad(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(x < 1 << 255);\n        require(y < 1 << 255);\n\n        return uint256(FixedPointMathLib.powWad(int256(x), int256(y))); // Assumption: x cannot be negative so this result will never be.\n    }\n}"},"lib/morpho-core-v1/contracts/common/rewards-distribution/RewardsDistributor.sol":{"content":"// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.0;\n\nimport \"../../../lib/solmate/src/utils/SafeTransferLib.sol\";\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Morpho Rewards Distributor.\n/// @author Morpho Labs.\n/// @custom:contact security@morpho.xyz\n/// @notice This contract allows Morpho users to claim their rewards. This contract is largely inspired by Euler Distributor's contract: https://github.com/euler-xyz/euler-contracts/blob/master/contracts/mining/EulDistributor.sol.\ncontract RewardsDistributor is Ownable {\n    using SafeTransferLib for ERC20;\n\n    /// STORAGE ///\n\n    ERC20 public immutable MORPHO;\n    bytes32 public currRoot; // The merkle tree's root of the current rewards distribution.\n    bytes32 public prevRoot; // The merkle tree's root of the previous rewards distribution.\n    mapping(address => uint256) public claimed; // The rewards already claimed. account -> amount.\n\n    /// EVENTS ///\n\n    /// @notice Emitted when the root is updated.\n    /// @param newRoot The new merkle's tree root.\n    event RootUpdated(bytes32 newRoot);\n\n    /// @notice Emitted when MORPHO tokens are withdrawn.\n    /// @param to The address of the recipient.\n    /// @param amount The amount of MORPHO tokens withdrawn.\n    event MorphoWithdrawn(address to, uint256 amount);\n\n    /// @notice Emitted when an account claims rewards.\n    /// @param account The address of the claimer.\n    /// @param amount The amount of rewards claimed.\n    event RewardsClaimed(address account, uint256 amount);\n\n    /// ERRORS ///\n\n    /// @notice Thrown when the proof is invalid or expired.\n    error ProofInvalidOrExpired();\n\n    /// @notice Thrown when the claimer has already claimed the rewards.\n    error AlreadyClaimed();\n\n    /// CONSTRUCTOR ///\n\n    /// @notice Constructs Morpho's RewardsDistributor contract.\n    /// @param _morpho The address of the MORPHO token to distribute.\n    constructor(address _morpho) {\n        MORPHO = ERC20(_morpho);\n    }\n\n    /// EXTERNAL ///\n\n    /// @notice Updates the current merkle tree's root.\n    /// @param _newRoot The new merkle tree's root.\n    function updateRoot(bytes32 _newRoot) external onlyOwner {\n        prevRoot = currRoot;\n        currRoot = _newRoot;\n        emit RootUpdated(_newRoot);\n    }\n\n    /// @notice Withdraws MORPHO tokens to a recipient.\n    /// @param _to The address of the recipient.\n    /// @param _amount The amount of MORPHO tokens to transfer.\n    function withdrawMorphoTokens(address _to, uint256 _amount) external onlyOwner {\n        uint256 morphoBalance = MORPHO.balanceOf(address(this));\n        uint256 toWithdraw = morphoBalance < _amount ? morphoBalance : _amount;\n        MORPHO.safeTransfer(_to, toWithdraw);\n        emit MorphoWithdrawn(_to, toWithdraw);\n    }\n\n    /// @notice Claims rewards.\n    /// @param _account The address of the claimer.\n    /// @param _claimable The overall claimable amount of token rewards.\n    /// @param _proof The merkle proof that validates this claim.\n    function claim(\n        address _account,\n        uint256 _claimable,\n        bytes32[] calldata _proof\n    ) external {\n        bytes32 candidateRoot = MerkleProof.processProof(\n            _proof,\n            keccak256(abi.encodePacked(_account, _claimable))\n        );\n        if (candidateRoot != currRoot && candidateRoot != prevRoot) revert ProofInvalidOrExpired();\n\n        uint256 alreadyClaimed = claimed[_account];\n        if (_claimable <= alreadyClaimed) revert AlreadyClaimed();\n\n        uint256 amount;\n        unchecked {\n            amount = _claimable - alreadyClaimed;\n        }\n\n        claimed[_account] = _claimable;\n\n        MORPHO.safeTransfer(_account, amount);\n        emit RewardsClaimed(_account, amount);\n    }\n}\n"},"lib/auto-roller/src/test/utils/MockOwnedAdapter.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { MockERC20 } from \"solmate/src/test/utils/mocks/MockERC20.sol\";\n\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { BaseAdapter } from \"@sense-finance/v1-core/src/adapters/abstract/BaseAdapter.sol\";\n\nimport { AutoRoller, SpaceFactoryLike } from \"../../AutoRoller.sol\";\n\ninterface Opener {\n    function onSponsorWindowOpened(address, uint256) external;\n}\n\nabstract contract OwnableAdapter is BaseAdapter {\n    function openSponsorWindow() external virtual {\n        Opener(msg.sender).onSponsorWindowOpened(address(0), 0);\n    }\n}\n\ncontract MockOwnableAdapter is OwnableAdapter, Trust {\n    uint256 public override scale = 1.1e18;\n    uint256 internal open = 1;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _underlying,\n        AdapterParams memory _adapterParams\n    ) BaseAdapter(_divider, _target, _underlying, 0.0012e18, _adapterParams) Trust(msg.sender) { }\n\n    function scaleStored() external view virtual override returns (uint256 _scale) {\n        _scale = scale;\n    }\n\n    function wrapUnderlying(uint256 uBal) external virtual override returns (uint256 amountOut) {\n        MockERC20 target = MockERC20(target);\n        MockERC20 underlying = MockERC20(underlying);\n\n        uint256 tDecimals = target.decimals();\n        uint256 uDecimals = underlying.decimals();\n\n        underlying.transferFrom(msg.sender, address(this), uBal);\n        if (tDecimals == uDecimals) {\n            amountOut = uBal * 1e18 / scale;\n        } else {\n            amountOut = uDecimals < tDecimals ?\n                uBal * 1e18 / scale * (tDecimals - uDecimals) ** 10 :\n                uBal * 1e18 / scale / (uDecimals - tDecimals) ** 10;\n        }\n\n        target.mint(msg.sender, amountOut);\n    }\n\n    function unwrapTarget(uint256 tBal) external virtual override returns (uint256 amountOut) {\n        MockERC20 target = MockERC20(target);\n        MockERC20 underlying = MockERC20(underlying);\n\n        uint256 tDecimals = target.decimals();\n        uint256 uDecimals = underlying.decimals();\n\n        target.transferFrom(msg.sender, address(this), tBal);\n        if (tDecimals == uDecimals) {\n            amountOut = tBal * scale / 1e18;\n        } else {\n            amountOut = uDecimals < tDecimals ?\n                tBal * scale / 1e18 / (tDecimals - uDecimals) ** 10 :\n                tBal * scale / 1e18 * (uDecimals - tDecimals) ** 10;\n        }\n            \n        underlying.mint(msg.sender, amountOut);\n    }\n\n    function getUnderlyingPrice() external view virtual override returns (uint256) {\n        return 1e18;\n    }\n\n    function setScale(uint256 _scale) external {\n        scale = _scale;\n    }\n\n    function openSponsorWindow() external override requiresTrust {\n        open = 2;\n        Opener(msg.sender).onSponsorWindowOpened(adapterParams.stake, adapterParams.stakeSize);\n        open = 1;\n    }\n\n    function getMaturityBounds() external view override returns (uint256, uint256) {\n        return open == 2 ? (0, type(uint64).max / 2) : (0, 0);\n    }\n}"},"@sense-finance/v1-core/src/Divider.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\nimport { ReentrancyGuard } from \"solmate/src/utils/ReentrancyGuard.sol\";\nimport { DateTime } from \"./external/DateTime.sol\";\nimport { FixedMath } from \"./external/FixedMath.sol\";\n\n// Internal references\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\nimport { Levels } from \"@sense-finance/v1-utils/src/libs/Levels.sol\";\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { YT } from \"./tokens/YT.sol\";\nimport { Token } from \"./tokens/Token.sol\";\nimport { BaseAdapter as Adapter } from \"./adapters/abstract/BaseAdapter.sol\";\n\n/// @title Sense Divider: Divide Assets in Two\n/// @author fedealconada + jparklev\n/// @notice You can use this contract to issue, combine, and redeem Sense ERC20 Principal and Yield Tokens\ncontract Divider is Trust, ReentrancyGuard, Pausable {\n    using SafeTransferLib for ERC20;\n    using FixedMath for uint256;\n    using Levels for uint256;\n\n    /* ========== PUBLIC CONSTANTS ========== */\n\n    /// @notice Buffer before and after the actual maturity in which only the sponsor can settle the Series\n    uint256 public constant SPONSOR_WINDOW = 3 hours;\n\n    /// @notice Buffer after the sponsor window in which anyone can settle the Series\n    uint256 public constant SETTLEMENT_WINDOW = 3 hours;\n\n    /// @notice 5% issuance fee cap\n    uint256 public constant ISSUANCE_FEE_CAP = 0.05e18;\n\n    /* ========== PUBLIC MUTABLE STORAGE ========== */\n\n    address public periphery;\n\n    /// @notice Sense community multisig\n    address public immutable cup;\n\n    /// @notice Principal/Yield tokens deployer\n    address public immutable tokenHandler;\n\n    /// @notice Permissionless flag\n    bool public permissionless;\n\n    /// @notice Guarded launch flag\n    bool public guarded = true;\n\n    /// @notice Number of adapters (including turned off)\n    uint248 public adapterCounter;\n\n    /// @notice adapter ID -> adapter address\n    mapping(uint256 => address) public adapterAddresses;\n\n    /// @notice adapter data\n    mapping(address => AdapterMeta) public adapterMeta;\n\n    /// @notice adapter -> maturity -> Series\n    mapping(address => mapping(uint256 => Series)) public series;\n\n    /// @notice adapter -> maturity -> user -> lscale (last scale)\n    mapping(address => mapping(uint256 => mapping(address => uint256))) public lscales;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct Series {\n        // Principal ERC20 token\n        address pt;\n        // Timestamp of series initialization\n        uint48 issuance;\n        // Yield ERC20 token\n        address yt;\n        // % of underlying principal initially reserved for Yield\n        uint96 tilt;\n        // Actor who initialized the Series\n        address sponsor;\n        // Tracks fees due to the series' settler\n        uint256 reward;\n        // Scale at issuance\n        uint256 iscale;\n        // Scale at maturity\n        uint256 mscale;\n        // Max scale value from this series' lifetime\n        uint256 maxscale;\n    }\n\n    struct AdapterMeta {\n        // Adapter ID\n        uint248 id;\n        // Adapter enabled/disabled\n        bool enabled;\n        // Max amount of Target allowed to be issued\n        uint256 guard;\n        // Adapter level\n        uint248 level;\n    }\n\n    constructor(address _cup, address _tokenHandler) Trust(msg.sender) {\n        cup = _cup;\n        tokenHandler = _tokenHandler;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /// @notice Enable an adapter\n    /// @dev when permissionless is disabled, only the Periphery can onboard adapters\n    /// @dev after permissionless is enabled, anyone can onboard adapters\n    /// @param adapter Adapter's address\n    function addAdapter(address adapter) external whenNotPaused {\n        if (!permissionless && msg.sender != periphery) revert Errors.OnlyPermissionless();\n        if (adapterMeta[adapter].id > 0 && !adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        _setAdapter(adapter, true);\n    }\n\n    /// @notice Initializes a new Series\n    /// @dev Deploys two ERC20 contracts, one for PTs and the other one for YTs\n    /// @dev Transfers some fixed amount of stake asset to this contract\n    /// @param adapter Adapter to associate with the Series\n    /// @param maturity Maturity date for the new Series, in units of unix time\n    /// @param sponsor Sponsor of the Series that puts up a token stake and receives the issuance fees\n    function initSeries(\n        address adapter,\n        uint256 maturity,\n        address sponsor\n    ) external nonReentrant whenNotPaused returns (address pt, address yt) {\n        if (periphery != msg.sender) revert Errors.OnlyPeriphery();\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        if (_exists(adapter, maturity)) revert Errors.DuplicateSeries();\n        if (!_isValid(adapter, maturity)) revert Errors.InvalidMaturity();\n\n        // Transfer stake asset stake from caller to adapter\n        (address target, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n\n        // Deploy Principal & Yield Tokens for this new Series\n        (pt, yt) = TokenHandler(tokenHandler).deploy(adapter, adapterMeta[adapter].id, maturity);\n\n        // Initialize the new Series struct\n        uint256 scale = Adapter(adapter).scale();\n\n        series[adapter][maturity].pt = pt;\n        series[adapter][maturity].issuance = uint48(block.timestamp);\n        series[adapter][maturity].yt = yt;\n        series[adapter][maturity].tilt = uint96(Adapter(adapter).tilt());\n        series[adapter][maturity].sponsor = sponsor;\n        series[adapter][maturity].iscale = scale;\n        series[adapter][maturity].maxscale = scale;\n\n        ERC20(stake).safeTransferFrom(msg.sender, adapter, stakeSize);\n\n        emit SeriesInitialized(adapter, maturity, pt, yt, sponsor, target);\n    }\n\n    /// @notice Settles a Series and transfers the settlement reward to the caller\n    /// @dev The Series' sponsor has a grace period where only they can settle the Series\n    /// @dev After that, the reward becomes MEV\n    /// @param adapter Adapter to associate with the Series\n    /// @param maturity Maturity date for the new Series\n    function settleSeries(address adapter, uint256 maturity) external nonReentrant whenNotPaused {\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n        if (_settled(adapter, maturity)) revert Errors.AlreadySettled();\n        if (!_canBeSettled(adapter, maturity)) revert Errors.OutOfWindowBoundaries();\n\n        // The maturity scale value is all a Series needs for us to consider it \"settled\"\n        uint256 mscale = Adapter(adapter).scale();\n        series[adapter][maturity].mscale = mscale;\n\n        if (mscale > series[adapter][maturity].maxscale) {\n            series[adapter][maturity].maxscale = mscale;\n        }\n\n        // Reward the caller for doing the work of settling the Series at around the correct time\n        (address target, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n        ERC20(target).safeTransferFrom(adapter, msg.sender, series[adapter][maturity].reward);\n        ERC20(stake).safeTransferFrom(adapter, msg.sender, stakeSize);\n\n        emit SeriesSettled(adapter, maturity, msg.sender);\n    }\n\n    /// @notice Mint Principal & Yield Tokens of a specific Series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series [unix time]\n    /// @param tBal Balance of Target to deposit\n    /// @dev The balance of PTs and YTs minted will be the same value in units of underlying (less fees)\n    function issue(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal\n    ) external nonReentrant whenNotPaused returns (uint256 uBal) {\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n        if (_settled(adapter, maturity)) revert Errors.IssueOnSettle();\n\n        uint256 level = adapterMeta[adapter].level;\n        if (level.issueRestricted() && msg.sender != adapter) revert Errors.IssuanceRestricted();\n\n        ERC20 target = ERC20(Adapter(adapter).target());\n\n        // Take the issuance fee out of the deposited Target, and put it towards the settlement reward\n        uint256 issuanceFee = Adapter(adapter).ifee();\n        if (issuanceFee > ISSUANCE_FEE_CAP) revert Errors.IssuanceFeeCapExceeded();\n        uint256 fee = tBal.fmul(issuanceFee);\n\n        unchecked {\n            // Safety: bounded by the Target's total token supply\n            series[adapter][maturity].reward += fee;\n        }\n        uint256 tBalSubFee = tBal - fee;\n\n        // Ensure the caller won't hit the issuance cap with this action\n        unchecked {\n            // Safety: bounded by the Target's total token supply\n            if (guarded && target.balanceOf(adapter) + tBal > adapterMeta[address(adapter)].guard)\n                revert Errors.GuardCapReached();\n        }\n\n        // Update values on adapter\n        Adapter(adapter).notify(msg.sender, tBalSubFee, true);\n\n        uint256 scale = level.collectDisabled() ? series[adapter][maturity].iscale : Adapter(adapter).scale();\n\n        // Determine the amount of Underlying equal to the Target being sent in (the principal)\n        uBal = tBalSubFee.fmul(scale);\n\n        // If the caller has not collected on YT before, use the current scale, otherwise\n        // use the harmonic mean of the last and the current scale value\n        lscales[adapter][maturity][msg.sender] = lscales[adapter][maturity][msg.sender] == 0\n            ? scale\n            : _reweightLScale(\n                adapter,\n                maturity,\n                YT(series[adapter][maturity].yt).balanceOf(msg.sender),\n                uBal,\n                msg.sender,\n                scale\n            );\n\n        // Mint equal amounts of PT and YT\n        Token(series[adapter][maturity].pt).mint(msg.sender, uBal);\n        YT(series[adapter][maturity].yt).mint(msg.sender, uBal);\n\n        target.safeTransferFrom(msg.sender, adapter, tBal);\n\n        emit Issued(adapter, maturity, uBal, msg.sender);\n    }\n\n    /// @notice Reconstitute Target by burning PT and YT\n    /// @dev Explicitly burns YTs before maturity, and implicitly does it at/after maturity through `_collect()`\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal Balance of PT and YT to burn\n    function combine(\n        address adapter,\n        uint256 maturity,\n        uint256 uBal\n    ) external nonReentrant whenNotPaused returns (uint256 tBal) {\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n\n        uint256 level = adapterMeta[adapter].level;\n        if (level.combineRestricted() && msg.sender != adapter) revert Errors.CombineRestricted();\n\n        // Burn the PT\n        Token(series[adapter][maturity].pt).burn(msg.sender, uBal);\n\n        // Collect whatever excess is due\n        uint256 collected = _collect(msg.sender, adapter, maturity, uBal, uBal, address(0));\n\n        uint256 cscale = series[adapter][maturity].mscale;\n        bool settled = _settled(adapter, maturity);\n        if (!settled) {\n            // If it's not settled, then YT won't be burned automatically in `_collect()`\n            YT(series[adapter][maturity].yt).burn(msg.sender, uBal);\n            // If collect has been restricted, use the initial scale, otherwise use the current scale\n            cscale = level.collectDisabled()\n                ? series[adapter][maturity].iscale\n                : lscales[adapter][maturity][msg.sender];\n        }\n\n        // Convert from units of Underlying to units of Target\n        tBal = uBal.fdiv(cscale);\n        ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, msg.sender, tBal);\n\n        // Notify only when Series is not settled as when it is, the _collect() call above would trigger a _redeemYT which will call notify\n        if (!settled) Adapter(adapter).notify(msg.sender, tBal, false);\n        unchecked {\n            // Safety: bounded by the Target's total token supply\n            tBal += collected;\n        }\n        emit Combined(adapter, maturity, tBal, msg.sender);\n    }\n\n    /// @notice Burn PT of a Series once it's been settled\n    /// @dev The balance of redeemable Target is a function of the change in Scale\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal Amount of PT to burn, which should be equivalent to the amount of Underlying owed to the caller\n    function redeem(\n        address adapter,\n        uint256 maturity,\n        uint256 uBal\n    ) external nonReentrant whenNotPaused returns (uint256 tBal) {\n        // If a Series is settled, we know that it must have existed as well, so that check is unnecessary\n        if (!_settled(adapter, maturity)) revert Errors.NotSettled();\n\n        uint256 level = adapterMeta[adapter].level;\n        if (level.redeemRestricted() && msg.sender != adapter) revert Errors.RedeemRestricted();\n\n        // Burn the caller's PT\n        Token(series[adapter][maturity].pt).burn(msg.sender, uBal);\n\n        // Principal Token holder's share of the principal = (1 - part of the principal that belongs to Yield)\n        uint256 zShare = FixedMath.WAD - series[adapter][maturity].tilt;\n\n        // If Principal Token are at a loss and Yield have some principal to help cover the shortfall,\n        // take what we can from Yield Token's principal\n        if (series[adapter][maturity].mscale.fdiv(series[adapter][maturity].maxscale) >= zShare) {\n            tBal = (uBal * zShare) / series[adapter][maturity].mscale;\n        } else {\n            tBal = uBal.fdiv(series[adapter][maturity].maxscale);\n        }\n\n        if (!level.redeemHookDisabled()) {\n            Adapter(adapter).onRedeem(uBal, series[adapter][maturity].mscale, series[adapter][maturity].maxscale, tBal);\n        }\n\n        ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, msg.sender, tBal);\n        emit PTRedeemed(adapter, maturity, tBal);\n    }\n\n    function collect(\n        address usr,\n        address adapter,\n        uint256 maturity,\n        uint256 uBalTransfer,\n        address to\n    ) external nonReentrant onlyYT(adapter, maturity) whenNotPaused returns (uint256 collected) {\n        uint256 uBal = YT(msg.sender).balanceOf(usr);\n        return _collect(usr, adapter, maturity, uBal, uBalTransfer > 0 ? uBalTransfer : uBal, to);\n    }\n\n    /// @notice Collect YT excess before, at, or after maturity\n    /// @dev If `to` is set, we copy the lscale value from usr to this address\n    /// @param usr User who's collecting for their YTs\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal yield Token balance\n    /// @param uBalTransfer original transfer value\n    /// @param to address to set the lscale value from usr\n    function _collect(\n        address usr,\n        address adapter,\n        uint256 maturity,\n        uint256 uBal,\n        uint256 uBalTransfer,\n        address to\n    ) internal returns (uint256 collected) {\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n\n        // If the adapter is disabled, its Yield Token can only collect\n        // if associated Series has been settled, which implies that an admin\n        // has backfilled it\n        if (!adapterMeta[adapter].enabled && !_settled(adapter, maturity)) revert Errors.InvalidAdapter();\n\n        Series memory _series = series[adapter][maturity];\n\n        // Get the scale value from the last time this holder collected (default to maturity)\n        uint256 lscale = lscales[adapter][maturity][usr];\n\n        uint256 level = adapterMeta[adapter].level;\n        if (level.collectDisabled()) {\n            // If this Series has been settled, we ensure everyone's YT will\n            // collect yield accrued since issuance\n            if (_settled(adapter, maturity)) {\n                lscale = series[adapter][maturity].iscale;\n                // If the Series is not settled, we ensure no collections can happen\n            } else {\n                return 0;\n            }\n        }\n\n        // If the Series has been settled, this should be their last collect, so redeem the user's Yield Tokens for them\n        if (_settled(adapter, maturity)) {\n            _redeemYT(usr, adapter, maturity, uBal);\n        } else {\n            // If we're not settled and we're past maturity + the sponsor window,\n            // anyone can settle this Series so revert until someone does\n            if (block.timestamp > maturity + SPONSOR_WINDOW) {\n                revert Errors.CollectNotSettled();\n                // Otherwise, this is a valid pre-settlement collect and we need to determine the scale value\n            } else {\n                uint256 cscale = Adapter(adapter).scale();\n                // If this is larger than the largest scale we've seen for this Series, use it\n                if (cscale > _series.maxscale) {\n                    _series.maxscale = cscale;\n                    lscales[adapter][maturity][usr] = cscale;\n                    // If not, use the previously noted max scale value\n                } else {\n                    lscales[adapter][maturity][usr] = _series.maxscale;\n                }\n            }\n        }\n\n        // Determine how much underlying has accrued since the last time this user collected, in units of Target.\n        // (Or take the last time as issuance if they haven't yet)\n        //\n        // Reminder: `Underlying / Scale = Target`\n        // So the following equation is saying, for some amount of Underlying `u`:\n        // \"Balance of Target that equaled `u` at the last collection _minus_ Target that equals `u` now\"\n        //\n        // Because maxscale must be increasing, the Target balance needed to equal `u` decreases, and that \"excess\"\n        // is what Yield holders are collecting\n        uint256 tBalNow = uBal.fdivUp(_series.maxscale); // preventive round-up towards the protocol\n        uint256 tBalPrev = uBal.fdiv(lscale);\n        unchecked {\n            collected = tBalPrev > tBalNow ? tBalPrev - tBalNow : 0;\n        }\n        ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, usr, collected);\n        Adapter(adapter).notify(usr, collected, false); // Distribute reward tokens\n\n        // If this collect is a part of a token transfer to another address, set the receiver's\n        // last collection to a synthetic scale weighted based on the scale on their last collect,\n        // the time elapsed, and the current scale\n        if (to != address(0)) {\n            uint256 ytBal = YT(_series.yt).balanceOf(to);\n            // If receiver holds yields, we set lscale to a computed \"synthetic\" lscales value that,\n            // for the updated yield balance, still assigns the correct amount of yield.\n            lscales[adapter][maturity][to] = ytBal > 0\n                ? _reweightLScale(adapter, maturity, ytBal, uBalTransfer, to, _series.maxscale)\n                : _series.maxscale;\n            uint256 tBalTransfer = uBalTransfer.fdiv(_series.maxscale);\n            Adapter(adapter).notify(usr, tBalTransfer, false);\n            Adapter(adapter).notify(to, tBalTransfer, true);\n        }\n        series[adapter][maturity] = _series;\n\n        emit Collected(adapter, maturity, collected);\n    }\n\n    /// @notice calculate the harmonic mean of the current scale and the last scale,\n    /// weighted by amounts associated with each\n    function _reweightLScale(\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal,\n        uint256 uBal,\n        address receiver,\n        uint256 scale\n    ) internal view returns (uint256) {\n        // Target Decimals * 18 Decimals [from fdiv] / (Target Decimals * 18 Decimals [from fdiv] / 18 Decimals)\n        // = 18 Decimals, which is the standard for scale values\n        return (ytBal + uBal).fdiv((ytBal.fdiv(lscales[adapter][maturity][receiver]) + uBal.fdiv(scale)));\n    }\n\n    function _redeemYT(\n        address usr,\n        address adapter,\n        uint256 maturity,\n        uint256 uBal\n    ) internal {\n        // Burn the users's YTs\n        YT(series[adapter][maturity].yt).burn(usr, uBal);\n\n        // Default principal for a YT\n        uint256 tBal = 0;\n\n        // Principal Token holder's share of the principal = (1 - part of the principal that belongs to Yield Tokens)\n        uint256 zShare = FixedMath.WAD - series[adapter][maturity].tilt;\n\n        // If PTs are at a loss and YTs had their principal cut to help cover the shortfall,\n        // calculate how much YTs have left\n        if (series[adapter][maturity].mscale.fdiv(series[adapter][maturity].maxscale) >= zShare) {\n            tBal = uBal.fdiv(series[adapter][maturity].maxscale) - (uBal * zShare) / series[adapter][maturity].mscale;\n            ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, usr, tBal);\n        }\n\n        // Always notify the Adapter of the full Target balance that will no longer\n        // have its rewards distributed\n        Adapter(adapter).notify(usr, uBal.fdivUp(series[adapter][maturity].maxscale), false);\n\n        emit YTRedeemed(adapter, maturity, tBal);\n    }\n\n    /* ========== ADMIN ========== */\n\n    /// @notice Enable or disable a adapter\n    /// @param adapter Adapter's address\n    /// @param isOn Flag setting this adapter to enabled or disabled\n    function setAdapter(address adapter, bool isOn) public requiresTrust {\n        _setAdapter(adapter, isOn);\n    }\n\n    /// @notice Set adapter's guard\n    /// @param adapter Adapter address\n    /// @param cap The max target that can be deposited on the Adapter\n    function setGuard(address adapter, uint256 cap) external requiresTrust {\n        adapterMeta[adapter].guard = cap;\n        emit GuardChanged(adapter, cap);\n    }\n\n    /// @notice Set guarded mode\n    /// @param _guarded bool\n    function setGuarded(bool _guarded) external requiresTrust {\n        guarded = _guarded;\n        emit GuardedChanged(_guarded);\n    }\n\n    /// @notice Set periphery's contract\n    /// @param _periphery Target address\n    function setPeriphery(address _periphery) external requiresTrust {\n        periphery = _periphery;\n        emit PeripheryChanged(_periphery);\n    }\n\n    /// @notice Set paused flag\n    /// @param _paused boolean\n    function setPaused(bool _paused) external requiresTrust {\n        _paused ? _pause() : _unpause();\n    }\n\n    /// @notice Set permissioless mode\n    /// @param _permissionless bool\n    function setPermissionless(bool _permissionless) external requiresTrust {\n        permissionless = _permissionless;\n        emit PermissionlessChanged(_permissionless);\n    }\n\n    /// @notice Backfill a Series' Scale value at maturity if keepers failed to settle it\n    /// @param adapter Adapter's address\n    /// @param maturity Maturity date for the Series\n    /// @param mscale Value to set as the Series' Scale value at maturity\n    /// @param _usrs Values to set on lscales mapping\n    /// @param _lscales Values to set on lscales mapping\n    function backfillScale(\n        address adapter,\n        uint256 maturity,\n        uint256 mscale,\n        address[] calldata _usrs,\n        uint256[] calldata _lscales\n    ) external requiresTrust {\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n\n        uint256 cutoff = maturity + SPONSOR_WINDOW + SETTLEMENT_WINDOW;\n        // Admin can never backfill before maturity\n        if (block.timestamp <= cutoff) revert Errors.OutOfWindowBoundaries();\n\n        // Set user's last scale values the Series (needed for the `collect` method)\n        for (uint256 i = 0; i < _usrs.length; i++) {\n            lscales[adapter][maturity][_usrs[i]] = _lscales[i];\n        }\n\n        if (mscale > 0) {\n            Series memory _series = series[adapter][maturity];\n            // Set the maturity scale for the Series (needed for `redeem` methods)\n            series[adapter][maturity].mscale = mscale;\n            if (mscale > _series.maxscale) {\n                series[adapter][maturity].maxscale = mscale;\n            }\n\n            (address target, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n\n            address stakeDst = adapterMeta[adapter].enabled ? cup : _series.sponsor;\n            ERC20(target).safeTransferFrom(adapter, cup, _series.reward);\n            series[adapter][maturity].reward = 0;\n            ERC20(stake).safeTransferFrom(adapter, stakeDst, stakeSize);\n        }\n\n        emit Backfilled(adapter, maturity, mscale, _usrs, _lscales);\n    }\n\n    /* ========== INTERNAL VIEWS ========== */\n\n    function _exists(address adapter, uint256 maturity) internal view returns (bool) {\n        return series[adapter][maturity].pt != address(0);\n    }\n\n    function _settled(address adapter, uint256 maturity) internal view returns (bool) {\n        return series[adapter][maturity].mscale > 0;\n    }\n\n    function _canBeSettled(address adapter, uint256 maturity) internal view returns (bool) {\n        uint256 cutoff = maturity + SPONSOR_WINDOW + SETTLEMENT_WINDOW;\n        // If the sender is the sponsor for the Series\n        if (msg.sender == series[adapter][maturity].sponsor) {\n            return maturity - SPONSOR_WINDOW <= block.timestamp && cutoff >= block.timestamp;\n        } else {\n            return maturity + SPONSOR_WINDOW < block.timestamp && cutoff >= block.timestamp;\n        }\n    }\n\n    function _isValid(address adapter, uint256 maturity) internal view returns (bool) {\n        (uint256 minm, uint256 maxm) = Adapter(adapter).getMaturityBounds();\n        if (maturity < block.timestamp + minm || maturity > block.timestamp + maxm) return false;\n        (, , uint256 day, uint256 hour, uint256 minute, uint256 second) = DateTime.timestampToDateTime(maturity);\n\n        if (hour != 0 || minute != 0 || second != 0) return false;\n        uint256 mode = Adapter(adapter).mode();\n        if (mode == 0) {\n            return day == 1;\n        }\n        if (mode == 1) {\n            return DateTime.getDayOfWeek(maturity) == 1;\n        }\n        return false;\n    }\n\n    /* ========== INTERNAL UTILS ========== */\n\n    function _setAdapter(address adapter, bool isOn) internal {\n        AdapterMeta memory am = adapterMeta[adapter];\n        if (am.enabled == isOn) revert Errors.ExistingValue();\n        am.enabled = isOn;\n\n        // If this adapter is being added for the first time\n        if (isOn && am.id == 0) {\n            am.id = ++adapterCounter;\n            adapterAddresses[am.id] = adapter;\n        }\n\n        // Set level and target (can only be done once);\n        am.level = uint248(Adapter(adapter).level());\n        adapterMeta[adapter] = am;\n        emit AdapterChanged(adapter, am.id, isOn);\n    }\n\n    /* ========== PUBLIC GETTERS ========== */\n\n    /// @notice Returns address of Principal Token\n    function pt(address adapter, uint256 maturity) public view returns (address) {\n        return series[adapter][maturity].pt;\n    }\n\n    /// @notice Returns address of Yield Token\n    function yt(address adapter, uint256 maturity) public view returns (address) {\n        return series[adapter][maturity].yt;\n    }\n\n    function mscale(address adapter, uint256 maturity) public view returns (uint256) {\n        return series[adapter][maturity].mscale;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyYT(address adapter, uint256 maturity) {\n        if (series[adapter][maturity].yt != msg.sender) revert Errors.OnlyYT();\n        _;\n    }\n\n    /* ========== LOGS ========== */\n\n    /// @notice Admin\n    event Backfilled(\n        address indexed adapter,\n        uint256 indexed maturity,\n        uint256 mscale,\n        address[] _usrs,\n        uint256[] _lscales\n    );\n    event GuardChanged(address indexed adapter, uint256 cap);\n    event AdapterChanged(address indexed adapter, uint256 indexed id, bool indexed isOn);\n    event PeripheryChanged(address indexed periphery);\n\n    /// @notice Series lifecycle\n    /// *---- beginning\n    event SeriesInitialized(\n        address adapter,\n        uint256 indexed maturity,\n        address pt,\n        address yt,\n        address indexed sponsor,\n        address indexed target\n    );\n    /// -***- middle\n    event Issued(address indexed adapter, uint256 indexed maturity, uint256 balance, address indexed sender);\n    event Combined(address indexed adapter, uint256 indexed maturity, uint256 balance, address indexed sender);\n    event Collected(address indexed adapter, uint256 indexed maturity, uint256 collected);\n    /// ----* end\n    event SeriesSettled(address indexed adapter, uint256 indexed maturity, address indexed settler);\n    event PTRedeemed(address indexed adapter, uint256 indexed maturity, uint256 redeemed);\n    event YTRedeemed(address indexed adapter, uint256 indexed maturity, uint256 redeemed);\n    /// *----* misc\n    event GuardedChanged(bool indexed guarded);\n    event PermissionlessChanged(bool indexed permissionless);\n}\n\ncontract TokenHandler is Trust {\n    /// @notice Program state\n    address public divider;\n\n    constructor() Trust(msg.sender) {}\n\n    function init(address _divider) external requiresTrust {\n        if (divider != address(0)) revert Errors.AlreadyInitialized();\n        divider = _divider;\n    }\n\n    function deploy(\n        address adapter,\n        uint248 id,\n        uint256 maturity\n    ) external returns (address pt, address yt) {\n        if (msg.sender != divider) revert Errors.OnlyDivider();\n\n        ERC20 target = ERC20(Adapter(adapter).target());\n        uint8 decimals = target.decimals();\n        string memory symbol = target.symbol();\n        (string memory d, string memory m, string memory y) = DateTime.toDateString(maturity);\n        string memory date = DateTime.format(maturity);\n        string memory datestring = string(abi.encodePacked(d, \"-\", m, \"-\", y));\n        string memory adapterId = DateTime.uintToString(id);\n        pt = address(\n            new Token(\n                string(abi.encodePacked(date, \" \", symbol, \" Sense Principal Token, A\", adapterId)),\n                string(abi.encodePacked(\"sP-\", symbol, \":\", datestring, \":\", adapterId)),\n                decimals,\n                divider\n            )\n        );\n\n        yt = address(\n            new YT(\n                adapter,\n                maturity,\n                string(abi.encodePacked(date, \" \", symbol, \" Sense Yield Token, A\", adapterId)),\n                string(abi.encodePacked(\"sY-\", symbol, \":\", datestring, \":\", adapterId)),\n                decimals,\n                divider\n            )\n        );\n    }\n}\n"},"@sense-finance/v1-core/src/Periphery.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\nimport { FixedMath } from \"./external/FixedMath.sol\";\nimport { BalancerVault, IAsset } from \"./external/balancer/Vault.sol\";\nimport { BalancerPool } from \"./external/balancer/Pool.sol\";\nimport { IERC3156FlashBorrower } from \"./external/flashloan/IERC3156FlashBorrower.sol\";\nimport { IPermit2 } from \"@sense-finance/v1-core/src/external/IPermit2.sol\";\n\n// Internal references\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { Levels } from \"@sense-finance/v1-utils/src/libs/Levels.sol\";\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { BaseAdapter as Adapter } from \"./adapters/abstract/BaseAdapter.sol\";\nimport { BaseFactory as AdapterFactory } from \"./adapters/abstract/factories/BaseFactory.sol\";\nimport { Divider } from \"./Divider.sol\";\n\ninterface SpaceFactoryLike {\n    function create(address, uint256) external returns (address);\n\n    function pools(address adapter, uint256 maturity) external view returns (address);\n}\n\n/// @title Periphery\ncontract Periphery is Trust, IERC3156FlashBorrower {\n    using FixedMath for uint256;\n    using SafeTransferLib for ERC20;\n    using Levels for uint256;\n\n    /* ========== PUBLIC CONSTANTS ========== */\n\n    /// @notice Lower bound on the amount of Claim tokens one can swap in for Target\n    uint256 public constant MIN_YT_SWAP_IN = 0.000001e18;\n\n    /// @notice Acceptable error when estimating the tokens resulting from a specific swap\n    uint256 public constant PRICE_ESTIMATE_ACCEPTABLE_ERROR = 0.00000001e18;\n\n    /// @notice ETH address\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /* ========== PUBLIC IMMUTABLES ========== */\n\n    /// @notice Sense core Divider address\n    Divider public immutable divider;\n\n    /// @notice Sense core Divider address\n    BalancerVault public immutable balancerVault;\n\n    /// @notice Permit2 contract\n    IPermit2 public immutable permit2;\n\n    // 0x ExchangeProxy address. See https://docs.0x.org/developer-resources/contract-addresses\n    address public immutable exchangeProxy;\n\n    /* ========== PUBLIC MUTABLE STORAGE ========== */\n\n    /// @notice Sense core Divider address\n    SpaceFactoryLike public spaceFactory;\n\n    /// @notice adapter factories -> is supported\n    mapping(address => bool) public factories;\n\n    /// @notice adapter -> bool\n    mapping(address => bool) public verified;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct PoolLiquidity {\n        ERC20[] tokens;\n        uint256[] amounts;\n        uint256 minBptOut;\n    }\n\n    struct PermitData {\n        IPermit2.PermitTransferFrom msg;\n        bytes sig;\n    }\n\n    struct PermitBatchData {\n        IPermit2.PermitBatchTransferFrom msg;\n        bytes sig;\n    }\n\n    struct SwapQuote {\n        ERC20 sellToken;\n        ERC20 buyToken;\n        uint256 amount;\n        address spender;\n        address payable swapTarget;\n        bytes swapCallData;\n    }\n\n    struct AddLiquidityParams {\n        uint256 minAccepted; // Min accepted amount of Target (from the sell of YTs)\n        uint256 minBptOut; // Min BPT the user will accept out for this transaction\n        uint256 deadline; // The UNIX timestamp at which our trade must be completed by - if the transaction is confirmed after this time then the transaction will fail.\n    }\n\n    struct RemoveLiquidityParams {\n        uint256 minAccepted; // Min accepted when swapping PTs to underlying (only used when removing liquidity before maturity)\n        uint256[] minAmountsOut; // Min accepted amounts of PTs and Target given the amount of LP shares provided\n        uint256 deadline; // The UNIX timestamp at which our trade must be completed by - if the transaction is confirmed after this time then the transaction will fail.\n    }\n\n    constructor(\n        address _divider,\n        address _spaceFactory,\n        address _balancerVault,\n        address _permit2,\n        address _exchangeProxy\n    ) Trust(msg.sender) {\n        divider = Divider(_divider);\n        spaceFactory = SpaceFactoryLike(_spaceFactory);\n        balancerVault = BalancerVault(_balancerVault);\n        permit2 = IPermit2(_permit2);\n        exchangeProxy = _exchangeProxy;\n    }\n\n    /* ========== SERIES / ADAPTER MANAGEMENT ========== */\n\n    /// @notice Sponsor a new Series in any adapter previously onboarded onto the Divider\n    /// @dev Called by an external address, initializes a new series in the Divider\n    /// @param adapter Adapter to associate with the Series\n    /// @param maturity Maturity date for the Series, in units of unix time\n    /// @param withPool Whether to deploy a Space pool or not (only works for unverified adapters)\n    function sponsorSeries(\n        address adapter,\n        uint256 maturity,\n        bool withPool\n    ) external returns (address pt, address yt) {\n        (, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n        ERC20(stake).transferFrom(msg.sender, address(this), stakeSize);\n        return _sponsorSeries(adapter, maturity, withPool, stake, stakeSize);\n    }\n\n    /// @notice Sponsor a new Series in any adapter previously onboarded onto the Divider\n    /// @dev Called by an external address, initializes a new series in the Divider\n    /// @param adapter Adapter to associate with the Series\n    /// @param maturity Maturity date for the Series, in units of unix time\n    /// @param withPool Whether to deploy a Space pool or not (only works for unverified adapters)\n    /// @param permit Permit to pull the tokens to swap from\n    /// @param quote Quote with swap details\n    function sponsorSeries(\n        address adapter,\n        uint256 maturity,\n        bool withPool,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external payable returns (address pt, address yt) {\n        (, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), quote.amount);\n        if (address(quote.sellToken) != stake) _fillQuote(quote);\n\n        (pt, yt) = _sponsorSeries(adapter, maturity, withPool, stake, stakeSize);\n\n        // refund any excess stake assets\n        ERC20(stake).safeTransfer(msg.sender, _balanceOf(stake, address(this)));\n\n        // refund any remaining quote.sellToken to receiver\n        _transfer(\n            quote.sellToken,\n            msg.sender,\n            address(quote.sellToken) == ETH\n                ? address(this).balance\n                : _balanceOf(address(quote.sellToken), address(this))\n        );\n    }\n\n    function _sponsorSeries(\n        address adapter,\n        uint256 maturity,\n        bool withPool,\n        address stake,\n        uint256 stakeSize\n    ) internal returns (address pt, address yt) {\n        // Approve divider to withdraw stake assets\n        ERC20(stake).safeApprove(address(divider), stakeSize);\n\n        (pt, yt) = divider.initSeries(adapter, maturity, msg.sender);\n\n        // Space pool is always created for verified adapters whilst is optional for unverified ones.\n        // Automatically queueing series is only for verified adapters\n        if (verified[adapter]) {\n            spaceFactory.create(adapter, maturity);\n        } else {\n            if (withPool) {\n                spaceFactory.create(adapter, maturity);\n            }\n        }\n\n        emit SeriesSponsored(adapter, maturity, msg.sender);\n    }\n\n    /// @notice Deploy and onboard a Adapter\n    /// @dev Called by external address, deploy a new Adapter via an Adapter Factory\n    /// @param f Factory to use\n    /// @param target Target to onboard\n    /// @param data Additional encoded data needed to deploy the adapter\n    function deployAdapter(\n        address f,\n        address target,\n        bytes calldata data\n    ) external returns (address adapter) {\n        if (!factories[f]) revert Errors.FactoryNotSupported();\n        adapter = AdapterFactory(f).deployAdapter(target, data);\n        emit AdapterDeployed(adapter);\n        _verifyAdapter(adapter);\n        _onboardAdapter(adapter, true);\n    }\n\n    /* ========== LIQUIDITY UTILS ========== */\n\n    /// @notice Swap for PTs of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param amt Amount to swap for PTs\n    /// @param minAccepted Min accepted amount of PT\n    /// @param receiver Address to receive the PT\n    /// @param permit Permit to pull the tokens to swap from\n    /// @param quote Quote with swap details\n    /// @dev if quote.sellToken is neither target nor underlying, it will be swapped for underlying\n    /// on 0x and wrapped into the target\n    /// @return ptBal amount of PT received\n    function swapForPTs(\n        address adapter,\n        uint256 maturity,\n        uint256 amt,\n        uint256 deadline,\n        uint256 minAccepted,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external payable returns (uint256 ptBal) {\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), amt);\n        ptBal = _swapTargetForPTs(\n            adapter,\n            maturity,\n            _toTarget(adapter, amt, receiver, quote),\n            deadline,\n            minAccepted,\n            receiver\n        );\n        // refund any remaining quote.sellToken to receiver\n        _transfer(\n            quote.sellToken,\n            receiver,\n            address(quote.sellToken) == ETH\n                ? address(this).balance\n                : _balanceOf(address(quote.sellToken), address(this))\n        );\n    }\n\n    /// @notice Swap to YTs of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param amt Amount to sell\n    /// @param targetToBorrow Amount of Target to borrow\n    /// @param minAccepted Min accepted amount of YT\n    /// @param receiver Address to receive the YT\n    /// @param permit Permit to pull the tokens to swap from\n    /// @param quote Quote with swap details\n    /// @return targetBal amount of Target sent back\n    /// @return ytBal amount of YT received\n    /// @dev if quote.sellToken is neither target nor underlying, it will be swapped for underlying\n    /// on 0x and wrapped into the target\n    function swapForYTs(\n        address adapter,\n        uint256 maturity,\n        uint256 amt,\n        uint256 deadline,\n        uint256 targetToBorrow,\n        uint256 minAccepted,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external payable returns (uint256 targetBal, uint256 ytBal) {\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), amt);\n\n        // swap sellToken to target, borrow more target and swap to YTs\n        (targetBal, ytBal) = _flashBorrowAndSwapToYTs(\n            adapter,\n            maturity,\n            _toTarget(adapter, amt, receiver, quote),\n            deadline,\n            targetToBorrow,\n            minAccepted\n        );\n\n        ERC20(Adapter(adapter).target()).safeTransfer(receiver, targetBal);\n        ERC20(divider.yt(adapter, maturity)).safeTransfer(receiver, ytBal);\n    }\n\n    /// @notice Swap PTs of a particular series\n    /// @param adapter Adapter address for the series\n    /// @param maturity Maturity date for the series\n    /// @param ptBal Balance of PT to sell\n    /// @param minAccepted Min accepted amount of quote.buyToken the user receives\n    /// @param receiver Address to receive the tokens\n    /// @param permit Permit to pull PTs\n    /// @param quote Quote with swap details\n    /// @return amt amount of tokens received\n    /// @dev if quote.buyToken is neither target nor underlying, it will unwrap target\n    /// and swap it on 0x\n    function swapPTs(\n        address adapter,\n        uint256 maturity,\n        uint256 ptBal,\n        uint256 deadline,\n        uint256 minAccepted,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external payable returns (uint256 amt) {\n        amt = _swapSenseToken(adapter, maturity, ptBal, deadline, minAccepted, 0, receiver, permit, quote);\n    }\n\n    /// @notice Swap YTs of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param ytBal Balance of YTs to swap\n    /// @param minAccepted Min accepted amount of tokens when selling them on Space\n    /// @param receiver Address to receive the Target\n    /// @param permit Permit to pull YTs\n    /// @param quote Quote with swap details\n    /// @return amt amount of Target received\n    /// @dev if quote.buyToken is neither target nor underlying, it will unwrap target\n    /// and swap it on 0x\n    function swapYTs(\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal,\n        uint256 deadline,\n        uint256 minAccepted,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external payable returns (uint256 amt) {\n        amt = _swapSenseToken(adapter, maturity, ytBal, deadline, minAccepted, 1, receiver, permit, quote);\n    }\n\n    /// @notice this function is here for backwards compatibility with AutoRoller. It does not suppport\n    /// the use of `deadline` parameter. Use `swapYTs` instead.\n    function swapYTsForTarget(\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal\n    ) external returns (uint256 amt) {\n        ERC20(divider.yt(adapter, maturity)).transferFrom(msg.sender, address(this), ytBal);\n        amt = this.swapYTsForTargetHelper(\n            msg.sender,\n            adapter,\n            maturity,\n            ytBal,\n            PermitData(IPermit2.PermitTransferFrom(IPermit2.TokenPermissions(ERC20(address(0)), 0), 0, 0), \"0x\")\n        );\n        _transfer(ERC20(Adapter(adapter).target()), msg.sender, amt);\n    }\n\n    function swapYTsForTargetHelper(\n        address sender,\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal,\n        PermitData calldata permit\n    ) external returns (uint256 amt) {\n        if (msg.sender != address(this)) revert Errors.OnlyPeriphery();\n        amt = _swapYTsForTarget(sender, adapter, maturity, ytBal, block.timestamp, permit);\n    }\n\n    function _swapSenseToken(\n        address adapter,\n        uint256 maturity,\n        uint256 sellAmt,\n        uint256 deadline,\n        uint256 minAccepted,\n        uint8 mode, // 0 = PTs, 1 = YTs\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) private returns (uint256 amt) {\n        amt = (mode == 1)\n            ? _swapYTsForTarget(msg.sender, adapter, maturity, sellAmt, deadline, permit)\n            : _swapPTsForTarget(adapter, maturity, sellAmt, deadline, permit);\n        amt = _fromTarget(adapter, amt, receiver, quote);\n\n        if (amt < minAccepted) revert Errors.UnexpectedSwapAmount();\n        _transfer(quote.buyToken, receiver, amt);\n    }\n\n    /// @notice Adds liquidity providing any Token\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param amt Amount to provide\n    /// @param params AddLiquidityParams struct with the params for the addLiquidity call\n    /// @param mode 0 = issues and sell YT, 1 = issue and hold YT\n    /// @param receiver Address to receive the BPT\n    /// @param permit Permit to pull the tokens to swap from\n    /// @param quote Quote with swap details\n    /// @dev see return description of _addLiquidity\n    /// @dev if quote.sellToken is neither target nor underlying, it will be swapped for underlying\n    /// on 0x and wrapped into the target\n    function addLiquidity(\n        address adapter,\n        uint256 maturity,\n        uint256 amt,\n        AddLiquidityParams memory params,\n        uint8 mode,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    )\n        external\n        payable\n        returns (\n            uint256 tAmount,\n            uint256 issued,\n            uint256 lpShares\n        )\n    {\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), amt);\n        (tAmount, issued, lpShares) = _addLiquidity(\n            adapter,\n            maturity,\n            _toTarget(adapter, amt, receiver, quote),\n            params,\n            mode,\n            receiver,\n            permit\n        );\n    }\n\n    /// @notice Removes liquidity providing an amount of LP tokens and returns underlying\n    /// @dev More info on `minAmountsOut`: https://github.com/balancer-labs/docs-developers/blob/main/resources/joins-and-exits/pool-exits.md#minamountsout\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param lpBal Balance of LP tokens to provide\n    /// @param params RemoveLiquidityParams struct with the params for the removeLiquidity call\n    /// @param swapPTs Whether to swap PTs or not. If false, it will transfer PTs to the user\n    /// @param receiver Address to receive the Underlying\n    /// @param permit Permit to pull the LP tokens\n    /// @param quote Quote with swap details\n    /// @return amt amount of tokens received and ptBal PTs (in case it's called after maturity and redeem is restricted or intoTarget is false)\n    /// @dev if quote.buyToken is neither target nor underlying, it will unwrap target\n    /// and swap it on 0x\n    /// if quote.buyToken is PT, it will return target and PTs\n    function removeLiquidity(\n        address adapter,\n        uint256 maturity,\n        uint256 lpBal,\n        RemoveLiquidityParams memory params,\n        bool swapPTs,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external payable returns (uint256 amt, uint256 ptBal) {\n        (amt, ptBal) = _removeLiquidity(adapter, maturity, lpBal, params, swapPTs, receiver, permit);\n        amt = _fromTarget(adapter, amt, receiver, quote);\n        _transfer(quote.buyToken, receiver, amt);\n    }\n\n    /* ========== UTILS ========== */\n\n    /// @notice Mint PTs & YTs of a specific Series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series [unix time]\n    /// @param amt Amount to issue with\n    /// @dev The balance of PTs and YTs minted will be the same value in units of underlying (less fees)\n    /// @param receiver Address where the resulting PTs and YTs will be transferred to\n    /// @param permit Permit to pull tokens\n    /// @param quote Quote with swap details\n    /// @return uBal Amount of PTs and YTs minted\n    /// @dev if quote.sellToken is neither target nor underlying, it will swap on 0x and wrap to target\n    /// and swap it on 0x\n    function issue(\n        address adapter,\n        uint256 maturity,\n        uint256 amt,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external payable returns (uint256 uBal) {\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), amt);\n        uBal = divider.issue(adapter, maturity, _toTarget(adapter, amt, receiver, quote));\n        ERC20(divider.pt(adapter, maturity)).transfer(receiver, uBal); // Send PTs to the receiver\n        ERC20(divider.yt(adapter, maturity)).transfer(receiver, uBal); // Send YT to the receiver\n    }\n\n    /// @notice Reconstitute Target by burning PT and YT\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal Amount of PT and YT to burn\n    /// @param receiver Address where the resulting Target will be transferred\n    /// @param permit Permit to pull PT and YT\n    /// @param quote Quote with swap details\n    /// @return amt Amount of tokens received from reconstituting target\n    /// @dev if quote.buyToken is neither target nor underlying, it will unwrap target\n    /// and swap it on 0x\n    function combine(\n        address adapter,\n        uint256 maturity,\n        uint256 uBal,\n        address receiver,\n        PermitBatchData calldata permit,\n        SwapQuote calldata quote\n    ) external payable returns (uint256 amt) {\n        IPermit2.SignatureTransferDetails[] memory sigs = new IPermit2.SignatureTransferDetails[](2);\n        sigs[0] = IPermit2.SignatureTransferDetails({ to: address(this), requestedAmount: uBal });\n        sigs[1] = IPermit2.SignatureTransferDetails({ to: address(this), requestedAmount: uBal });\n\n        // pull underlying\n        permit2.permitTransferFrom(permit.msg, sigs, msg.sender, permit.sig);\n        amt = _fromTarget(adapter, divider.combine(adapter, maturity, uBal), receiver, quote);\n        _transfer(quote.buyToken, receiver, amt);\n    }\n\n    /* ========== ADMIN ========== */\n\n    /// @notice Enable or disable a factory\n    /// @param f Factory's address\n    /// @param isOn Flag setting this factory to enabled or disabled\n    function setFactory(address f, bool isOn) external requiresTrust {\n        if (factories[f] == isOn) revert Errors.ExistingValue();\n        factories[f] = isOn;\n        emit FactoryChanged(f, isOn);\n    }\n\n    /// @notice Update the address for the Space Factory\n    /// @param newSpaceFactory The Space Factory addresss to set\n    function setSpaceFactory(address newSpaceFactory) external requiresTrust {\n        emit SpaceFactoryChanged(address(spaceFactory), newSpaceFactory);\n        spaceFactory = SpaceFactoryLike(newSpaceFactory);\n    }\n\n    /// @dev Verifies an Adapter\n    /// @param adapter Adapter to verify\n    function verifyAdapter(address adapter) public requiresTrust {\n        _verifyAdapter(adapter);\n    }\n\n    function _verifyAdapter(address adapter) private {\n        verified[adapter] = true;\n        emit AdapterVerified(adapter);\n    }\n\n    /// @notice Onboard a single Adapter w/o needing a factory\n    /// @dev Called by a trusted address, approves Target for issuance, and onboards adapter to the Divider\n    /// @param adapter Adapter to onboard\n    /// @param addAdapter Whether to call divider.addAdapter or not (useful e.g when upgrading Periphery)\n    function onboardAdapter(address adapter, bool addAdapter) public {\n        if (!divider.permissionless() && !isTrusted[msg.sender]) revert Errors.OnlyPermissionless();\n        _onboardAdapter(adapter, addAdapter);\n    }\n\n    function _onboardAdapter(address adapter, bool addAdapter) private {\n        ERC20 target = ERC20(Adapter(adapter).target());\n        target.safeApprove(address(divider), type(uint256).max);\n        target.safeApprove(address(adapter), type(uint256).max);\n        ERC20(Adapter(adapter).underlying()).safeApprove(address(adapter), type(uint256).max);\n        if (addAdapter) divider.addAdapter(adapter);\n        emit AdapterOnboarded(adapter);\n    }\n\n    /* ========== INTERNAL UTILS ========== */\n\n    function _balancerSwap(\n        address assetIn,\n        address assetOut,\n        uint256 amountIn,\n        uint256 deadline,\n        bytes32 poolId,\n        uint256 minAccepted,\n        address payable receiver\n    ) internal returns (uint256 amountOut) {\n        // approve vault to spend tokenIn\n        ERC20(assetIn).safeApprove(address(balancerVault), amountIn);\n\n        BalancerVault.SingleSwap memory request = BalancerVault.SingleSwap({\n            poolId: poolId,\n            kind: BalancerVault.SwapKind.GIVEN_IN,\n            assetIn: IAsset(assetIn),\n            assetOut: IAsset(assetOut),\n            amount: amountIn,\n            userData: hex\"\"\n        });\n\n        BalancerVault.FundManagement memory funds = BalancerVault.FundManagement({\n            sender: address(this),\n            fromInternalBalance: false,\n            recipient: receiver,\n            toInternalBalance: false\n        });\n\n        amountOut = balancerVault.swap(request, funds, minAccepted, deadline);\n        emit Swapped(msg.sender, poolId, assetIn, assetOut, amountIn, amountOut, msg.sig);\n    }\n\n    function _swapPTsForTarget(\n        address adapter,\n        uint256 maturity,\n        uint256 ptBal,\n        uint256 deadline,\n        PermitData calldata permit\n    ) internal returns (uint256 tBal) {\n        _transferFrom(permit, divider.pt(adapter, maturity), ptBal);\n\n        if (divider.mscale(adapter, maturity) > 0 && !uint256(Adapter(adapter).level()).redeemRestricted()) {\n            tBal = divider.redeem(adapter, maturity, ptBal);\n        } else {\n            tBal = _balancerSwap(\n                divider.pt(adapter, maturity),\n                Adapter(adapter).target(),\n                ptBal,\n                deadline,\n                BalancerPool(spaceFactory.pools(adapter, maturity)).getPoolId(),\n                0,\n                payable(address(this))\n            );\n        }\n    }\n\n    function _swapTargetForPTs(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal,\n        uint256 deadline,\n        uint256 minAccepted,\n        address receiver\n    ) internal returns (uint256 ptBal) {\n        address pt = divider.pt(adapter, maturity);\n        BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n        ptBal = _balancerSwap(\n            Adapter(adapter).target(),\n            pt,\n            tBal,\n            deadline,\n            pool.getPoolId(),\n            minAccepted,\n            payable(receiver)\n        ); // swap target for PTs\n    }\n\n    function _swapYTsForTarget(\n        address sender,\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal,\n        uint256 deadline,\n        PermitData calldata permit\n    ) internal returns (uint256 tBal) {\n        // Because there's some margin of error in the pricing functions here, smaller\n        // swaps will be unreliable. Tokens with more than 18 decimals are not supported.\n        if (ytBal * 10**(18 - ERC20(divider.yt(adapter, maturity)).decimals()) <= MIN_YT_SWAP_IN)\n            revert Errors.SwapTooSmall();\n\n        // Transfer YTs into this contract if needed\n        if (sender != address(this) && msg.sender != address(this))\n            _transferFrom(permit, divider.yt(adapter, maturity), ytBal);\n\n        // Calculate target to borrow by calling AMM\n        uint256 targetToBorrow;\n        {\n            BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n            bytes32 poolId = pool.getPoolId();\n            (uint256 pti, uint256 targeti) = pool.getIndices();\n            (ERC20[] memory tokens, uint256[] memory balances, ) = balancerVault.getPoolTokens(poolId);\n            // Determine how much Target we'll need in to get `ytBal` balance of PT out\n            // (space doesn't directly use of the fields from `SwapRequest` beyond `poolId`, so the values after are placeholders)\n            targetToBorrow = BalancerPool(pool).onSwap(\n                BalancerPool.SwapRequest({\n                    kind: BalancerVault.SwapKind.GIVEN_OUT,\n                    tokenIn: tokens[targeti],\n                    tokenOut: tokens[pti],\n                    amount: ytBal,\n                    poolId: poolId,\n                    lastChangeBlock: 0,\n                    from: address(0),\n                    to: address(0),\n                    userData: \"\"\n                }),\n                balances[targeti],\n                balances[pti]\n            );\n        }\n\n        // Flash borrow target (following actions in `onFlashLoan`)\n        tBal = _flashBorrowAndSwapFromYTs(adapter, maturity, abi.encode(ytBal, targetToBorrow, deadline));\n    }\n\n    /// @return tAmount if mode = 0, target received from selling YTs, otherwise, returns 0\n    /// @return issued returns amount of YTs issued (and received) except first provision which returns 0\n    /// @return lpShares LP Shares received from adding liquidity to a Space\n    function _addLiquidity(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal,\n        AddLiquidityParams memory params,\n        uint8 mode,\n        address receiver,\n        PermitData calldata permit\n    )\n        internal\n        returns (\n            uint256 tAmount,\n            uint256 issued,\n            uint256 lpShares\n        )\n    {\n        // 1. Compute target, issue PTs & YTs & add liquidity to space\n        (issued, lpShares) = _computeIssueAddLiq(adapter, maturity, tBal, params.minBptOut, receiver);\n\n        if (issued > 0) {\n            // issue = 0 means that we are on the first pool provision or that the pt:target ratio is 0:target\n            if (mode == 0) {\n                // 2. Sell YTs\n                tAmount = _swapYTsForTarget(\n                    address(this),\n                    adapter,\n                    maturity,\n                    issued,\n                    params.deadline,\n                    permit // we send permit thought it won't be used\n                );\n                // Check that we got enough target\n                if (tAmount < params.minAccepted) revert Errors.UnexpectedSwapAmount();\n\n                // 3. Send remaining Target to the receiver\n                ERC20(Adapter(adapter).target()).safeTransfer(receiver, tAmount);\n            } else {\n                // 2. Send YTs to the receiver\n                ERC20(divider.yt(adapter, maturity)).safeTransfer(receiver, issued);\n            }\n        }\n    }\n\n    /// @dev Calculates amount of PTs in target terms (see description on `_computeTarget`) then issues\n    /// PTs and YTs with the calculated amount and finally adds liquidity to space with the PTs issued\n    /// and the diff between the target initially passed and the calculated amount\n    function _computeIssueAddLiq(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal,\n        uint256 minBptOut,\n        address receiver\n    ) internal returns (uint256 issued, uint256 lpShares) {\n        BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n        // Compute target\n        (ERC20[] memory tokens, uint256[] memory balances, ) = balancerVault.getPoolTokens(pool.getPoolId());\n        (uint256 pti, uint256 targeti) = pool.getIndices(); // Ensure we have the right token Indices\n\n        // We do not add Principal Token liquidity if it haven't been initialized yet\n        bool ptInitialized = balances[pti] != 0;\n        uint256 ptBalInTarget = ptInitialized ? _computeTarget(adapter, balances[pti], balances[targeti], tBal) : 0;\n\n        // Issue PT & YT (skip if first pool provision)\n        issued = ptBalInTarget > 0 ? divider.issue(adapter, maturity, ptBalInTarget) : 0;\n\n        // Add liquidity to Space & send the LP Shares to recipient\n        uint256[] memory amounts = new uint256[](2);\n        amounts[targeti] = tBal - ptBalInTarget;\n        amounts[pti] = issued;\n        lpShares = _addLiquidityToSpace(pool, PoolLiquidity(tokens, amounts, minBptOut), receiver);\n    }\n\n    /// @dev Based on pt:target ratio from current pool reserves and tBal passed\n    /// calculates amount of tBal needed so as to issue PTs that would keep the ratio\n    function _computeTarget(\n        address adapter,\n        uint256 ptiBal,\n        uint256 targetiBal,\n        uint256 tBal\n    ) internal returns (uint256 tBalForIssuance) {\n        return\n            tBal.fmul(\n                ptiBal.fdiv(\n                    Adapter(adapter).scale().fmul(FixedMath.WAD - Adapter(adapter).ifee()).fmul(targetiBal) + ptiBal\n                )\n            );\n    }\n\n    function _removeLiquidity(\n        address adapter,\n        uint256 maturity,\n        uint256 lpBal,\n        RemoveLiquidityParams memory params,\n        bool swapPTs,\n        address receiver,\n        PermitData calldata permit\n    ) internal returns (uint256 tBal, uint256 ptBal) {\n        bytes32 poolId;\n        {\n            BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n            _transferFrom(permit, address(pool), lpBal);\n            poolId = pool.getPoolId();\n        }\n\n        // 1. Remove liquidity from Space\n        address pt = divider.pt(adapter, maturity);\n        uint256 _ptBal;\n        (tBal, _ptBal) = _removeLiquidityFromSpace(poolId, pt, Adapter(adapter).target(), params.minAmountsOut, lpBal);\n\n        if (divider.mscale(adapter, maturity) > 0) {\n            if (uint256(Adapter(adapter).level()).redeemRestricted()) {\n                ptBal = _ptBal;\n            } else {\n                // 2. Redeem PTs for Target\n                tBal += divider.redeem(adapter, maturity, _ptBal);\n            }\n        } else {\n            // 2. Sell PTs for Target (if there are)\n            if (_ptBal > 0 && swapPTs) {\n                tBal += _balancerSwap(\n                    pt,\n                    Adapter(adapter).target(),\n                    _ptBal,\n                    params.deadline,\n                    poolId,\n                    params.minAccepted,\n                    payable(address(this))\n                );\n            } else {\n                ptBal = _ptBal;\n            }\n        }\n        if (ptBal > 0) ERC20(pt).transfer(receiver, ptBal);\n    }\n\n    /// @notice Initiates a flash loan of Target, swaps target amount to PTs and combines\n    /// @param adapter adapter\n    /// @param maturity maturity\n    /// @param data abi.encoded data:\n    /// - YT amount the user has sent in\n    /// - target amount to borrow\n    /// - deadline for the swap\n    /// @return tBal amount of Target obtained from a sale of YTs\n    function _flashBorrowAndSwapFromYTs(\n        address adapter,\n        uint256 maturity,\n        bytes memory data\n    ) internal returns (uint256 tBal) {\n        ERC20 target = ERC20(Adapter(adapter).target());\n        uint256 decimals = target.decimals();\n        uint256 acceptableError = decimals < 9 ? 1 : PRICE_ESTIMATE_ACCEPTABLE_ERROR / 10**(18 - decimals);\n        (uint256 ytBalIn, uint256 amountToBorrow, uint256 deadline) = abi.decode(data, (uint256, uint256, uint256));\n        bool result = Adapter(adapter).flashLoan(\n            this,\n            address(target),\n            amountToBorrow,\n            abi.encode(adapter, uint256(maturity), ytBalIn, ytBalIn - acceptableError, deadline, true)\n        );\n        if (!result) revert Errors.FlashBorrowFailed();\n        tBal = _balanceOf(address(target), address(this));\n    }\n\n    /// @notice Initiates a flash loan of Target, issues PTs/YTs and swaps the PTs to Target\n    /// @param adapter adapter\n    /// @param maturity taturity\n    /// @param targetIn Target amount the user has sent in\n    /// @param amountToBorrow Target amount to borrow\n    /// @param minAccepted minimum amount of Target accepted out for the issued PTs\n    /// @return targetBal amount of Target remaining after the flashloan has been paid back\n    /// @return ytBal amount of YTs issued with the borrowed Target and the Target sent in\n    function _flashBorrowAndSwapToYTs(\n        address adapter,\n        uint256 maturity,\n        uint256 targetIn,\n        uint256 deadline,\n        uint256 amountToBorrow,\n        uint256 minAccepted\n    ) internal returns (uint256 targetBal, uint256 ytBal) {\n        bool result = Adapter(adapter).flashLoan(\n            this,\n            Adapter(adapter).target(),\n            amountToBorrow,\n            abi.encode(adapter, uint256(maturity), targetIn, minAccepted, deadline, false)\n        );\n        if (!result) revert Errors.FlashBorrowFailed();\n\n        targetBal = _balanceOf(Adapter(adapter).target(), address(this));\n        ytBal = _balanceOf(divider.yt(adapter, maturity), address(this));\n        emit YTsPurchased(msg.sender, adapter, maturity, targetIn, targetBal, ytBal);\n    }\n\n    /// @dev ERC-3156 Flash loan callback\n    function onFlashLoan(\n        address initiator,\n        address, /* token */\n        uint256 amountBorrrowed,\n        uint256, /* fee */\n        bytes calldata data\n    ) external returns (bytes32) {\n        (\n            address adapter,\n            uint256 maturity,\n            uint256 amountIn,\n            uint256 minAccepted,\n            uint256 deadline,\n            bool ytToTarget\n        ) = abi.decode(data, (address, uint256, uint256, uint256, uint256, bool));\n\n        if (msg.sender != address(adapter)) revert Errors.FlashUntrustedBorrower();\n        if (initiator != address(this)) revert Errors.FlashUntrustedLoanInitiator();\n\n        address target = Adapter(adapter).target();\n        if (ytToTarget) {\n            // Swap Target for PTs\n            uint256 ptBal = _balancerSwap(\n                target,\n                divider.pt(adapter, maturity),\n                _balanceOf(target, address(this)),\n                deadline,\n                BalancerPool(spaceFactory.pools(adapter, maturity)).getPoolId(),\n                minAccepted, // min pt out\n                payable(address(this))\n            );\n\n            // Combine PTs and YTs\n            divider.combine(adapter, maturity, ptBal < amountIn ? ptBal : amountIn);\n        } else {\n            // Issue PTs and YTs\n            divider.issue(adapter, maturity, amountIn + amountBorrrowed);\n            address pt = divider.pt(adapter, maturity);\n\n            // Swap PTs for Target\n            _balancerSwap(\n                pt,\n                target,\n                _balanceOf(pt, address(this)),\n                deadline,\n                BalancerPool(spaceFactory.pools(adapter, maturity)).getPoolId(),\n                minAccepted, // min Target accepted\n                payable(address(this))\n            ); // minAccepted should be close to amountBorrrowed so that minimal Target dust is sent back to the caller\n\n            // Flashloaner contract will revert if not enough Target has been swapped out to pay back the loan\n        }\n\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n\n    function _addLiquidityToSpace(\n        BalancerPool pool,\n        PoolLiquidity memory liq,\n        address receiver\n    ) internal returns (uint256 lpBal) {\n        IAsset[] memory assets = _convertERC20sToAssets(liq.tokens);\n        for (uint8 i; i < liq.tokens.length; i++) {\n            // Tokens and amounts must be in same order\n            liq.tokens[i].safeApprove(address(balancerVault), liq.amounts[i]);\n        }\n\n        // Behaves like EXACT_TOKENS_IN_FOR_BPT_OUT, user sends precise quantities of tokens,\n        // and receives an estimated but unknown (computed at run time) quantity of BPT\n        BalancerVault.JoinPoolRequest memory request = BalancerVault.JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: liq.amounts,\n            userData: abi.encode(liq.amounts, liq.minBptOut),\n            fromInternalBalance: false\n        });\n        lpBal = _balanceOf(address(pool), receiver);\n        balancerVault.joinPool(pool.getPoolId(), address(this), receiver, request);\n        lpBal = _balanceOf(address(pool), receiver) - lpBal;\n    }\n\n    function _removeLiquidityFromSpace(\n        bytes32 poolId,\n        address pt,\n        address target,\n        uint256[] memory minAmountsOut,\n        uint256 lpBal\n    ) internal returns (uint256 tBal, uint256 ptBal) {\n        // ExitPoolRequest params\n        (ERC20[] memory tokens, , ) = balancerVault.getPoolTokens(poolId);\n        BalancerVault.ExitPoolRequest memory request = BalancerVault.ExitPoolRequest({\n            assets: _convertERC20sToAssets(tokens),\n            minAmountsOut: minAmountsOut,\n            userData: abi.encode(lpBal),\n            toInternalBalance: false\n        });\n        tBal = _balanceOf(target, address(this));\n        ptBal = _balanceOf(pt, address(this));\n\n        balancerVault.exitPool(poolId, address(this), payable(address(this)), request);\n\n        tBal = _balanceOf(target, address(this)) - tBal;\n        ptBal = _balanceOf(pt, address(this)) - ptBal;\n    }\n\n    // @dev Swaps ETH->ERC20, ERC20->ERC20 or ERC20->ETH held by this contract using a 0x-API quote\n    function _fillQuote(SwapQuote calldata quote) internal returns (uint256 boughtAmount) {\n        if (quote.sellToken == quote.buyToken) return 0; // No swap if the tokens are the same.\n        if (quote.swapTarget != exchangeProxy) revert Errors.InvalidExchangeProxy();\n\n        // Give `spender` an infinite allowance to spend this contract's `sellToken`.\n        if (address(quote.sellToken) != ETH)\n            ERC20(address(quote.sellToken)).safeApprove(quote.spender, type(uint256).max);\n\n        uint256 sellAmount = address(quote.sellToken) == ETH\n            ? address(this).balance\n            : _balanceOf(address(quote.sellToken), address(this));\n\n        // Call the encoded swap function call on the contract at `swapTarget`,\n        // passing along any ETH attached to this function call to cover protocol fees.\n        (bool success, bytes memory res) = quote.swapTarget.call{ value: msg.value }(quote.swapCallData);\n        if (!success) revert Errors.ZeroExSwapFailed(res);\n\n        // We assume the Periphery does not hold tokens so boughtAmount is always it's balance\n        boughtAmount = address(quote.buyToken) == ETH\n            ? address(this).balance\n            : _balanceOf(address(quote.buyToken), address(this));\n        sellAmount =\n            sellAmount -\n            (\n                address(quote.sellToken) == ETH\n                    ? address(this).balance\n                    : _balanceOf(address(quote.sellToken), address(this))\n            );\n        if (boughtAmount == 0 || sellAmount == 0) revert Errors.ZeroSwapAmt();\n\n        emit BoughtTokens(address(quote.sellToken), address(quote.buyToken), sellAmount, boughtAmount);\n    }\n\n    /// @notice Given an amount and a quote, decides whether it needs to wrap and make a swap on 0x,\n    /// simply wrap tokens or do nothing\n    function _toTarget(\n        address adapter,\n        uint256 _amt,\n        address receiver,\n        SwapQuote calldata quote\n    ) internal returns (uint256 amt) {\n        if (address(quote.sellToken) == Adapter(adapter).target()) {\n            amt = _amt;\n        } else if (address(quote.sellToken) == Adapter(adapter).underlying()) {\n            amt = Adapter(adapter).wrapUnderlying(_amt);\n        } else {\n            // sell tokens for underlying and wrap into target\n            amt = Adapter(adapter).wrapUnderlying(_fillQuote(quote));\n\n            // refund any remaining quote.sellToken to receiver\n            _transfer(\n                quote.sellToken,\n                receiver,\n                address(quote.sellToken) == ETH\n                    ? address(this).balance\n                    : _balanceOf(address(quote.sellToken), address(this))\n            );\n        }\n    }\n\n    /// @notice Given an amount and a quote, decides whether it needs to unwrap and make a swap on 0x,\n    /// simply unwrap tokens or do nothing\n    /// @dev when swapping via 0x, the quote needs the amount of underlying that will be received from\n    /// the unwrapTarget. This calculation is done off-chain.\n    function _fromTarget(\n        address adapter,\n        uint256 _amt,\n        address receiver,\n        SwapQuote calldata quote\n    ) internal returns (uint256 amt) {\n        if (address(quote.buyToken) == Adapter(adapter).target()) {\n            amt = _amt;\n        } else if (address(quote.buyToken) == Adapter(adapter).underlying()) {\n            amt = Adapter(adapter).unwrapTarget(_amt);\n        } else {\n            Adapter(adapter).unwrapTarget(_amt);\n            amt = _fillQuote(quote);\n            // refund excess tokens to receiver\n            _transfer(quote.sellToken, receiver, _balanceOf(address(quote.sellToken), address(this)));\n        }\n    }\n\n    function _transferFrom(\n        PermitData calldata permit,\n        address token,\n        uint256 amt\n    ) internal {\n        // Generate calldata for a standard safeTransferFrom call.\n        bytes memory inputData = abi.encodeCall(ERC20.transferFrom, (msg.sender, address(this), amt));\n\n        bool success; // Call the token contract as normal, capturing whether it succeeded.\n        assembly {\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(eq(mload(0), 1), iszero(returndatasize())),\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the first slot of scratch space.\n                call(gas(), token, 0, add(inputData, 32), mload(inputData), 0, 32)\n            )\n        }\n\n        // We'll fall back to using Permit2 if calling transferFrom on the token directly reverted.\n        if (!success)\n            permit2.permitTransferFrom(\n                permit.msg,\n                IPermit2.SignatureTransferDetails({ to: address(this), requestedAmount: amt }),\n                msg.sender,\n                permit.sig\n            );\n    }\n\n    function _transfer(\n        ERC20 token,\n        address receiver,\n        uint256 amt\n    ) internal {\n        if (amt > 0) {\n            if (address(token) == ETH) {\n                (bool sent, ) = receiver.call{ value: amt }(\"\");\n                if (!sent) revert Errors.TransferFailed();\n            } else {\n                token.safeTransfer(receiver, amt);\n            }\n        }\n    }\n\n    function _balanceOf(address token, address user) internal returns (uint256 amt) {\n        amt = ERC20(token).balanceOf(user);\n    }\n\n    /// @notice From: https://github.com/balancer-labs/balancer-examples/blob/master/packages/liquidity-provision/contracts/LiquidityProvider.sol#L33\n    /// @dev This helper function is a fast and cheap way to convert between IERC20[] and IAsset[] types\n    function _convertERC20sToAssets(ERC20[] memory tokens) internal pure returns (IAsset[] memory assets) {\n        assembly {\n            assets := tokens\n        }\n    }\n\n    // required for refunds\n    receive() external payable {}\n\n    /* ========== LOGS ========== */\n\n    event FactoryChanged(address indexed factory, bool indexed isOn);\n    event SpaceFactoryChanged(address oldSpaceFactory, address newSpaceFactory);\n    event SeriesSponsored(address indexed adapter, uint256 indexed maturity, address indexed sponsor);\n    event AdapterDeployed(address indexed adapter);\n    event AdapterOnboarded(address indexed adapter);\n    event AdapterVerified(address indexed adapter);\n    event YTsPurchased(\n        address indexed sender,\n        address adapter,\n        uint256 maturity,\n        uint256 targetIn,\n        uint256 targetReturned,\n        uint256 ytOut\n    );\n    event Swapped(\n        address indexed sender,\n        bytes32 indexed poolId,\n        address assetIn,\n        address assetOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        bytes4 indexed sig\n    );\n    event BoughtTokens(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint256 sellAmount,\n        uint256 indexed boughtAmount\n    );\n}\n"},"@sense-finance/v1-fuse/src/PoolManager.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External reference\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { Bytes32AddressLib } from \"solmate/src/utils/Bytes32AddressLib.sol\";\nimport { PriceOracle } from \"./external/PriceOracle.sol\";\nimport { BalancerOracle } from \"./external/BalancerOracle.sol\";\n\n// Internal references\nimport { UnderlyingOracle } from \"./oracles/Underlying.sol\";\nimport { TargetOracle } from \"./oracles/Target.sol\";\nimport { PTOracle } from \"./oracles/PT.sol\";\nimport { LPOracle } from \"./oracles/LP.sol\";\n\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { Divider } from \"@sense-finance/v1-core/src/Divider.sol\";\nimport { BaseAdapter as Adapter } from \"@sense-finance/v1-core/src/adapters/abstract/BaseAdapter.sol\";\n\ninterface FuseDirectoryLike {\n    function deployPool(\n        string memory name,\n        address implementation,\n        bool enforceWhitelist,\n        uint256 closeFactor,\n        uint256 liquidationIncentive,\n        address priceOracle\n    ) external returns (uint256, address);\n}\n\ninterface ComptrollerLike {\n    /// Deploy cToken, add the market to the markets mapping, and set it as listed and set the collateral factor\n    /// Admin function to deploy cToken, set isListed, and add support for the market and set the collateral factor\n    function _deployMarket(\n        bool isCEther,\n        bytes calldata constructorData,\n        uint256 collateralFactorMantissa\n    ) external returns (uint256);\n\n    /// Accepts transfer of admin rights. msg.sender must be pendingAdmin\n    function _acceptAdmin() external returns (uint256);\n\n    /// All cTokens addresses mapped by their underlying token addresses\n    function cTokensByUnderlying(address underlying) external view returns (address);\n\n    /// A list of all markets\n    function markets(address cToken) external view returns (bool, uint256);\n\n    /// Pause borrowing for a specific market\n    function _setBorrowPaused(address cToken, bool state) external returns (bool);\n}\n\ninterface MasterOracleLike {\n    function initialize(\n        address[] memory underlyings,\n        PriceOracle[] memory _oracles,\n        PriceOracle _defaultOracle,\n        address _restrictedAdmin,\n        bool _canAdminOverwrite\n    ) external;\n\n    function add(address[] calldata underlyings, PriceOracle[] calldata _oracles) external;\n\n    function getUnderlyingPrice(address cToken) external view returns (uint256);\n}\n\n/// @title Fuse Pool Manager\n/// @notice Consolidated Fuse interactions\ncontract PoolManager is Trust {\n    /* ========== PUBLIC IMMUTABLES ========== */\n\n    /// @notice Implementation of Fuse's comptroller\n    address public immutable comptrollerImpl;\n\n    /// @notice Implementation of Fuse's cERC20\n    address public immutable cERC20Impl;\n\n    /// @notice Fuse's pool directory\n    address public immutable fuseDirectory;\n\n    /// @notice Sense core Divider address\n    address public immutable divider;\n\n    /// @notice Implementation of Fuse's master oracle that routes to individual asset oracles\n    address public immutable oracleImpl;\n\n    /// @notice Sense oracle for SEnse Targets\n    address public immutable targetOracle;\n\n    /// @notice Sense oracle for Sense Principal Tokens\n    address public immutable ptOracle;\n\n    /// @notice Sense oracle for Space LP Shares\n    address public immutable lpOracle;\n\n    /// @notice Sense oracle for Underlying assets\n    address public immutable underlyingOracle;\n\n    /* ========== PUBLIC MUTABLE STORAGE ========== */\n\n    /// @notice Fuse comptroller for the Sense pool\n    address public comptroller;\n\n    /// @notice Master oracle for Sense's assets deployed on Fuse\n    address public masterOracle;\n\n    /// @notice Fuse param config\n    AssetParams public targetParams;\n    AssetParams public ptParams;\n    AssetParams public lpTokenParams;\n\n    /// @notice Series Pools: adapter -> maturity -> (series status (pt/lp shares), AMM pool)\n    mapping(address => mapping(uint256 => Series)) public sSeries;\n\n    /* ========== ENUMS ========== */\n\n    enum SeriesStatus {\n        NONE,\n        QUEUED,\n        ADDED\n    }\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct AssetParams {\n        address irModel;\n        uint256 reserveFactor;\n        uint256 collateralFactor;\n    }\n\n    struct Series {\n        // Series addition status\n        SeriesStatus status;\n        // Space pool for this Series\n        address pool;\n    }\n\n    constructor(\n        address _fuseDirectory,\n        address _comptrollerImpl,\n        address _cERC20Impl,\n        address _divider,\n        address _oracleImpl\n    ) Trust(msg.sender) {\n        fuseDirectory = _fuseDirectory;\n        comptrollerImpl = _comptrollerImpl;\n        cERC20Impl = _cERC20Impl;\n        divider = _divider;\n        oracleImpl = _oracleImpl;\n\n        targetOracle = address(new TargetOracle());\n        ptOracle = address(new PTOracle());\n        lpOracle = address(new LPOracle());\n        underlyingOracle = address(new UnderlyingOracle());\n    }\n\n    function deployPool(\n        string calldata name,\n        uint256 closeFactor,\n        uint256 liqIncentive,\n        address fallbackOracle\n    ) external requiresTrust returns (uint256 _poolIndex, address _comptroller) {\n        masterOracle = Clones.cloneDeterministic(oracleImpl, Bytes32AddressLib.fillLast12Bytes(address(this)));\n        MasterOracleLike(masterOracle).initialize(\n            new address[](0),\n            new PriceOracle[](0),\n            PriceOracle(fallbackOracle), // default oracle used if asset prices can't be found otherwise\n            address(this), // admin\n            true // admin can override existing oracle routes\n        );\n\n        (_poolIndex, _comptroller) = FuseDirectoryLike(fuseDirectory).deployPool(\n            name,\n            comptrollerImpl,\n            false, // `whitelist` is always false\n            closeFactor,\n            liqIncentive,\n            masterOracle\n        );\n\n        uint256 err = ComptrollerLike(_comptroller)._acceptAdmin();\n        if (err != 0) revert Errors.FailedBecomeAdmin();\n        comptroller = _comptroller;\n\n        emit PoolDeployed(name, _comptroller, _poolIndex, closeFactor, liqIncentive);\n    }\n\n    function addTarget(address target, address adapter) external requiresTrust returns (address cTarget) {\n        if (comptroller == address(0)) revert Errors.PoolNotDeployed();\n        if (targetParams.irModel == address(0)) revert Errors.TargetParamsNotSet();\n\n        address underlying = Adapter(adapter).underlying();\n\n        address[] memory underlyings = new address[](2);\n        underlyings[0] = target;\n        underlyings[1] = underlying;\n\n        PriceOracle[] memory oracles = new PriceOracle[](2);\n        oracles[0] = PriceOracle(targetOracle);\n        oracles[1] = PriceOracle(underlyingOracle);\n\n        UnderlyingOracle(underlyingOracle).setUnderlying(underlying, adapter);\n        TargetOracle(targetOracle).setTarget(target, adapter);\n        MasterOracleLike(masterOracle).add(underlyings, oracles);\n\n        bytes memory constructorData = abi.encode(\n            target,\n            comptroller,\n            targetParams.irModel,\n            ERC20(target).name(),\n            ERC20(target).symbol(),\n            cERC20Impl,\n            hex\"\", // calldata sent to becomeImplementation (empty bytes b/c it's currently unused)\n            targetParams.reserveFactor,\n            0 // no admin fee\n        );\n\n        // Trying to deploy the same market twice will fail\n        uint256 err = ComptrollerLike(comptroller)._deployMarket(false, constructorData, targetParams.collateralFactor);\n        if (err != 0) revert Errors.FailedAddTargetMarket();\n\n        cTarget = ComptrollerLike(comptroller).cTokensByUnderlying(target);\n\n        emit TargetAdded(target, cTarget);\n    }\n\n    /// @notice queues a set of (Principal Tokens, LPShare) for a Fuse pool to be deployed once the TWAP is ready\n    /// @dev called by the Periphery, which will know which pool address to set for this Series\n    function queueSeries(\n        address adapter,\n        uint256 maturity,\n        address pool\n    ) external requiresTrust {\n        if (Divider(divider).pt(adapter, maturity) == address(0)) revert Errors.SeriesDoesNotExist();\n        if (sSeries[adapter][maturity].status != SeriesStatus.NONE) revert Errors.DuplicateSeries();\n\n        address cTarget = ComptrollerLike(comptroller).cTokensByUnderlying(Adapter(adapter).target());\n        if (cTarget == address(0)) revert Errors.TargetNotInFuse();\n\n        (bool isListed, ) = ComptrollerLike(comptroller).markets(cTarget);\n        if (!isListed) revert Errors.TargetNotInFuse();\n\n        sSeries[adapter][maturity] = Series({ status: SeriesStatus.QUEUED, pool: pool });\n\n        emit SeriesQueued(adapter, maturity, pool);\n    }\n\n    /// @notice open method to add queued Principal Tokens and LPShares to Fuse pool\n    /// @dev this can only be done once the yield space pool has filled its buffer and has a TWAP\n    function addSeries(address adapter, uint256 maturity) external returns (address cPT, address cLPToken) {\n        if (sSeries[adapter][maturity].status != SeriesStatus.QUEUED) revert Errors.SeriesNotQueued();\n        if (ptParams.irModel == address(0)) revert Errors.PTParamsNotSet();\n        if (lpTokenParams.irModel == address(0)) revert Errors.PoolParamsNotSet();\n\n        address pt = Divider(divider).pt(adapter, maturity);\n        address pool = sSeries[adapter][maturity].pool;\n\n        (, , , , , , uint256 sampleTs) = BalancerOracle(pool).getSample(BalancerOracle(pool).getTotalSamples() - 1);\n        // Prevent this market from being deployed on Fuse if we're unable to read a TWAP\n        if (sampleTs == 0) revert Errors.OracleNotReady();\n\n        address[] memory underlyings = new address[](2);\n        underlyings[0] = pt;\n        underlyings[1] = pool;\n\n        PriceOracle[] memory oracles = new PriceOracle[](2);\n        oracles[0] = PriceOracle(ptOracle);\n        oracles[1] = PriceOracle(lpOracle);\n\n        PTOracle(ptOracle).setPrincipal(pt, pool);\n        MasterOracleLike(masterOracle).add(underlyings, oracles);\n\n        bytes memory constructorDataPrincipal = abi.encode(\n            pt,\n            comptroller,\n            ptParams.irModel,\n            ERC20(pt).name(),\n            ERC20(pt).symbol(),\n            cERC20Impl,\n            hex\"\",\n            ptParams.reserveFactor,\n            0 // no admin fee\n        );\n\n        uint256 errPrincipal = ComptrollerLike(comptroller)._deployMarket(\n            false,\n            constructorDataPrincipal,\n            ptParams.collateralFactor\n        );\n        if (errPrincipal != 0) revert Errors.FailedToAddPTMarket();\n\n        // LP Share pool token\n        bytes memory constructorDataLpToken = abi.encode(\n            pool,\n            comptroller,\n            lpTokenParams.irModel,\n            ERC20(pool).name(),\n            ERC20(pool).symbol(),\n            cERC20Impl,\n            hex\"\",\n            lpTokenParams.reserveFactor,\n            0 // no admin fee\n        );\n\n        uint256 errLpToken = ComptrollerLike(comptroller)._deployMarket(\n            false,\n            constructorDataLpToken,\n            lpTokenParams.collateralFactor\n        );\n        if (errLpToken != 0) revert Errors.FailedAddLpMarket();\n\n        cPT = ComptrollerLike(comptroller).cTokensByUnderlying(pt);\n        cLPToken = ComptrollerLike(comptroller).cTokensByUnderlying(pool);\n\n        ComptrollerLike(comptroller)._setBorrowPaused(cLPToken, true);\n\n        sSeries[adapter][maturity].status = SeriesStatus.ADDED;\n\n        emit SeriesAdded(pt, pool);\n    }\n\n    /* ========== ADMIN ========== */\n\n    function setParams(bytes32 what, AssetParams calldata data) external requiresTrust {\n        if (what == \"PT_PARAMS\") ptParams = data;\n        else if (what == \"LP_TOKEN_PARAMS\") lpTokenParams = data;\n        else if (what == \"TARGET_PARAMS\") targetParams = data;\n        else revert Errors.InvalidParam();\n        emit ParamsSet(what, data);\n    }\n\n    function execute(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) external requiresTrust returns (bool success) {\n        assembly {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    /* ========== LOGS ========== */\n\n    event ParamsSet(bytes32 indexed what, AssetParams data);\n    event PoolDeployed(string name, address comptroller, uint256 poolIndex, uint256 closeFactor, uint256 liqIncentive);\n    event TargetAdded(address indexed target, address indexed cTarget);\n    event SeriesQueued(address indexed adapter, uint256 indexed maturity, address indexed pool);\n    event SeriesAdded(address indexed pt, address indexed lpToken);\n}\n"},"@sense-finance/v1-utils/src/EmergencyStop.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Internal references\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { Divider } from \"@sense-finance/v1-core/src/Divider.sol\";\n\n/// @notice Unsets multiple adapters on the divider\ncontract EmergencyStop is Trust {\n    address public immutable divider;\n\n    constructor(address _divider) Trust(msg.sender) {\n        divider = _divider;\n    }\n\n    function stop(address[] memory adapters) external virtual requiresTrust {\n        Divider(divider).setPermissionless(false);\n        for (uint256 i = 0; i < adapters.length; i++) {\n            Divider(divider).setAdapter(adapters[i], false);\n            emit Stopped(adapters[i]);\n        }\n    }\n\n    event Stopped(address indexed adapter);\n}\n"},"@sense-finance/v1-fuse/src/NoopPoolManager.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Pool manager implementation with no restrictions where every function is a no-op. Refer to \"PoolManager.sol\"\n// for an exemplar of a normal Pool Manager.\ncontract NoopPoolManager {\n    function deployPool(\n        string calldata name,\n        uint256 closeFactor,\n        uint256 liqIncentive,\n        address fallbackOracle\n    ) external returns (uint256 _poolIndex, address _comptroller) {}\n\n    function addTarget(address target, address adapter) external returns (address cTarget) {}\n\n    function queueSeries(\n        address adapter,\n        uint256 maturity,\n        address pool\n    ) external {}\n\n    function addSeries(address adapter, uint256 maturity) external returns (address, address) {}\n}\n"},"@sense-finance/v1-core/src/external/MultiRewardsDistributor.sol":{"content":"// SPDX-License-Identifier: GNU AGPLv3\npragma solidity ^0.8.0;\n\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Sense Multi Rewards Distributor.\n/// @author Sense Finance.\n/// @notice This contract allows users to claim their rewards. This contract is largely inspired by Morpho's Reward Distributor contract: https://github.com/morpho-dao/morpho-v1/blob/main/src/common/rewards-distribution/RewardsDistributor.sol.\n/// and modified to allow multiple rewards tokens.\ncontract MultiRewardsDistributor is Ownable {\n    using SafeTransferLib for ERC20;\n\n    /// STORAGE ///\n\n    struct Node {\n        bytes32 currRoot; // The merkle tree's root of the current rewards distribution.\n        bytes32 prevRoot; // The merkle tree's root of the previous rewards distribution.\n        mapping(address => uint256) claimed; // The rewards already claimed. account -> amount.\n    }\n    mapping(ERC20 => Node) public nodes;\n\n    ERC20[] public rewards;\n\n    /// EVENTS ///\n\n    /// @notice Emitted when the root is updated.\n    /// @param newRoot The new merkle's tree root.\n    event RootUpdated(ERC20 reward, bytes32 newRoot);\n\n    /// @notice Emitted when reward tokens are withdrawn.\n    /// @param reward The address of the reward token.\n    /// @param to The address of the recipient.\n    /// @param amount The amount of reward tokens withdrawn.\n    event RewardsWithdrawn(ERC20 reward, address to, uint256 amount);\n\n    /// @notice Emitted when an account claims rewards.\n    /// @param reward The address of the reward token.\n    /// @param account The address of the claimer.\n    /// @param amount The amount of rewards claimed.\n    event RewardsClaimed(ERC20 reward, address account, uint256 amount);\n\n    /// ERRORS ///\n\n    /// @notice Thrown when the proof is invalid or expired.\n    error ProofInvalidOrExpired();\n\n    /// @notice Thrown when the claimer has already claimed the rewards.\n    error AlreadyClaimed();\n\n    /// CONSTRUCTOR ///\n\n    /// @notice Constructs Morpho's RewardsDistributor contract.\n    /// @param _rewards The address of the MORPHO token to distribute.\n    constructor(ERC20[] memory _rewards) {\n        rewards = _rewards;\n    }\n\n    /// EXTERNAL ///\n\n    /// @notice Updates the current merkle tree's root.\n    /// @param _newRoot The new merkle tree's root.\n    function updateRoot(ERC20 _reward, bytes32 _newRoot) external onlyOwner {\n        nodes[_reward].prevRoot = nodes[_reward].currRoot;\n        nodes[_reward].currRoot = _newRoot;\n        emit RootUpdated(_reward, _newRoot);\n    }\n\n    /// @notice Withdraws reward tokens to a recipient.\n    /// @param _to The address of the recipient.\n    /// @param _amounts The amounts for each reward token to transfer.\n    function withdrawTokens(address _to, uint256[] calldata _amounts) external onlyOwner {\n        for (uint256 i = 0; i < rewards.length; i++) {\n            ERC20 reward = rewards[i];\n            uint256 rewardBalance = reward.balanceOf(address(this));\n            uint256 toWithdraw = rewardBalance < _amounts[i] ? rewardBalance : _amounts[i];\n            reward.safeTransfer(_to, toWithdraw);\n            emit RewardsWithdrawn(reward, _to, toWithdraw);\n        }\n    }\n\n    /// @notice Claims rewards.\n    /// @param _account The address of the claimer.\n    /// @param _claimable The overall claimable amount of token rewards.\n    /// @param _proof The merkle proof that validates this claim.\n    function claim(\n        ERC20 _reward,\n        address _account,\n        uint256 _claimable,\n        bytes32[] calldata _proof\n    ) external {\n        bytes32 candidateRoot = MerkleProof.processProof(\n            _proof,\n            keccak256(abi.encodePacked(_reward, _account, _claimable))\n        );\n        if (candidateRoot != nodes[_reward].currRoot && candidateRoot != nodes[_reward].prevRoot)\n            revert ProofInvalidOrExpired();\n\n        uint256 alreadyClaimed = nodes[_reward].claimed[_account];\n        if (_claimable <= alreadyClaimed) revert AlreadyClaimed();\n\n        uint256 amount;\n        unchecked {\n            amount = _claimable - alreadyClaimed;\n        }\n\n        nodes[_reward].claimed[_account] = _claimable;\n\n        _reward.safeTransfer(_account, amount);\n        emit RewardsClaimed(_reward, _account, amount);\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/BaseAdapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\nimport { IERC3156FlashLender } from \"../../external/flashloan/IERC3156FlashLender.sol\";\nimport { IERC3156FlashBorrower } from \"../../external/flashloan/IERC3156FlashBorrower.sol\";\n\n// Internal references\nimport { Divider } from \"../../Divider.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\n/// @title Assign value to Target tokens\nabstract contract BaseAdapter is IERC3156FlashLender {\n    using SafeTransferLib for ERC20;\n\n    /* ========== CONSTANTS ========== */\n\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /* ========== PUBLIC IMMUTABLES ========== */\n\n    /// @notice Sense core Divider address\n    address public immutable divider;\n\n    /// @notice Target token to divide\n    address public immutable target;\n\n    /// @notice Underlying for the Target\n    address public immutable underlying;\n\n    /// @notice Issuance fee\n    uint128 public immutable ifee;\n\n    /// @notice adapter params\n    AdapterParams public adapterParams;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct AdapterParams {\n        /// @notice Oracle address\n        address oracle;\n        /// @notice Token to stake at issuance\n        address stake;\n        /// @notice Amount to stake at issuance\n        uint256 stakeSize;\n        /// @notice Min maturity (seconds after block.timstamp)\n        uint256 minm;\n        /// @notice Max maturity (seconds after block.timstamp)\n        uint256 maxm;\n        /// @notice WAD number representing the percentage of the total\n        /// principal that's set aside for Yield Tokens (e.g. 0.1e18 means that 10% of the principal is reserved).\n        /// @notice If `0`, it means no principal is set aside for Yield Tokens\n        uint64 tilt;\n        /// @notice The number this function returns will be used to determine its access by checking for binary\n        /// digits using the following scheme: <onRedeem(y/n)><collect(y/n)><combine(y/n)><issue(y/n)>\n        /// (e.g. 0101 enables `collect` and `issue`, but not `combine`)\n        uint48 level;\n        /// @notice 0 for monthly, 1 for weekly\n        uint16 mode;\n    }\n\n    /* ========== METADATA STORAGE ========== */\n\n    string public name;\n\n    string public symbol;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _underlying,\n        uint128 _ifee,\n        AdapterParams memory _adapterParams\n    ) {\n        divider = _divider;\n        target = _target;\n        underlying = _underlying;\n        ifee = _ifee;\n        adapterParams = _adapterParams;\n\n        name = string(abi.encodePacked(ERC20(_target).name(), \" Adapter\"));\n        symbol = string(abi.encodePacked(ERC20(_target).symbol(), \"-adapter\"));\n\n        ERC20(_target).safeApprove(divider, type(uint256).max);\n        ERC20(_adapterParams.stake).safeApprove(divider, type(uint256).max);\n    }\n\n    /// @notice Loan `amount` target to `receiver`, and takes it back after the callback.\n    /// @param receiver The contract receiving target, needs to implement the\n    /// `onFlashLoan(address user, address adapter, uint256 maturity, uint256 amount)` interface.\n    /// @param amount The amount of target lent.\n    /// @param data (encoded adapter address, maturity and YT amount the use has sent in)\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address, /* fee */\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n        ERC20(target).safeTransfer(address(receiver), amount);\n        bytes32 keccak = IERC3156FlashBorrower(receiver).onFlashLoan(msg.sender, target, amount, 0, data);\n        if (keccak != CALLBACK_SUCCESS) revert Errors.FlashCallbackFailed();\n        ERC20(target).safeTransferFrom(address(receiver), address(this), amount);\n        return true;\n    }\n\n    /* ========== REQUIRED VALUE GETTERS ========== */\n\n    /// @notice Calculate and return this adapter's Scale value for the current timestamp. To be overriden by child contracts\n    /// @dev For some Targets, such as cTokens, this is simply the exchange rate, or `supply cToken / supply underlying`\n    /// @dev For other Targets, such as AMM LP shares, specialized logic will be required\n    /// @dev This function _must_ return a WAD number representing the current exchange rate\n    /// between the Target and the Underlying.\n    /// @return value WAD Scale value\n    function scale() external virtual returns (uint256);\n\n    /// @notice Cached scale value getter\n    /// @dev For situations where you need scale from a view function\n    function scaleStored() external view virtual returns (uint256);\n\n    /// @notice Returns the current price of the underlying in ETH terms\n    function getUnderlyingPrice() external view virtual returns (uint256);\n\n    /* ========== REQUIRED UTILITIES ========== */\n\n    /// @notice Deposits underlying `amount`in return for target. Must be overriden by child contracts\n    /// @param amount Underlying amount\n    /// @return amount of target returned\n    function wrapUnderlying(uint256 amount) external virtual returns (uint256);\n\n    /// @notice Deposits target `amount`in return for underlying. Must be overriden by child contracts\n    /// @param amount Target amount\n    /// @return amount of underlying returned\n    function unwrapTarget(uint256 amount) external virtual returns (uint256);\n\n    function flashFee(address token, uint256) external view returns (uint256) {\n        if (token != target) revert Errors.TokenNotSupported();\n        return 0;\n    }\n\n    function maxFlashLoan(address token) external view override returns (uint256) {\n        return ERC20(token).balanceOf(address(this));\n    }\n\n    /* ========== OPTIONAL HOOKS ========== */\n\n    /// @notice Notification whenever the Divider adds or removes Target\n    function notify(\n        address, /* usr */\n        uint256, /* amt */\n        bool /* join */\n    ) public virtual {\n        return;\n    }\n\n    /// @notice Hook called whenever a user redeems PT\n    function onRedeem(\n        uint256, /* uBal */\n        uint256, /* mscale */\n        uint256, /* maxscale */\n        uint256 /* tBal */\n    ) public virtual {\n        return;\n    }\n\n    /* ========== PUBLIC STORAGE ACCESSORS ========== */\n\n    function getMaturityBounds() external view virtual returns (uint256, uint256) {\n        return (adapterParams.minm, adapterParams.maxm);\n    }\n\n    function getStakeAndTarget()\n        external\n        view\n        returns (\n            address,\n            address,\n            uint256\n        )\n    {\n        return (target, adapterParams.stake, adapterParams.stakeSize);\n    }\n\n    function mode() external view returns (uint256) {\n        return adapterParams.mode;\n    }\n\n    function tilt() external view returns (uint256) {\n        return adapterParams.tilt;\n    }\n\n    function level() external view returns (uint256) {\n        return adapterParams.level;\n    }\n}\n"},"@sense-finance/v1-core/src/tests/test-helpers/Permit2Clone.sol":{"content":"import { IPermit2 } from \"@sense-finance/v1-core/src/external/IPermit2.sol\";\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Local bytecode clone of the canonical Permit2 contract deployed to mainnet.\ncontract Permit2Clone is IPermit2 {\n    error InvalidNonce();\n    error InvalidSigner();\n\n    constructor() {\n        // Deployed Permit2 bytecode at\n        // https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3\n        bytes\n            memory bytecode = hex\"6040608081526004908136101561001557600080fd5b600090813560e01c80630d58b1db1461126c578063137c29fe146110755780632a2d80d114610db75780632b67b57014610bde57806330f28b7a14610ade5780633644e51514610a9d57806336c7851614610a285780633ff9dcb1146109a85780634fe02b441461093f57806365d9723c146107ac57806387517c451461067a578063927da105146105c3578063cc53287f146104a3578063edd9444b1461033a5763fe8ec1a7146100c657600080fd5b346103365760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103365767ffffffffffffffff833581811161033257610114903690860161164b565b60243582811161032e5761012b903690870161161a565b6101336114e6565b9160843585811161032a5761014b9036908a016115c1565b98909560a43590811161032657610164913691016115c1565b969095815190610173826113ff565b606b82527f5065726d697442617463685769746e6573735472616e7366657246726f6d285460208301527f6f6b656e5065726d697373696f6e735b5d207065726d69747465642c61646472838301527f657373207370656e6465722c75696e74323536206e6f6e63652c75696e74323560608301527f3620646561646c696e652c000000000000000000000000000000000000000000608083015282519a8b9181610222602085018096611f93565b918237018a8152039961025b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09b8c8101835282611437565b5190209085515161026b81611ebb565b908a5b8181106102f95750506102f6999a6102ed9183516102a081610294602082018095611f66565b03848101835282611437565b519020602089810151858b015195519182019687526040820192909252336060820152608081019190915260a081019390935260643560c08401528260e081015b03908101835282611437565b51902093611cf7565b80f35b8061031161030b610321938c5161175e565b51612054565b61031b828661175e565b52611f0a565b61026e565b8880fd5b8780fd5b8480fd5b8380fd5b5080fd5b5091346103365760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103365767ffffffffffffffff9080358281116103325761038b903690830161164b565b60243583811161032e576103a2903690840161161a565b9390926103ad6114e6565b9160643590811161049f576103c4913691016115c1565b949093835151976103d489611ebb565b98885b81811061047d5750506102f697988151610425816103f9602082018095611f66565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282611437565b5190206020860151828701519083519260208401947ffcf35f5ac6a2c28868dc44c302166470266239195f02b0ee408334829333b7668652840152336060840152608083015260a082015260a081526102ed8161141b565b808b61031b8261049461030b61049a968d5161175e565b9261175e565b6103d7565b8680fd5b5082346105bf57602090817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103325780359067ffffffffffffffff821161032e576104f49136910161161a565b929091845b848110610504578580f35b8061051a610515600193888861196c565b61197c565b61052f84610529848a8a61196c565b0161197c565b3389528385528589209173ffffffffffffffffffffffffffffffffffffffff80911692838b528652868a20911690818a5285528589207fffffffffffffffffffffffff000000000000000000000000000000000000000081541690558551918252848201527f89b1add15eff56b3dfe299ad94e01f2b52fbcb80ae1a3baea6ae8c04cb2b98a4853392a2016104f9565b8280fd5b50346103365760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033657610676816105ff6114a0565b936106086114c3565b6106106114e6565b73ffffffffffffffffffffffffffffffffffffffff968716835260016020908152848420928816845291825283832090871683528152919020549251938316845260a083901c65ffffffffffff169084015260d09190911c604083015281906060820190565b0390f35b50346103365760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610336576106b26114a0565b906106bb6114c3565b916106c46114e6565b65ffffffffffff926064358481169081810361032a5779ffffffffffff0000000000000000000000000000000000000000947fda9fa7c1b00402c17d0161b249b1ab8bbec047c5a52207b9c112deffd817036b94338a5260016020527fffffffffffff0000000000000000000000000000000000000000000000000000858b209873ffffffffffffffffffffffffffffffffffffffff809416998a8d5260205283878d209b169a8b8d52602052868c209486156000146107a457504216925b8454921697889360a01b16911617179055815193845260208401523392a480f35b905092610783565b5082346105bf5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105bf576107e56114a0565b906107ee6114c3565b9265ffffffffffff604435818116939084810361032a57338852602091600183528489209673ffffffffffffffffffffffffffffffffffffffff80911697888b528452858a20981697888a5283528489205460d01c93848711156109175761ffff9085840316116108f05750907f55eb90d810e1700b35a8e7e25395ff7f2b2259abd7415ca2284dfb1c246418f393929133895260018252838920878a528252838920888a5282528389209079ffffffffffffffffffffffffffffffffffffffffffffffffffff7fffffffffffff000000000000000000000000000000000000000000000000000083549260d01b16911617905582519485528401523392a480f35b84517f24d35a26000000000000000000000000000000000000000000000000000000008152fd5b5084517f756688fe000000000000000000000000000000000000000000000000000000008152fd5b503461033657807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610336578060209273ffffffffffffffffffffffffffffffffffffffff61098f6114a0565b1681528084528181206024358252845220549051908152f35b5082346105bf57817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105bf577f3704902f963766a4e561bbaab6e6cdc1b1dd12f6e9e99648da8843b3f46b918d90359160243533855284602052818520848652602052818520818154179055815193845260208401523392a280f35b8234610a9a5760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610a9a57610a606114a0565b610a686114c3565b610a706114e6565b6064359173ffffffffffffffffffffffffffffffffffffffff8316830361032e576102f6936117a1565b80fd5b503461033657817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033657602090610ad7611b1e565b9051908152f35b508290346105bf576101007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105bf57610b1a3661152a565b90807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7c36011261033257610b4c611478565b9160e43567ffffffffffffffff8111610bda576102f694610b6f913691016115c1565b939092610b7c8351612054565b6020840151828501519083519260208401947f939c21a48a8dbe3a9a2404a1d46691e4d39f6583d6ec6b35714604c986d801068652840152336060840152608083015260a082015260a08152610bd18161141b565b51902091611c25565b8580fd5b509134610336576101007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033657610c186114a0565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc360160c08112610332576080855191610c51836113e3565b1261033257845190610c6282611398565b73ffffffffffffffffffffffffffffffffffffffff91602435838116810361049f578152604435838116810361049f57602082015265ffffffffffff606435818116810361032a5788830152608435908116810361049f576060820152815260a435938285168503610bda576020820194855260c4359087830182815260e43567ffffffffffffffff811161032657610cfe90369084016115c1565b929093804211610d88575050918591610d786102f6999a610d7e95610d238851611fbe565b90898c511690519083519260208401947ff3841cd1ff0085026a6327b620b67997ce40f282c88a8e905a7a5626e310f3d086528401526060830152608082015260808152610d70816113ff565b519020611bd9565b916120c7565b519251169161199d565b602492508a51917fcd21db4f000000000000000000000000000000000000000000000000000000008352820152fd5b5091346103365760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc93818536011261033257610df36114a0565b9260249081359267ffffffffffffffff9788851161032a578590853603011261049f578051978589018981108282111761104a578252848301358181116103265785019036602383011215610326578382013591610e50836115ef565b90610e5d85519283611437565b838252602093878584019160071b83010191368311611046578801905b828210610fe9575050508a526044610e93868801611509565b96838c01978852013594838b0191868352604435908111610fe557610ebb90369087016115c1565b959096804211610fba575050508998995151610ed681611ebb565b908b5b818110610f9757505092889492610d7892610f6497958351610f02816103f98682018095611f66565b5190209073ffffffffffffffffffffffffffffffffffffffff9a8b8b51169151928551948501957faf1b0d30d2cab0380e68f0689007e3254993c596f2fdd0aaa7f4d04f794408638752850152830152608082015260808152610d70816113ff565b51169082515192845b848110610f78578580f35b80610f918585610f8b600195875161175e565b5161199d565b01610f6d565b80610311610fac8e9f9e93610fb2945161175e565b51611fbe565b9b9a9b610ed9565b8551917fcd21db4f000000000000000000000000000000000000000000000000000000008352820152fd5b8a80fd5b6080823603126110465785608091885161100281611398565b61100b85611509565b8152611018838601611509565b838201526110278a8601611607565b8a8201528d611037818701611607565b90820152815201910190610e7a565b8c80fd5b84896041867f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b5082346105bf576101407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105bf576110b03661152a565b91807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7c360112610332576110e2611478565b67ffffffffffffffff93906101043585811161049f5761110590369086016115c1565b90936101243596871161032a57611125610bd1966102f6983691016115c1565b969095825190611134826113ff565b606482527f5065726d69745769746e6573735472616e7366657246726f6d28546f6b656e5060208301527f65726d697373696f6e73207065726d69747465642c6164647265737320737065848301527f6e6465722c75696e74323536206e6f6e63652c75696e7432353620646561646c60608301527f696e652c0000000000000000000000000000000000000000000000000000000060808301528351948591816111e3602085018096611f93565b918237018b8152039361121c7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe095868101835282611437565b5190209261122a8651612054565b6020878101518589015195519182019687526040820192909252336060820152608081019190915260a081019390935260e43560c08401528260e081016102e1565b5082346105bf576020807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033257813567ffffffffffffffff92838211610bda5736602383011215610bda5781013592831161032e576024906007368386831b8401011161049f57865b8581106112e5578780f35b80821b83019060807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc83360301126103265761139288876001946060835161132c81611398565b611368608461133c8d8601611509565b9485845261134c60448201611509565b809785015261135d60648201611509565b809885015201611509565b918291015273ffffffffffffffffffffffffffffffffffffffff80808093169516931691166117a1565b016112da565b6080810190811067ffffffffffffffff8211176113b457604052565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6060810190811067ffffffffffffffff8211176113b457604052565b60a0810190811067ffffffffffffffff8211176113b457604052565b60c0810190811067ffffffffffffffff8211176113b457604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff8211176113b457604052565b60c4359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b600080fd5b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b6044359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01906080821261149b576040805190611563826113e3565b8082941261149b57805181810181811067ffffffffffffffff8211176113b457825260043573ffffffffffffffffffffffffffffffffffffffff8116810361149b578152602435602082015282526044356020830152606435910152565b9181601f8401121561149b5782359167ffffffffffffffff831161149b576020838186019501011161149b57565b67ffffffffffffffff81116113b45760051b60200190565b359065ffffffffffff8216820361149b57565b9181601f8401121561149b5782359167ffffffffffffffff831161149b576020808501948460061b01011161149b57565b91909160608184031261149b576040805191611666836113e3565b8294813567ffffffffffffffff9081811161149b57830182601f8201121561149b578035611693816115ef565b926116a087519485611437565b818452602094858086019360061b8501019381851161149b579086899897969594939201925b8484106116e3575050505050855280820135908501520135910152565b90919293949596978483031261149b578851908982019082821085831117611730578a928992845261171487611509565b81528287013583820152815201930191908897969594936116c6565b602460007f4e487b710000000000000000000000000000000000000000000000000000000081526041600452fd5b80518210156117725760209160051b010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b92919273ffffffffffffffffffffffffffffffffffffffff604060008284168152600160205282828220961695868252602052818120338252602052209485549565ffffffffffff8760a01c16804211611884575082871696838803611812575b5050611810955016926118b5565b565b878484161160001461184f57602488604051907ff96fb0710000000000000000000000000000000000000000000000000000000082526004820152fd5b7fffffffffffffffffffffffff000000000000000000000000000000000000000084846118109a031691161790553880611802565b602490604051907fd81b2f2e0000000000000000000000000000000000000000000000000000000082526004820152fd5b9060006064926020958295604051947f23b872dd0000000000000000000000000000000000000000000000000000000086526004860152602485015260448401525af13d15601f3d116001600051141617161561190e57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f5452414e534645525f46524f4d5f4641494c45440000000000000000000000006044820152fd5b91908110156117725760061b0190565b3573ffffffffffffffffffffffffffffffffffffffff8116810361149b5790565b9065ffffffffffff908160608401511673ffffffffffffffffffffffffffffffffffffffff908185511694826020820151169280866040809401511695169560009187835260016020528383208984526020528383209916988983526020528282209184835460d01c03611af5579185611ace94927fc6a377bfc4eb120024a8ac08eef205be16b817020812c73223e81d1bdb9708ec98979694508715600014611ad35779ffffffffffff00000000000000000000000000000000000000009042165b60a01b167fffffffffffff00000000000000000000000000000000000000000000000000006001860160d01b1617179055519384938491604091949373ffffffffffffffffffffffffffffffffffffffff606085019616845265ffffffffffff809216602085015216910152565b0390a4565b5079ffffffffffff000000000000000000000000000000000000000087611a60565b600484517f756688fe000000000000000000000000000000000000000000000000000000008152fd5b467f000000000000000000000000000000000000000000000000000000000000000103611b69577f866a5aba21966af95d6c7ab78eb2b2fc913915c28be3b9aa07cc04ff903e3f2890565b60405160208101907f8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a86682527f9ac997416e8ff9d2ff6bebeb7149f65cdae5e32e2b90440b566bb3044041d36a604082015246606082015230608082015260808152611bd3816113ff565b51902090565b611be1611b1e565b906040519060208201927f190100000000000000000000000000000000000000000000000000000000000084526022830152604282015260428152611bd381611398565b9192909360a435936040840151804211611cc65750602084510151808611611c955750918591610d78611c6594611c60602088015186611e47565b611bd9565b73ffffffffffffffffffffffffffffffffffffffff809151511692608435918216820361149b57611810936118b5565b602490604051907f3728b83d0000000000000000000000000000000000000000000000000000000082526004820152fd5b602490604051907fcd21db4f0000000000000000000000000000000000000000000000000000000082526004820152fd5b959093958051519560409283830151804211611e175750848803611dee57611d2e918691610d7860209b611c608d88015186611e47565b60005b868110611d42575050505050505050565b611d4d81835161175e565b5188611d5a83878a61196c565b01359089810151808311611dbe575091818888886001968596611d84575b50505050505001611d31565b611db395611dad9273ffffffffffffffffffffffffffffffffffffffff6105159351169561196c565b916118b5565b803888888883611d78565b6024908651907f3728b83d0000000000000000000000000000000000000000000000000000000082526004820152fd5b600484517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b6024908551907fcd21db4f0000000000000000000000000000000000000000000000000000000082526004820152fd5b9073ffffffffffffffffffffffffffffffffffffffff600160ff83161b9216600052600060205260406000209060081c6000526020526040600020818154188091551615611e9157565b60046040517f756688fe000000000000000000000000000000000000000000000000000000008152fd5b90611ec5826115ef565b611ed26040519182611437565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0611f0082946115ef565b0190602036910137565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114611f375760010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b805160208092019160005b828110611f7f575050505090565b835185529381019392810192600101611f71565b9081519160005b838110611fab575050016000815290565b8060208092840101518185015201611f9a565b60405160208101917f65626cad6cb96493bf6f5ebea28756c966f023ab9e8a83a7101849d5573b3678835273ffffffffffffffffffffffffffffffffffffffff8082511660408401526020820151166060830152606065ffffffffffff9182604082015116608085015201511660a082015260a0815260c0810181811067ffffffffffffffff8211176113b45760405251902090565b6040516020808201927f618358ac3db8dc274f0cd8829da7e234bd48cd73c4a740aede1adec9846d06a1845273ffffffffffffffffffffffffffffffffffffffff81511660408401520151606082015260608152611bd381611398565b919082604091031261149b576020823592013590565b6000843b61222e5750604182036121ac576120e4828201826120b1565b939092604010156117725760209360009360ff6040608095013560f81c5b60405194855216868401526040830152606082015282805260015afa156121a05773ffffffffffffffffffffffffffffffffffffffff806000511691821561217657160361214c57565b60046040517f815e1d64000000000000000000000000000000000000000000000000000000008152fd5b60046040517f8baa579f000000000000000000000000000000000000000000000000000000008152fd5b6040513d6000823e3d90fd5b60408203612204576121c0918101906120b1565b91601b7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84169360ff1c019060ff8211611f375760209360009360ff608094612102565b60046040517f4be6321b000000000000000000000000000000000000000000000000000000008152fd5b929391601f928173ffffffffffffffffffffffffffffffffffffffff60646020957fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0604051988997889687947f1626ba7e000000000000000000000000000000000000000000000000000000009e8f8752600487015260406024870152816044870152868601378b85828601015201168101030192165afa9081156123a857829161232a575b507fffffffff000000000000000000000000000000000000000000000000000000009150160361230057565b60046040517fb0669cbc000000000000000000000000000000000000000000000000000000008152fd5b90506020813d82116123a0575b8161234460209383611437565b810103126103365751907fffffffff0000000000000000000000000000000000000000000000000000000082168203610a9a57507fffffffff0000000000000000000000000000000000000000000000000000000090386122d4565b3d9150612337565b6040513d84823e3d90fdfea164736f6c6343000811000a\";\n        assembly {\n            return(add(bytecode, 0x20), mload(bytecode))\n        }\n    }\n\n    ///// STUBS /////\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {}\n\n    function nonceBitmap(address, uint256) external view returns (uint256) {}\n\n    function permitTransferFrom(\n        IPermit2.PermitTransferFrom memory permit,\n        IPermit2.SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external {}\n\n    function permitTransferFrom(\n        IPermit2.PermitBatchTransferFrom memory permit,\n        IPermit2.SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external {}\n}\n"},"@sense-finance/v1-core/src/adapters/implementations/compound/CFactory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Internal references\nimport { CropFactory } from \"../../abstract/factories/CropFactory.sol\";\nimport { CAdapter, ComptrollerLike } from \"./CAdapter.sol\";\nimport { BaseAdapter } from \"../../abstract/BaseAdapter.sol\";\nimport { ExtractableReward } from \"../../abstract/extensions/ExtractableReward.sol\";\nimport { Divider } from \"../../../Divider.sol\";\n\n// External references\nimport { Bytes32AddressLib } from \"solmate/src/utils/Bytes32AddressLib.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\ninterface CTokenLike {\n    function underlying() external view returns (address);\n}\n\ncontract CFactory is CropFactory {\n    using Bytes32AddressLib for address;\n\n    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant CETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    address public constant COMP = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n\n    constructor(\n        address _divider,\n        address _restrictedAdmin,\n        address _rewardsRecipient,\n        FactoryParams memory _factoryParams,\n        address _reward\n    ) CropFactory(_divider, _restrictedAdmin, _rewardsRecipient, _factoryParams, _reward) {}\n\n    function deployAdapter(address _target, bytes memory) external override returns (address adapter) {\n        // Sanity check\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n\n        (bool isListed, , ) = ComptrollerLike(COMPTROLLER).markets(_target);\n        if (!isListed) revert Errors.TargetNotSupported();\n\n        // Use the CREATE2 opcode to deploy a new Adapter contract.\n        // This will revert if a CAdapter with the provided target has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        BaseAdapter.AdapterParams memory adapterParams = BaseAdapter.AdapterParams({\n            oracle: factoryParams.oracle,\n            stake: factoryParams.stake,\n            stakeSize: factoryParams.stakeSize,\n            minm: factoryParams.minm,\n            maxm: factoryParams.maxm,\n            mode: factoryParams.mode,\n            tilt: factoryParams.tilt,\n            level: DEFAULT_LEVEL\n        });\n        adapter = address(\n            new CAdapter{ salt: _target.fillLast12Bytes() }(\n                divider,\n                _target,\n                _target == CETH ? WETH : CTokenLike(_target).underlying(),\n                rewardsRecipient,\n                factoryParams.ifee,\n                adapterParams,\n                reward\n            )\n        );\n\n        _setGuard(adapter);\n\n        ExtractableReward(adapter).setIsTrusted(restrictedAdmin, true);\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/implementations/fuse/FFactory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Internal references\nimport { FAdapter, FComptrollerLike, RewardsDistributorLike } from \"./FAdapter.sol\";\nimport { BaseFactory } from \"../../abstract/factories/BaseFactory.sol\";\nimport { BaseAdapter } from \"../../abstract/BaseAdapter.sol\";\nimport { ExtractableReward } from \"../../abstract/extensions/ExtractableReward.sol\";\nimport { Divider } from \"../../../Divider.sol\";\n\n// External references\nimport { Bytes32AddressLib } from \"solmate/src/utils/Bytes32AddressLib.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\ninterface FTokenLike {\n    function underlying() external view returns (address);\n\n    function isCEther() external view returns (bool);\n}\n\ninterface FusePoolLensLike {\n    function poolExists(address comptroller) external view returns (bool);\n}\n\ncontract FFactory is BaseFactory {\n    using Bytes32AddressLib for address;\n\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant FUSE_POOL_DIRECTORY = 0x835482FE0532f169024d5E9410199369aAD5C77E;\n\n    constructor(\n        address _divider,\n        address _restrictedAdmin,\n        address _rewardsRecipient,\n        FactoryParams memory _factoryParams\n    ) BaseFactory(_divider, _restrictedAdmin, _rewardsRecipient, _factoryParams) {}\n\n    function deployAdapter(address _target, bytes memory data) external override returns (address adapter) {\n        address comptroller = abi.decode(data, (address));\n\n        /// Sanity checks\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n        if (!FusePoolLensLike(FUSE_POOL_DIRECTORY).poolExists(comptroller)) revert Errors.InvalidParam();\n        (bool isListed, ) = FComptrollerLike(comptroller).markets(_target);\n        if (!isListed) revert Errors.TargetNotSupported();\n\n        // Initialize rewardTokens by calling getRewardsDistributors() -> rewardToken()\n        address[] memory rewardsDistributors = FComptrollerLike(comptroller).getRewardsDistributors();\n        address[] memory rewardTokens = new address[](rewardsDistributors.length);\n        address[] memory targetRewardsDistributors = new address[](rewardsDistributors.length);\n\n        uint256 idx;\n        for (uint256 i = 0; i < rewardsDistributors.length; i++) {\n            (, uint32 lastUpdatedTimestamp) = RewardsDistributorLike(rewardsDistributors[i]).marketState(_target);\n            if (lastUpdatedTimestamp > 0) {\n                rewardTokens[idx] = RewardsDistributorLike(rewardsDistributors[i]).rewardToken();\n                targetRewardsDistributors[idx] = rewardsDistributors[i];\n                idx = idx + 1;\n            }\n        }\n\n        address underlying = FTokenLike(_target).underlying();\n        BaseAdapter.AdapterParams memory adapterParams = BaseAdapter.AdapterParams({\n            oracle: factoryParams.oracle,\n            stake: factoryParams.stake,\n            stakeSize: factoryParams.stakeSize,\n            minm: factoryParams.minm,\n            maxm: factoryParams.maxm,\n            mode: factoryParams.mode,\n            tilt: factoryParams.tilt,\n            level: DEFAULT_LEVEL\n        });\n        // Use the CREATE2 opcode to deploy a new Adapter contract.\n        // This will revert if a FAdapter with the provided target has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        adapter = address(\n            new FAdapter{ salt: _target.fillLast12Bytes() }(\n                divider,\n                _target,\n                FTokenLike(_target).isCEther() ? WETH : underlying,\n                rewardsRecipient,\n                factoryParams.ifee,\n                comptroller,\n                adapterParams,\n                rewardTokens,\n                targetRewardsDistributors\n            )\n        );\n\n        _setGuard(adapter);\n\n        ExtractableReward(adapter).setIsTrusted(restrictedAdmin, true);\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/implementations/lido/WstETHAdapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { FixedMath } from \"../../../external/FixedMath.sol\";\n\n// Internal references\nimport { BaseAdapter } from \"../../abstract/BaseAdapter.sol\";\nimport { ExtractableReward } from \"../../abstract/extensions/ExtractableReward.sol\";\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\ninterface WstETHLike {\n    /// @notice Exchanges wstETH to stETH\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n\n    /// @notice Exchanges stETH to wstETH\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n}\n\ninterface StETHLike {\n    /// @notice Get amount of stETH for a one wstETH\n    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);\n}\n\ninterface PriceOracleLike {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n/// @notice Adapter contract for wstETH\ncontract WstETHAdapter is BaseAdapter, ExtractableReward {\n    using FixedMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    address public constant WSTETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n    address public constant STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n    address public constant STETH_USD_PRICEFEED = 0xCfE54B5cD566aB89272946F602D76Ea879CAb4a8; // Chainlink stETH-USD price feed\n    address public constant ETH_USD_PRICEFEED = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419; // Chainlink ETH-USD price feed\n\n    /// @notice Cached scale value from the last call to `scale()`\n    uint256 public override scaleStored;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        BaseAdapter.AdapterParams memory _adapterParams\n    ) BaseAdapter(_divider, _target, STETH, _ifee, _adapterParams) ExtractableReward(_rewardsRecipient) {\n        // approve wstETH contract to pull stETH (used on wrapUnderlying())\n        ERC20(STETH).approve(WSTETH, type(uint256).max);\n        // set an inital cached scale value\n        scaleStored = StETHLike(STETH).getPooledEthByShares(1 ether);\n    }\n\n    /// @return exRate Eth per wstEtH (natively in 18 decimals)\n    function scale() external virtual override returns (uint256 exRate) {\n        exRate = StETHLike(STETH).getPooledEthByShares(1 ether);\n\n        if (exRate != scaleStored) {\n            // update value only if different than the previous\n            scaleStored = exRate;\n        }\n    }\n\n    /// @dev To calculate stETH-ETH price we use Chainlink's stETH-USD and ETH-USD price feeds.\n    function getUnderlyingPrice() external view override returns (uint256 price) {\n        (, int256 stethPrice, , uint256 stethUpdatedAt, ) = PriceOracleLike(STETH_USD_PRICEFEED).latestRoundData();\n        (, int256 ethPrice, , uint256 ethUpdatedAt, ) = PriceOracleLike(ETH_USD_PRICEFEED).latestRoundData();\n        if (block.timestamp - stethUpdatedAt > 2 hours) revert Errors.InvalidPrice();\n        if (block.timestamp - ethUpdatedAt > 2 hours) revert Errors.InvalidPrice();\n        price = uint256(stethPrice).fdiv(uint256(ethPrice));\n        if (price < 0) revert Errors.InvalidPrice();\n    }\n\n    function unwrapTarget(uint256 amount) external override returns (uint256 stETH) {\n        ERC20(WSTETH).safeTransferFrom(msg.sender, address(this), amount); // pull wstETH\n        // unwrap wstETH into stETH and transfer it back to sender\n        ERC20(STETH).safeTransfer(msg.sender, stETH = WstETHLike(WSTETH).unwrap(amount));\n    }\n\n    function wrapUnderlying(uint256 amount) external override returns (uint256 wstETH) {\n        ERC20(STETH).safeTransferFrom(msg.sender, address(this), amount); // pull STETH\n        // wrap stETH into wstETH and transfer it back to sender\n        ERC20(WSTETH).safeTransfer(msg.sender, wstETH = WstETHLike(WSTETH).wrap(amount));\n    }\n\n    function _isValid(address _token) internal override returns (bool) {\n        return (_token != target && _token != adapterParams.stake);\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/implementations/claimers/PingPongClaimer.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\n\n// Internal references\nimport { IClaimer } from \"../../../adapters/abstract/IClaimer.sol\";\nimport { BaseAdapter } from \"../../../adapters/abstract/BaseAdapter.sol\";\n\n/// @title ExtractableReward\n/// @dev This claimer only returns the received target back to the adapter. This is because\n/// target has automatic rewards claiming which is triggered when transferring the target.\ncontract PingPongClaimer is IClaimer {\n    function claim() external virtual {\n        ERC20 target = ERC20(BaseAdapter(msg.sender).target());\n        target.transfer(msg.sender, target.balanceOf(address(this)));\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/implementations/lido/OwnableWstETHAdapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { BaseAdapter } from \"../../abstract/BaseAdapter.sol\";\nimport { WstETHAdapter } from \"../../implementations/lido/WstETHAdapter.sol\";\n\ninterface Opener {\n    function onSponsorWindowOpened(address, uint256) external;\n}\n\n/// @notice Adapter contract for wstETH\ncontract OwnableWstETHAdapter is WstETHAdapter {\n    /// @notice Ownabale param\n    uint256 internal open = 1;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        BaseAdapter.AdapterParams memory _adapterParams\n    ) WstETHAdapter(_divider, _target, _rewardsRecipient, _ifee, _adapterParams) {}\n\n    function openSponsorWindow() external requiresTrust {\n        open = 2;\n        Opener(msg.sender).onSponsorWindowOpened(adapterParams.stake, adapterParams.stakeSize);\n        open = 1;\n    }\n\n    function getMaturityBounds() external view override returns (uint256, uint256) {\n        return open == 2 ? (adapterParams.minm, adapterParams.maxm) : (0, 0);\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/factories/ERC4626CropsFactory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Internal references\nimport { Divider } from \"../../../Divider.sol\";\nimport { ERC4626CropsAdapter } from \"../erc4626/ERC4626CropsAdapter.sol\";\nimport { BaseAdapter } from \"../../abstract/BaseAdapter.sol\";\nimport { BaseFactory } from \"./BaseFactory.sol\";\nimport { ExtractableReward } from \"../../abstract/extensions/ExtractableReward.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\n\n// External references\nimport { Bytes32AddressLib } from \"solmate/src/utils/Bytes32AddressLib.sol\";\n\ncontract ERC4626CropsFactory is BaseFactory {\n    using Bytes32AddressLib for address;\n\n    mapping(address => bool) public supportedTargets;\n\n    constructor(\n        address _divider,\n        address _restrictedAdmin,\n        address _rewardsRecipient,\n        FactoryParams memory _factoryParams\n    ) BaseFactory(_divider, _restrictedAdmin, _rewardsRecipient, _factoryParams) {}\n\n    /// @notice Deploys an ERC4626Adapter contract\n    /// @param _target The target address\n    /// @param data ABI encoded data\n    function deployAdapter(address _target, bytes memory data) external override returns (address adapter) {\n        address[] memory rewardTokens = abi.decode(data, (address[]));\n\n        /// Sanity checks\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n        if (!Divider(divider).permissionless() && !supportedTargets[_target]) revert Errors.TargetNotSupported();\n\n        BaseAdapter.AdapterParams memory adapterParams = BaseAdapter.AdapterParams({\n            oracle: factoryParams.oracle,\n            stake: factoryParams.stake,\n            stakeSize: factoryParams.stakeSize,\n            minm: factoryParams.minm,\n            maxm: factoryParams.maxm,\n            mode: factoryParams.mode,\n            tilt: factoryParams.tilt,\n            level: DEFAULT_LEVEL\n        });\n\n        // Use the CREATE2 opcode to deploy a new Adapter contract.\n        // This will revert if am ERC4626 adapter with the provided target has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        adapter = address(\n            new ERC4626CropsAdapter{ salt: _target.fillLast12Bytes() }(\n                divider,\n                _target,\n                rewardsRecipient,\n                factoryParams.ifee,\n                adapterParams,\n                rewardTokens\n            )\n        );\n\n        _setGuard(adapter);\n\n        ExtractableReward(adapter).setIsTrusted(restrictedAdmin, true);\n    }\n\n    /// @notice (Un)support target\n    /// @param _target The target address\n    /// @param supported Whether the target should be supported or not\n    function supportTarget(address _target, bool supported) external requiresTrust {\n        supportedTargets[_target] = supported;\n        emit TargetSupported(_target, supported);\n    }\n\n    /// @notice (Un)support multiple target at once\n    /// @param _targets Array of target addresses\n    /// @param supported Whether the targets should be supported or not\n    function supportTargets(address[] memory _targets, bool supported) external requiresTrust {\n        for (uint256 i = 0; i < _targets.length; i++) {\n            supportedTargets[_targets[i]] = supported;\n            emit TargetSupported(_targets[i], supported);\n        }\n    }\n\n    /* ========== LOGS ========== */\n\n    event TargetSupported(address indexed target, bool indexed supported);\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/factories/ERC4626Factory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Internal references\nimport { Divider } from \"../../../Divider.sol\";\nimport { ERC4626Adapter } from \"../erc4626/ERC4626Adapter.sol\";\nimport { BaseAdapter } from \"../../abstract/BaseAdapter.sol\";\nimport { ExtractableReward } from \"../../abstract/extensions/ExtractableReward.sol\";\nimport { BaseFactory } from \"./BaseFactory.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\n// External references\nimport { Bytes32AddressLib } from \"solmate/src/utils/Bytes32AddressLib.sol\";\n\ncontract ERC4626Factory is BaseFactory {\n    using Bytes32AddressLib for address;\n\n    mapping(address => bool) public supportedTargets;\n\n    constructor(\n        address _divider,\n        address _restrictedAdmin,\n        address _rewardsRecipient,\n        FactoryParams memory _factoryParams\n    ) BaseFactory(_divider, _restrictedAdmin, _rewardsRecipient, _factoryParams) {}\n\n    /// @notice Deploys an ERC4626Adapter contract\n    /// @param _target The target address\n    /// @param data ABI encoded reward tokens address array\n    function deployAdapter(address _target, bytes memory data) external virtual override returns (address adapter) {\n        /// Sanity checks\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n        if (!Divider(divider).permissionless() && !supportedTargets[_target]) revert Errors.TargetNotSupported();\n\n        BaseAdapter.AdapterParams memory adapterParams = BaseAdapter.AdapterParams({\n            oracle: factoryParams.oracle,\n            stake: factoryParams.stake,\n            stakeSize: factoryParams.stakeSize,\n            minm: factoryParams.minm,\n            maxm: factoryParams.maxm,\n            mode: factoryParams.mode,\n            tilt: factoryParams.tilt,\n            level: DEFAULT_LEVEL\n        });\n\n        // Use the CREATE2 opcode to deploy a new Adapter contract.\n        // This will revert if an ERC4626 adapter with the provided target has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        adapter = address(\n            new ERC4626Adapter{ salt: _target.fillLast12Bytes() }(\n                divider,\n                _target,\n                rewardsRecipient,\n                factoryParams.ifee,\n                adapterParams\n            )\n        );\n\n        _setGuard(adapter);\n\n        ExtractableReward(adapter).setIsTrusted(restrictedAdmin, true);\n    }\n\n    /// @notice (Un)support target\n    /// @param _target The target address\n    /// @param supported Whether the target should be supported or not\n    function supportTarget(address _target, bool supported) external requiresTrust {\n        supportedTargets[_target] = supported;\n        emit TargetSupported(_target, supported);\n    }\n\n    /// @notice (Un)support multiple target at once\n    /// @param _targets Array of target addresses\n    /// @param supported Whether the targets should be supported or not\n    function supportTargets(address[] memory _targets, bool supported) external requiresTrust {\n        for (uint256 i = 0; i < _targets.length; i++) {\n            supportedTargets[_targets[i]] = supported;\n            emit TargetSupported(_targets[i], supported);\n        }\n    }\n\n    /* ========== LOGS ========== */\n\n    event TargetSupported(address indexed target, bool indexed supported);\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/factories/ERC4626CropFactory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Internal references\nimport { Divider } from \"../../../Divider.sol\";\nimport { ERC4626CropAdapter } from \"../erc4626/ERC4626CropAdapter.sol\";\nimport { BaseAdapter } from \"../../abstract/BaseAdapter.sol\";\nimport { ExtractableReward } from \"../../abstract/extensions/ExtractableReward.sol\";\nimport { CropFactory } from \"./CropFactory.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\n// External references\nimport { Bytes32AddressLib } from \"solmate/src/utils/Bytes32AddressLib.sol\";\n\ncontract ERC4626CropFactory is CropFactory {\n    using Bytes32AddressLib for address;\n\n    mapping(address => bool) public supportedTargets;\n\n    constructor(\n        address _divider,\n        address _restrictedAdmin,\n        address _rewardsRecipient,\n        FactoryParams memory _factoryParams\n    ) CropFactory(_divider, _restrictedAdmin, _rewardsRecipient, _factoryParams, address(0)) {}\n\n    /// @notice Deploys an ERC4626Adapter contract\n    /// @param _target The target address\n    /// @param data ABI encoded data\n    function deployAdapter(address _target, bytes memory data) external virtual override returns (address adapter) {\n        address reward = abi.decode(data, (address));\n\n        /// Sanity checks\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n        if (!Divider(divider).permissionless() && !supportedTargets[_target]) revert Errors.TargetNotSupported();\n\n        BaseAdapter.AdapterParams memory adapterParams = BaseAdapter.AdapterParams({\n            oracle: factoryParams.oracle,\n            stake: factoryParams.stake,\n            stakeSize: factoryParams.stakeSize,\n            minm: factoryParams.minm,\n            maxm: factoryParams.maxm,\n            mode: factoryParams.mode,\n            tilt: factoryParams.tilt,\n            level: DEFAULT_LEVEL\n        });\n\n        // Use the CREATE2 opcode to deploy a new Adapter contract.\n        // This will revert if am ERC4626 adapter with the provided target has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        adapter = address(\n            new ERC4626CropAdapter{ salt: _target.fillLast12Bytes() }(\n                divider,\n                _target,\n                rewardsRecipient,\n                factoryParams.ifee,\n                adapterParams,\n                reward\n            )\n        );\n\n        _setGuard(adapter);\n\n        ExtractableReward(adapter).setIsTrusted(restrictedAdmin, true);\n    }\n\n    /// @notice (Un)support target\n    /// @param _target The target address\n    /// @param supported Whether the target should be supported or not\n    function supportTarget(address _target, bool supported) external requiresTrust {\n        supportedTargets[_target] = supported;\n        emit TargetSupported(_target, supported);\n    }\n\n    /// @notice (Un)support multiple target at once\n    /// @param _targets Array of target addresses\n    /// @param supported Whether the targets should be supported or not\n    function supportTargets(address[] memory _targets, bool supported) external requiresTrust {\n        for (uint256 i = 0; i < _targets.length; i++) {\n            supportedTargets[_targets[i]] = supported;\n            emit TargetSupported(_targets[i], supported);\n        }\n    }\n\n    /* ========== LOGS ========== */\n\n    event TargetSupported(address indexed target, bool indexed supported);\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/factories/OwnableERC4626Factory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Internal references\nimport { Divider } from \"../../../Divider.sol\";\nimport { BaseAdapter } from \"../../abstract/BaseAdapter.sol\";\nimport { OwnableERC4626Adapter } from \"../erc4626/OwnableERC4626Adapter.sol\";\nimport { ERC4626Factory } from \"./ERC4626Factory.sol\";\nimport { ExtractableReward } from \"../../abstract/extensions/ExtractableReward.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\n// External references\nimport { Bytes32AddressLib } from \"solmate/src/utils/Bytes32AddressLib.sol\";\n\n/// @notice Ownable Factoy contract that deploys Ownable Adapters for Rolling Liquidity Vaults\ncontract OwnableERC4626Factory is ERC4626Factory {\n    using Bytes32AddressLib for address;\n\n    /// @notice Rolling Liquidity Vault Factory address\n    address public rlvFactory;\n\n    constructor(\n        address _divider,\n        address _restrictedAdmin,\n        address _rewardsRecipient,\n        FactoryParams memory _factoryParams,\n        address _rlvFactory\n    ) ERC4626Factory(_divider, _restrictedAdmin, _rewardsRecipient, _factoryParams) {\n        rlvFactory = _rlvFactory;\n    }\n\n    /// @notice Deploys an OwnableERC4626Adapter contract\n    /// @param _target The target address\n    /// @param data ABI encoded reward tokens address array\n    function deployAdapter(address _target, bytes memory data) external override returns (address adapter) {\n        /// Sanity checks\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n        if (!Divider(divider).permissionless() && !supportedTargets[_target]) revert Errors.TargetNotSupported();\n\n        BaseAdapter.AdapterParams memory adapterParams = BaseAdapter.AdapterParams({\n            oracle: factoryParams.oracle,\n            stake: factoryParams.stake,\n            stakeSize: factoryParams.stakeSize,\n            minm: factoryParams.minm,\n            maxm: factoryParams.maxm,\n            mode: factoryParams.mode,\n            tilt: factoryParams.tilt,\n            level: DEFAULT_LEVEL\n        });\n\n        // Use the CREATE2 opcode to deploy a new Adapter contract.\n        // This will revert if an ERC4626 adapter with the provided target has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        adapter = address(\n            new OwnableERC4626Adapter{ salt: _target.fillLast12Bytes() }(\n                divider,\n                _target,\n                rewardsRecipient,\n                factoryParams.ifee,\n                adapterParams\n            )\n        );\n\n        _setGuard(adapter);\n\n        // Factory must have adapter auth so that it can give auth to the RLV\n        OwnableERC4626Adapter(adapter).setIsTrusted(rlvFactory, true);\n\n        ExtractableReward(adapter).setIsTrusted(restrictedAdmin, true);\n    }\n\n    /// @notice Modify RLV Factory address\n    /// @param _rlvFactory Address of the new factory\n    function setRlvFactory(address _rlvFactory) external requiresTrust {\n        rlvFactory = _rlvFactory;\n        emit RlvFactoryChanged(_rlvFactory);\n    }\n\n    /* ========== LOGS ========== */\n\n    event RlvFactoryChanged(address indexed rlvFactory);\n}\n"},"@sense-finance/v1-core/src/adapters/implementations/oracles/ChainlinkPriceOracle.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { IPriceFeed } from \"../../abstract/IPriceFeed.sol\";\nimport { FixedMath } from \"../../../external/FixedMath.sol\";\n\ninterface FeedRegistryLike {\n    function latestRoundData(address base, address quote)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function decimals(address base, address quote) external view returns (uint8);\n}\n\n/// @title ChainlinkPriceOracle\n/// @notice Returns prices from Chainlink.\n/// @dev Implements `IPricefeed` and `Trust`.\n/// @author Inspired by: https://github.com/Rari-Capital/fuse-v1/blob/development/src/oracles/ChainlinkPriceOracleV3.sol\ncontract ChainlinkPriceOracle is IPriceFeed, Trust {\n    using FixedMath for uint256;\n\n    // Chainlink's denominations\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n    address public constant USD = address(840);\n\n    // The maxmimum number of seconds elapsed since the round was last updated before the price is considered stale. If set to 0, no limit is enforced.\n    uint256 public maxSecondsBeforePriceIsStale;\n\n    FeedRegistryLike public feedRegistry = FeedRegistryLike(0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf); // Chainlink feed registry contract\n\n    constructor(uint256 _maxSecondsBeforePriceIsStale) public Trust(msg.sender) {\n        maxSecondsBeforePriceIsStale = _maxSecondsBeforePriceIsStale;\n    }\n\n    /// @dev Internal function returning the price in ETH of `underlying`.\n    function _price(address underlying) internal view returns (uint256) {\n        // Return 1e18 for WETH\n        if (underlying == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) return 1e18;\n\n        // Try token/ETH to get token/ETH\n        try feedRegistry.latestRoundData(underlying, ETH) returns (\n            uint80,\n            int256 tokenEthPrice,\n            uint256,\n            uint256 updatedAt,\n            uint80\n        ) {\n            if (tokenEthPrice <= 0) return 0;\n            _validatePrice(updatedAt);\n            return uint256(tokenEthPrice).fmul(1e18).fdiv(10**uint256(feedRegistry.decimals(underlying, ETH)));\n        } catch Error(string memory reason) {\n            if (keccak256(abi.encodePacked(reason)) != keccak256(abi.encodePacked(\"Feed not found\")))\n                revert Errors.AttemptFailed();\n        }\n\n        // Try token/USD to get token/ETH\n        try feedRegistry.latestRoundData(underlying, USD) returns (\n            uint80,\n            int256 tokenUsdPrice,\n            uint256,\n            uint256 updatedAt,\n            uint80\n        ) {\n            if (tokenUsdPrice <= 0) return 0;\n            _validatePrice(updatedAt);\n\n            int256 ethUsdPrice;\n            (, ethUsdPrice, , updatedAt, ) = feedRegistry.latestRoundData(ETH, USD);\n            if (ethUsdPrice <= 0) return 0;\n            _validatePrice(updatedAt);\n            return\n                uint256(tokenUsdPrice).fmul(1e26).fdiv(10**uint256(feedRegistry.decimals(underlying, USD))).fdiv(\n                    uint256(ethUsdPrice)\n                );\n        } catch Error(string memory reason) {\n            if (keccak256(abi.encodePacked(reason)) != keccak256(abi.encodePacked(\"Feed not found\")))\n                revert Errors.AttemptFailed();\n        }\n\n        // Try token/BTC to get token/ETH\n        try feedRegistry.latestRoundData(underlying, BTC) returns (\n            uint80,\n            int256 tokenBtcPrice,\n            uint256,\n            uint256 updatedAt,\n            uint80\n        ) {\n            if (tokenBtcPrice <= 0) return 0;\n            _validatePrice(updatedAt);\n\n            int256 btcEthPrice;\n            (, btcEthPrice, , updatedAt, ) = feedRegistry.latestRoundData(BTC, ETH);\n            if (btcEthPrice <= 0) return 0;\n            _validatePrice(updatedAt);\n\n            return\n                uint256(tokenBtcPrice).fmul(uint256(btcEthPrice)).fdiv(\n                    10**uint256(feedRegistry.decimals(underlying, BTC))\n                );\n        } catch Error(string memory reason) {\n            if (keccak256(abi.encodePacked(reason)) != keccak256(abi.encodePacked(\"Feed not found\")))\n                revert Errors.AttemptFailed();\n        }\n\n        // Revert if all else fails\n        revert Errors.PriceOracleNotFound();\n    }\n\n    /// @dev validates the price returned from Chainlink\n    function _validatePrice(uint256 _updatedAt) internal view {\n        if (maxSecondsBeforePriceIsStale > 0 && block.timestamp > _updatedAt + maxSecondsBeforePriceIsStale)\n            revert Errors.InvalidPrice();\n    }\n\n    /// @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n    function price(address underlying) external view override returns (uint256) {\n        return _price(underlying);\n    }\n\n    /// @dev Sets the `maxSecondsBeforePriceIsStale`.\n    function setMaxSecondsBeforePriceIsStale(uint256 _maxSecondsBeforePriceIsStale) public requiresTrust {\n        maxSecondsBeforePriceIsStale = _maxSecondsBeforePriceIsStale;\n        emit MaxSecondsBeforePriceIsStaleChanged(maxSecondsBeforePriceIsStale);\n    }\n\n    /* ========== LOGS ========== */\n    event MaxSecondsBeforePriceIsStaleChanged(uint256 indexed maxSecondsBeforePriceIsStale);\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/factories/OwnableERC4626CropFactory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Internal references\nimport { Divider } from \"../../../Divider.sol\";\nimport { BaseAdapter } from \"../../abstract/BaseAdapter.sol\";\nimport { OwnableERC4626CropAdapter } from \"../erc4626/OwnableERC4626CropAdapter.sol\";\nimport { ERC4626CropFactory } from \"./ERC4626CropFactory.sol\";\nimport { ExtractableReward } from \"../../abstract/extensions/ExtractableReward.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\n// External references\nimport { Bytes32AddressLib } from \"solmate/src/utils/Bytes32AddressLib.sol\";\n\n/// @notice Ownable Crop Factory contract that deploys Ownable Crop Adapters for Rolling Liquidity Vaults\ncontract OwnableERC4626CropFactory is ERC4626CropFactory {\n    using Bytes32AddressLib for address;\n\n    /// @notice Rolling Liquidity Vault Factory address\n    address public rlvFactory;\n\n    constructor(\n        address _divider,\n        address _restrictedAdmin,\n        address _rewardsRecipient,\n        FactoryParams memory _factoryParams,\n        address _rlvFactory\n    ) ERC4626CropFactory(_divider, _restrictedAdmin, _rewardsRecipient, _factoryParams) {\n        rlvFactory = _rlvFactory;\n    }\n\n    /// @notice Deploys an OwnableERC4626Adapter contract\n    /// @param _target The target address\n    /// @param data ABI encoded reward tokens address array\n    function deployAdapter(address _target, bytes memory data) external override returns (address adapter) {\n        address reward = abi.decode(data, (address));\n\n        /// Sanity checks\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n        if (!Divider(divider).permissionless() && !supportedTargets[_target]) revert Errors.TargetNotSupported();\n\n        BaseAdapter.AdapterParams memory adapterParams = BaseAdapter.AdapterParams({\n            oracle: factoryParams.oracle,\n            stake: factoryParams.stake,\n            stakeSize: factoryParams.stakeSize,\n            minm: factoryParams.minm,\n            maxm: factoryParams.maxm,\n            mode: factoryParams.mode,\n            tilt: factoryParams.tilt,\n            level: DEFAULT_LEVEL\n        });\n\n        // Use the CREATE2 opcode to deploy a new Adapter contract.\n        // This will revert if an ERC4626 adapter with the provided target has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        adapter = address(\n            new OwnableERC4626CropAdapter{ salt: _target.fillLast12Bytes() }(\n                divider,\n                _target,\n                rewardsRecipient,\n                factoryParams.ifee,\n                adapterParams,\n                reward\n            )\n        );\n\n        _setGuard(adapter);\n\n        // Factory must have adapter auth so that it can give auth to the RLV\n        OwnableERC4626CropAdapter(adapter).setIsTrusted(rlvFactory, true);\n\n        ExtractableReward(adapter).setIsTrusted(restrictedAdmin, true);\n    }\n\n    /// @notice Modify RLV Factory address\n    /// @param _rlvFactory Address of the new factory\n    function setRlvFactory(address _rlvFactory) external requiresTrust {\n        rlvFactory = _rlvFactory;\n        emit RlvFactoryChanged(_rlvFactory);\n    }\n\n    /* ========== LOGS ========== */\n\n    event RlvFactoryChanged(address indexed rlvFactory);\n}\n"},"@sense-finance/v1-core/src/adapters/implementations/oracles/MasterPriceOracle.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { IPriceFeed } from \"../../abstract/IPriceFeed.sol\";\n\n/// @notice This contract gets prices from an available oracle address which must implement IPriceFeed.sol\n/// If there's no oracle set, it will try getting the price from Chainlink's Oracle.\n/// @author Inspired by: https://github.com/Rari-Capital/fuse-v1/blob/development/src/oracles/MasterPriceOracle.sol\ncontract MasterPriceOracle is IPriceFeed, Trust {\n    address public senseChainlinkPriceOracle;\n\n    /// @dev Maps underlying token addresses to oracle addresses.\n    mapping(address => address) public oracles;\n\n    /// @dev Constructor to initialize state variables.\n    /// @param _chainlinkOracle The underlying ERC20 token addresses to link to `_oracles`.\n    /// @param _underlyings The underlying ERC20 token addresses to link to `_oracles`.\n    /// @param _oracles The `PriceOracle` contracts to be assigned to `underlyings`.\n    constructor(\n        address _chainlinkOracle,\n        address[] memory _underlyings,\n        address[] memory _oracles\n    ) public Trust(msg.sender) {\n        senseChainlinkPriceOracle = _chainlinkOracle;\n\n        // Input validation\n        if (_underlyings.length != _oracles.length) revert Errors.InvalidParam();\n\n        // Initialize state variables\n        for (uint256 i = 0; i < _underlyings.length; i++) oracles[_underlyings[i]] = _oracles[i];\n    }\n\n    /// @dev Sets `_oracles` for `underlyings`.\n    /// Caller of this function must make sure that the oracles being added return non-stale, greater than 0\n    /// prices for all underlying tokens.\n    function add(address[] calldata _underlyings, address[] calldata _oracles) external requiresTrust {\n        if (_underlyings.length <= 0 || _underlyings.length != _oracles.length) revert Errors.InvalidParam();\n\n        for (uint256 i = 0; i < _underlyings.length; i++) {\n            oracles[_underlyings[i]] = _oracles[i];\n        }\n    }\n\n    /// @dev Attempts to return the price in ETH of `underlying` (implements `BasePriceOracle`).\n    function price(address underlying) external view override returns (uint256) {\n        if (underlying == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) return 1e18; // Return 1e18 for WETH\n\n        address oracle = oracles[underlying];\n        if (oracle != address(0)) {\n            return IPriceFeed(oracle).price(underlying);\n        } else {\n            // Try token/ETH from Sense's Chainlink Oracle\n            try IPriceFeed(senseChainlinkPriceOracle).price(underlying) returns (uint256 price) {\n                return price;\n            } catch {\n                revert Errors.PriceOracleNotFound();\n            }\n        }\n    }\n\n    /// @dev Sets the `senseChainlinkPriceOracle`.\n    function setSenseChainlinkPriceOracle(address _senseChainlinkPriceOracle) public requiresTrust {\n        senseChainlinkPriceOracle = _senseChainlinkPriceOracle;\n        emit SenseChainlinkPriceOracleChanged(senseChainlinkPriceOracle);\n    }\n\n    /* ========== LOGS ========== */\n    event SenseChainlinkPriceOracleChanged(address indexed senseChainlinkPriceOracle);\n}\n"},"@sense-finance/v1-core/src/tests/test-helpers/mocks/MockAdapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { BaseAdapter } from \"../../../adapters/abstract/BaseAdapter.sol\";\nimport { Crops } from \"../../../adapters/abstract/extensions/Crops.sol\";\nimport { Crop } from \"../../../adapters/abstract/extensions/Crop.sol\";\nimport { ExtractableReward } from \"../../../adapters/abstract/extensions/ExtractableReward.sol\";\nimport { ERC4626Adapter } from \"../../../adapters/abstract/erc4626/ERC4626Adapter.sol\";\nimport { FixedMath } from \"../../../external/FixedMath.sol\";\nimport { Divider } from \"../../../Divider.sol\";\nimport { YT } from \"../../../tokens/YT.sol\";\nimport { MockTarget } from \"./MockTarget.sol\";\nimport { MockToken } from \"./MockToken.sol\";\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Mock adapter\ncontract MockAdapter is BaseAdapter, ExtractableReward {\n    using FixedMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    uint256 internal scaleOverride;\n    uint256 public INITIAL_VALUE = 1e18;\n    uint256 internal GROWTH_PER_SECOND = 792744799594; // 25% APY\n    uint256 public onRedeemCalls;\n    uint256 public scalingFactor;\n\n    struct LScale {\n        // Timestamp of the last scale value\n        uint256 timestamp;\n        // Last scale value\n        uint256 value;\n    }\n\n    /// @notice Cached scale value from the last call to `scale()`\n    LScale public lscale;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _underlying,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        AdapterParams memory _adapterParams\n    ) BaseAdapter(_divider, _target, _underlying, _ifee, _adapterParams) ExtractableReward(_rewardsRecipient) {\n        uint256 tDecimals = MockTarget(_target).decimals();\n        uint256 uDecimals = MockTarget(_underlying).decimals();\n        scalingFactor = 10**(tDecimals > uDecimals ? tDecimals - uDecimals : uDecimals - tDecimals);\n    }\n\n    function scale() external virtual override returns (uint256 _scale) {\n        if (scaleOverride > 0) {\n            _scale = scaleOverride;\n            lscale.value = scaleOverride;\n            lscale.timestamp = block.timestamp;\n        } else {\n            uint256 gps = GROWTH_PER_SECOND.fmul(99 * (10**(18 - 2)));\n            uint256 timeDiff = block.timestamp - lscale.timestamp;\n            _scale = lscale.value > 0 ? (gps * timeDiff).fmul(lscale.value) + lscale.value : INITIAL_VALUE;\n\n            if (_scale != lscale.value) {\n                // update value only if different than the previous\n                lscale.value = _scale;\n                lscale.timestamp = block.timestamp;\n            }\n        }\n    }\n\n    function scaleStored() external view virtual override returns (uint256) {\n        return lscale.value == 0 ? INITIAL_VALUE : lscale.value;\n    }\n\n    function wrapUnderlying(uint256 uBal) public virtual override returns (uint256) {\n        MockTarget target = MockTarget(target);\n        MockToken underlying = MockToken(target.underlying());\n        underlying.transferFrom(msg.sender, address(this), uBal);\n        uint256 mintAmount = uBal.fdivUp(lscale.value);\n        mintAmount = underlying.decimals() > target.decimals()\n            ? mintAmount / scalingFactor\n            : mintAmount * scalingFactor;\n        target.mint(msg.sender, mintAmount);\n        return mintAmount;\n    }\n\n    function unwrapTarget(uint256 tBal) external virtual override returns (uint256) {\n        MockTarget target = MockTarget(target);\n        MockToken underlying = MockToken(target.underlying());\n        target.transferFrom(msg.sender, address(this), tBal); // pull target\n        uint256 mintAmount = tBal.fmul(lscale.value);\n        mintAmount = underlying.decimals() > target.decimals()\n            ? mintAmount * scalingFactor\n            : mintAmount / scalingFactor;\n        MockToken(target.underlying()).mint(msg.sender, mintAmount);\n        return mintAmount;\n    }\n\n    function getUnderlyingPrice() external view virtual override returns (uint256) {\n        return 1e18;\n    }\n\n    function _isValid(address _token) internal override returns (bool) {\n        return (_token != target && _token != adapterParams.stake);\n    }\n\n    function onRedeem(\n        uint256, /* uBal */\n        uint256, /* mscale */\n        uint256, /* maxscale */\n        uint256 /* tBal */\n    ) public virtual override {\n        onRedeemCalls++;\n    }\n\n    function setScale(uint256 _scaleOverride) external {\n        scaleOverride = _scaleOverride;\n    }\n}\n\n// Mock crop adapter\ncontract MockCropAdapter is BaseAdapter, Crop, ExtractableReward {\n    using FixedMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    uint256 internal scaleOverride;\n    uint256 public INITIAL_VALUE = 1e18;\n    uint256 internal GROWTH_PER_SECOND = 792744799594; // 25% APY\n    uint256 public onRedeemCalls;\n    uint256 public scalingFactor;\n\n    struct LScale {\n        // Timestamp of the last scale value\n        uint256 timestamp;\n        // Last scale value\n        uint256 value;\n    }\n\n    /// @notice Cached scale value from the last call to `scale()`\n    LScale public lscale;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _underlying,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        AdapterParams memory _adapterParams,\n        address _reward\n    )\n        Crop(_divider, _reward)\n        BaseAdapter(_divider, _target, _underlying, _ifee, _adapterParams)\n        ExtractableReward(_rewardsRecipient)\n    {\n        uint256 tDecimals = MockTarget(_target).decimals();\n        uint256 uDecimals = MockTarget(_underlying).decimals();\n        scalingFactor = 10**(tDecimals > uDecimals ? tDecimals - uDecimals : uDecimals - tDecimals);\n    }\n\n    function notify(\n        address _usr,\n        uint256 amt,\n        bool join\n    ) public override(BaseAdapter, Crop) {\n        super.notify(_usr, amt, join);\n    }\n\n    function scale() external virtual override returns (uint256 _scale) {\n        if (scaleOverride > 0) {\n            _scale = scaleOverride;\n            lscale.value = scaleOverride;\n            lscale.timestamp = block.timestamp;\n        } else {\n            uint256 gps = GROWTH_PER_SECOND.fmul(99 * (10**(18 - 2)));\n            uint256 timeDiff = block.timestamp - lscale.timestamp;\n            _scale = lscale.value > 0 ? (gps * timeDiff).fmul(lscale.value) + lscale.value : INITIAL_VALUE;\n\n            if (_scale != lscale.value) {\n                // update value only if different than the previous\n                lscale.value = _scale;\n                lscale.timestamp = block.timestamp;\n            }\n        }\n    }\n\n    function scaleStored() external view virtual override returns (uint256) {\n        return lscale.value == 0 ? INITIAL_VALUE : lscale.value;\n    }\n\n    function _claimReward() internal virtual override {\n        super._claimReward();\n    }\n\n    function wrapUnderlying(uint256 uBal) public virtual override returns (uint256) {\n        MockTarget target = MockTarget(target);\n        MockToken underlying = MockToken(target.underlying());\n        underlying.transferFrom(msg.sender, address(this), uBal);\n        uint256 mintAmount = uBal.fdivUp(lscale.value);\n        mintAmount = underlying.decimals() > target.decimals()\n            ? mintAmount / scalingFactor\n            : mintAmount * scalingFactor;\n        target.mint(msg.sender, mintAmount);\n        return mintAmount;\n    }\n\n    function unwrapTarget(uint256 tBal) external virtual override returns (uint256) {\n        MockTarget target = MockTarget(target);\n        MockToken underlying = MockToken(target.underlying());\n        target.transferFrom(msg.sender, address(this), tBal); // pull target\n        uint256 mintAmount = tBal.fmul(lscale.value);\n        mintAmount = underlying.decimals() > target.decimals()\n            ? mintAmount * scalingFactor\n            : mintAmount / scalingFactor;\n        MockToken(target.underlying()).mint(msg.sender, mintAmount);\n        return mintAmount;\n    }\n\n    function getUnderlyingPrice() external view virtual override returns (uint256) {\n        return 1e18;\n    }\n\n    function _isValid(address _token) internal override returns (bool) {\n        return (_token != target && _token != adapterParams.stake && _token != reward);\n    }\n\n    function onRedeem(\n        uint256, /* uBal */\n        uint256, /* mscale */\n        uint256, /* maxscale */\n        uint256 /* tBal */\n    ) public virtual override {\n        onRedeemCalls++;\n    }\n\n    function setScale(uint256 _scaleOverride) external {\n        scaleOverride = _scaleOverride;\n    }\n}\n\n// Mock crops adapter\ncontract MockCropsAdapter is BaseAdapter, Crops, ExtractableReward {\n    using FixedMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    uint256 internal scaleOverride;\n    uint256 public INITIAL_VALUE = 1e18;\n    uint256 internal GROWTH_PER_SECOND = 792744799594; // 25% APY\n    uint256 public onRedeemCalls;\n    uint256 public scalingFactor;\n\n    struct LScale {\n        // Timestamp of the last scale value\n        uint256 timestamp;\n        // Last scale value\n        uint256 value;\n    }\n\n    /// @notice Cached scale value from the last call to `scale()`\n    LScale public lscale;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _underlying,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        AdapterParams memory _adapterParams,\n        address[] memory _rewardTokens\n    )\n        Crops(_divider, _rewardTokens)\n        BaseAdapter(_divider, _target, _underlying, _ifee, _adapterParams)\n        ExtractableReward(_rewardsRecipient)\n    {\n        uint256 tDecimals = MockTarget(_target).decimals();\n        uint256 uDecimals = MockTarget(_underlying).decimals();\n        scalingFactor = 10**(tDecimals > uDecimals ? tDecimals - uDecimals : uDecimals - tDecimals);\n    }\n\n    function notify(\n        address _usr,\n        uint256 amt,\n        bool join\n    ) public override(BaseAdapter, Crops) {\n        super.notify(_usr, amt, join);\n    }\n\n    function scale() external virtual override returns (uint256 _scale) {\n        if (scaleOverride > 0) {\n            _scale = scaleOverride;\n            lscale.value = scaleOverride;\n            lscale.timestamp = block.timestamp;\n        } else {\n            uint256 gps = GROWTH_PER_SECOND.fmul(99 * (10**(18 - 2)));\n            uint256 timeDiff = block.timestamp - lscale.timestamp;\n            _scale = lscale.value > 0 ? (gps * timeDiff).fmul(lscale.value) + lscale.value : INITIAL_VALUE;\n\n            if (_scale != lscale.value) {\n                // update value only if different than the previous\n                lscale.value = _scale;\n                lscale.timestamp = block.timestamp;\n            }\n        }\n    }\n\n    function scaleStored() external view virtual override returns (uint256) {\n        return lscale.value == 0 ? INITIAL_VALUE : lscale.value;\n    }\n\n    function _claimRewards() internal virtual override {\n        super._claimRewards();\n    }\n\n    function wrapUnderlying(uint256 uBal) public virtual override returns (uint256) {\n        MockTarget target = MockTarget(target);\n        MockToken underlying = MockToken(target.underlying());\n        underlying.transferFrom(msg.sender, address(this), uBal);\n        uint256 mintAmount = uBal.fdivUp(lscale.value);\n        mintAmount = underlying.decimals() > target.decimals()\n            ? mintAmount / scalingFactor\n            : mintAmount * scalingFactor;\n        target.mint(msg.sender, mintAmount);\n        return mintAmount;\n    }\n\n    function unwrapTarget(uint256 tBal) external virtual override returns (uint256) {\n        MockTarget target = MockTarget(target);\n        MockToken underlying = MockToken(target.underlying());\n        target.transferFrom(msg.sender, address(this), tBal); // pull target\n        uint256 mintAmount = tBal.fmul(lscale.value);\n        mintAmount = underlying.decimals() > target.decimals()\n            ? mintAmount * scalingFactor\n            : mintAmount / scalingFactor;\n        MockToken(target.underlying()).mint(msg.sender, mintAmount);\n        return mintAmount;\n    }\n\n    function getUnderlyingPrice() external view virtual override returns (uint256) {\n        return 1e18;\n    }\n\n    function _isValid(address _token) internal override returns (bool) {\n        for (uint256 i = 0; i < rewardTokens.length; ) {\n            if (_token == rewardTokens[i]) return false;\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Check that token is neither the target nor the stake\n        return (_token != target && _token != adapterParams.stake);\n    }\n\n    function onRedeem(\n        uint256, /* uBal */\n        uint256, /* mscale */\n        uint256, /* maxscale */\n        uint256 /* tBal */\n    ) public virtual override {\n        onRedeemCalls++;\n    }\n\n    function setScale(uint256 _scaleOverride) external {\n        scaleOverride = _scaleOverride;\n    }\n}\n\n// Mock ERC4626 crop adapter\ncontract Mock4626Adapter is ERC4626Adapter {\n    using FixedMath for uint256;\n\n    uint256 public onRedeemCalls;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _underlying,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        AdapterParams memory _adapterParams\n    ) ERC4626Adapter(_divider, _target, _rewardsRecipient, _ifee, _adapterParams) {}\n\n    function lscale() external returns (uint256, uint256) {\n        return (0, IERC4626(target).convertToAssets(BASE_UINT));\n    }\n\n    function onRedeem(\n        uint256, /* uBal */\n        uint256, /* mscale */\n        uint256, /* maxscale */\n        uint256 /* tBal */\n    ) public virtual override {\n        onRedeemCalls++;\n    }\n}\n\n// Mock ERC4626 crop adapter\ncontract Mock4626CropAdapter is ERC4626Adapter, Crop {\n    using FixedMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    uint256 public onRedeemCalls;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _underlying,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        AdapterParams memory _adapterParams,\n        address _reward\n    ) ERC4626Adapter(_divider, _target, _rewardsRecipient, _ifee, _adapterParams) Crop(_divider, _reward) {}\n\n    function notify(\n        address _usr,\n        uint256 amt,\n        bool join\n    ) public override(BaseAdapter, Crop) {\n        super.notify(_usr, amt, join);\n    }\n\n    function lscale() external returns (uint256, uint256) {\n        return (0, IERC4626(target).convertToAssets(BASE_UINT));\n    }\n\n    function _isValid(address _token) internal override returns (bool) {\n        return (_token != target && _token != adapterParams.stake && _token != reward);\n    }\n\n    function onRedeem(\n        uint256, /* uBal */\n        uint256, /* mscale */\n        uint256, /* maxscale */\n        uint256 /* tBal */\n    ) public virtual override {\n        onRedeemCalls++;\n    }\n}\n\n// Mock ERC4626 crops adapter\ncontract Mock4626CropsAdapter is ERC4626Adapter, Crops {\n    using FixedMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    uint256 public onRedeemCalls;\n    uint256 public scalingFactor;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _underlying,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        AdapterParams memory _adapterParams,\n        address[] memory _rewardTokens\n    ) ERC4626Adapter(_divider, _target, _rewardsRecipient, _ifee, _adapterParams) Crops(_divider, _rewardTokens) {\n        uint256 tDecimals = MockTarget(_target).decimals();\n        uint256 uDecimals = MockTarget(_underlying).decimals();\n        scalingFactor = 10**(tDecimals > uDecimals ? tDecimals - uDecimals : uDecimals - tDecimals);\n    }\n\n    function notify(\n        address _usr,\n        uint256 amt,\n        bool join\n    ) public override(BaseAdapter, Crops) {\n        super.notify(_usr, amt, join);\n    }\n\n    function _isValid(address _token) internal override returns (bool) {\n        for (uint256 i = 0; i < rewardTokens.length; ) {\n            if (_token == rewardTokens[i]) return false;\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Check that token is neither the target nor the stake\n        return (_token != target && _token != adapterParams.stake);\n    }\n\n    function onRedeem(\n        uint256, /* uBal */\n        uint256, /* mscale */\n        uint256, /* maxscale */\n        uint256 /* tBal */\n    ) public virtual override {\n        onRedeemCalls++;\n    }\n}\n\n// Mock base adapter\ncontract MockBaseAdapter is BaseAdapter, ExtractableReward {\n    using SafeTransferLib for ERC20;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _underlying,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        AdapterParams memory _adapterParams\n    ) BaseAdapter(_divider, _target, _underlying, _ifee, _adapterParams) ExtractableReward(_rewardsRecipient) {}\n\n    function scale() external virtual override returns (uint256 _value) {\n        return 100e18;\n    }\n\n    function scaleStored() external view virtual override returns (uint256) {\n        return 100e18;\n    }\n\n    function wrapUnderlying(uint256 amount) external override returns (uint256) {\n        return 0;\n    }\n\n    function unwrapTarget(uint256 amount) external override returns (uint256) {\n        return 0;\n    }\n\n    function getUnderlyingPrice() external view override returns (uint256) {\n        return 1e18;\n    }\n\n    function _isValid(address _token) internal override returns (bool) {\n        return (_token != target && _token != adapterParams.stake);\n    }\n}\n"},"@sense-finance/v1-core/src/tests/test-helpers/mocks/MockToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\n\n// Internal references\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\n\ncontract MockToken is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal\n    ) ERC20(_name, _symbol, _decimal) {}\n\n    function mint(address account, uint256 amount) external virtual {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) external virtual {\n        _burn(account, amount);\n    }\n}\n\ncontract AuthdMockToken is ERC20, Trust {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal\n    ) ERC20(_name, _symbol, _decimal) Trust(msg.sender) {}\n\n    function mint(address account, uint256 amount) external virtual requiresTrust {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) external virtual requiresTrust {\n        _burn(account, amount);\n    }\n}\n\n// Non-ERC20 token\n\nabstract contract NonERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n\ncontract MockNonERC20Token is NonERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal\n    ) NonERC20(_name, _symbol, _decimal) {}\n\n    function mint(address account, uint256 amount) external virtual {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) external virtual {\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     */\n    function approve(address _spender, uint256 _value) public onlyPayloadSize(2 * 32) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n    }\n\n    /**\n     * @dev Fix for the ERC20 short address attack.\n     */\n    modifier onlyPayloadSize(uint256 size) {\n        require(!(msg.data.length < size + 4));\n        _;\n    }\n}\n"},"@sense-finance/v1-core/src/tests/test-helpers/mocks/MockTarget.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { MockToken, AuthdMockToken, MockNonERC20Token } from \"./MockToken.sol\";\nimport { ERC20 as ZeppelinERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockTarget is MockToken {\n    address public underlying;\n\n    constructor(\n        address _underlying,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal\n    ) MockToken(_name, _symbol, _decimal) {\n        underlying = _underlying;\n    }\n}\n\ncontract AuthdMockTarget is AuthdMockToken {\n    address public underlying;\n\n    constructor(\n        address _underlying,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal\n    ) AuthdMockToken(_name, _symbol, _decimal) {\n        underlying = _underlying;\n    }\n}\n\ncontract MockNonERC20Target is MockNonERC20Token {\n    address public underlying;\n\n    constructor(\n        address _underlying,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal\n    ) MockNonERC20Token(_name, _symbol, _decimal) {\n        underlying = _underlying;\n    }\n}\n"},"@sense-finance/v1-core/src/tests/test-helpers/mocks/MockFactory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Internal references\nimport { BaseFactory } from \"../../../adapters/abstract/factories/BaseFactory.sol\";\nimport { CropFactory } from \"../../../adapters/abstract/factories/CropFactory.sol\";\nimport { ERC4626Factory } from \"../../../adapters/abstract/factories/ERC4626Factory.sol\";\nimport { ExtractableReward } from \"../../../adapters/abstract/extensions/ExtractableReward.sol\";\nimport { Divider } from \"../../../Divider.sol\";\nimport { MockAdapter, MockCropsAdapter, MockCropAdapter, Mock4626Adapter, Mock4626CropAdapter, Mock4626CropsAdapter } from \"./MockAdapter.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { BaseAdapter } from \"../../../adapters/abstract/BaseAdapter.sol\";\n\n// External references\nimport { Bytes32AddressLib } from \"solmate/src/utils/Bytes32AddressLib.sol\";\n\ninterface MockTargetLike {\n    function underlying() external view returns (address);\n\n    function asset() external view returns (address);\n}\n\n// -- Non-4626 factories -- //\n\ncontract MockFactory is BaseFactory {\n    using Bytes32AddressLib for address;\n\n    mapping(address => bool) public targets;\n\n    constructor(\n        address _divider,\n        address _restrictedAdmin,\n        address _rewardsRecipient,\n        BaseFactory.FactoryParams memory _factoryParams\n    ) BaseFactory(_divider, _restrictedAdmin, _rewardsRecipient, _factoryParams) {}\n\n    function supportTarget(address _target, bool status) external {\n        targets[_target] = status;\n    }\n\n    function deployAdapter(address _target, bytes memory data) external virtual override returns (address adapter) {\n        if (!targets[_target]) revert Errors.TargetNotSupported();\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n\n        // Use the CREATE2 opcode to deploy a new Adapter contract.\n        // This will revert if a MockAdapter with the provided target has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        BaseAdapter.AdapterParams memory adapterParams = BaseAdapter.AdapterParams({\n            oracle: factoryParams.oracle,\n            stake: factoryParams.stake,\n            stakeSize: factoryParams.stakeSize,\n            minm: factoryParams.minm,\n            maxm: factoryParams.maxm,\n            mode: factoryParams.mode,\n            tilt: factoryParams.tilt,\n            level: DEFAULT_LEVEL\n        });\n\n        adapter = address(\n            new MockAdapter{ salt: _target.fillLast12Bytes() }(\n                divider,\n                _target,\n                MockTargetLike(_target).underlying(),\n                rewardsRecipient,\n                factoryParams.ifee,\n                adapterParams\n            )\n        );\n\n        // We only want to execute this if divider is guarded\n        if (Divider(divider).guarded()) {\n            Divider(divider).setGuard(adapter, type(uint256).max);\n        }\n\n        ExtractableReward(adapter).setIsTrusted(restrictedAdmin, true);\n    }\n}\n\ncontract MockCropFactory is CropFactory {\n    using Bytes32AddressLib for address;\n\n    mapping(address => bool) public targets;\n\n    constructor(\n        address _divider,\n        address _restrictedAdmin,\n        address _rewardsRecipient,\n        BaseFactory.FactoryParams memory _factoryParams,\n        address _reward\n    ) CropFactory(_divider, _restrictedAdmin, _rewardsRecipient, _factoryParams, _reward) {}\n\n    function supportTarget(address _target, bool status) external {\n        targets[_target] = status;\n    }\n\n    function deployAdapter(address _target, bytes memory data) external virtual override returns (address adapter) {\n        if (!targets[_target]) revert Errors.TargetNotSupported();\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n\n        // Use the CREATE2 opcode to deploy a new Adapter contract.\n        // This will revert if a MockCropsAdapter with the provided target has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        BaseAdapter.AdapterParams memory adapterParams = BaseAdapter.AdapterParams({\n            oracle: factoryParams.oracle,\n            stake: factoryParams.stake,\n            stakeSize: factoryParams.stakeSize,\n            minm: factoryParams.minm,\n            maxm: factoryParams.maxm,\n            mode: factoryParams.mode,\n            tilt: factoryParams.tilt,\n            level: DEFAULT_LEVEL\n        });\n\n        adapter = address(\n            new MockCropAdapter{ salt: _target.fillLast12Bytes() }(\n                divider,\n                _target,\n                MockTargetLike(_target).underlying(),\n                rewardsRecipient,\n                factoryParams.ifee,\n                adapterParams,\n                reward\n            )\n        );\n\n        // We only want to execute this if divider is guarded\n        if (Divider(divider).guarded()) {\n            Divider(divider).setGuard(adapter, type(uint256).max);\n        }\n\n        ExtractableReward(adapter).setIsTrusted(restrictedAdmin, true);\n    }\n}\n\ncontract MockCropsFactory is BaseFactory {\n    using Bytes32AddressLib for address;\n\n    mapping(address => bool) public targets;\n    address[] rewardTokens;\n\n    constructor(\n        address _divider,\n        address _restrictedAdmin,\n        address _rewardsRecipient,\n        BaseFactory.FactoryParams memory _factoryParams,\n        address[] memory _rewardTokens\n    ) BaseFactory(_divider, _restrictedAdmin, _rewardsRecipient, _factoryParams) {\n        rewardTokens = _rewardTokens;\n    }\n\n    function supportTarget(address _target, bool status) external {\n        targets[_target] = status;\n    }\n\n    function deployAdapter(address _target, bytes memory data) external override returns (address adapter) {\n        if (!targets[_target]) revert Errors.TargetNotSupported();\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n\n        // Use the CREATE2 opcode to deploy a new Adapter contract.\n        // This will revert if a MockCropsAdapter with the provided target has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        BaseAdapter.AdapterParams memory adapterParams = BaseAdapter.AdapterParams({\n            oracle: factoryParams.oracle,\n            stake: factoryParams.stake,\n            stakeSize: factoryParams.stakeSize,\n            minm: factoryParams.minm,\n            maxm: factoryParams.maxm,\n            mode: factoryParams.mode,\n            tilt: factoryParams.tilt,\n            level: DEFAULT_LEVEL\n        });\n\n        adapter = address(\n            new MockCropsAdapter{ salt: _target.fillLast12Bytes() }(\n                divider,\n                _target,\n                MockTargetLike(_target).underlying(),\n                rewardsRecipient,\n                factoryParams.ifee,\n                adapterParams,\n                rewardTokens\n            )\n        );\n\n        // We only want to execute this if divider is guarded\n        if (Divider(divider).guarded()) {\n            Divider(divider).setGuard(adapter, type(uint256).max);\n        }\n\n        ExtractableReward(adapter).setIsTrusted(restrictedAdmin, true);\n    }\n}\n\n// -- 4626 factories -- //\n\ncontract Mock4626CropFactory is CropFactory {\n    using Bytes32AddressLib for address;\n\n    mapping(address => bool) public targets;\n\n    constructor(\n        address _divider,\n        address _restrictedAdmin,\n        address _rewardsRecipient,\n        BaseFactory.FactoryParams memory _factoryParams,\n        address _reward\n    ) CropFactory(_divider, _restrictedAdmin, _rewardsRecipient, _factoryParams, _reward) {}\n\n    function supportTarget(address _target, bool status) external {\n        targets[_target] = status;\n    }\n\n    function deployAdapter(address _target, bytes memory data) external virtual override returns (address adapter) {\n        if (!targets[_target]) revert Errors.TargetNotSupported();\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n\n        // Use the CREATE2 opcode to deploy a new Adapter contract.\n        // This will revert if a MockAdapter with the provided target has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        BaseAdapter.AdapterParams memory adapterParams = BaseAdapter.AdapterParams({\n            oracle: factoryParams.oracle,\n            stake: factoryParams.stake,\n            stakeSize: factoryParams.stakeSize,\n            minm: factoryParams.minm,\n            maxm: factoryParams.maxm,\n            mode: factoryParams.mode,\n            tilt: factoryParams.tilt,\n            level: DEFAULT_LEVEL\n        });\n\n        adapter = address(\n            new Mock4626CropAdapter{ salt: _target.fillLast12Bytes() }(\n                divider,\n                _target,\n                MockTargetLike(_target).asset(),\n                rewardsRecipient,\n                factoryParams.ifee,\n                adapterParams,\n                reward\n            )\n        );\n\n        // We only want to execute this if divider is guarded\n        if (Divider(divider).guarded()) {\n            Divider(divider).setGuard(adapter, type(uint256).max);\n        }\n\n        ExtractableReward(adapter).setIsTrusted(restrictedAdmin, true);\n    }\n}\n\ncontract Mock4626CropsFactory is BaseFactory {\n    using Bytes32AddressLib for address;\n\n    mapping(address => bool) public targets;\n    address[] rewardTokens;\n\n    constructor(\n        address _divider,\n        address _restrictedAdmin,\n        address _rewardsRecipient,\n        BaseFactory.FactoryParams memory _factoryParams,\n        address[] memory _rewardTokens\n    ) BaseFactory(_divider, _restrictedAdmin, _rewardsRecipient, _factoryParams) {\n        rewardTokens = _rewardTokens;\n    }\n\n    function supportTarget(address _target, bool status) external {\n        targets[_target] = status;\n    }\n\n    function deployAdapter(address _target, bytes memory data) external override returns (address adapter) {\n        if (!targets[_target]) revert Errors.TargetNotSupported();\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n\n        // Use the CREATE2 opcode to deploy a new Adapter contract.\n        // This will revert if a MockCropsAdapter with the provided target has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        BaseAdapter.AdapterParams memory adapterParams = BaseAdapter.AdapterParams({\n            oracle: factoryParams.oracle,\n            stake: factoryParams.stake,\n            stakeSize: factoryParams.stakeSize,\n            minm: factoryParams.minm,\n            maxm: factoryParams.maxm,\n            mode: factoryParams.mode,\n            tilt: factoryParams.tilt,\n            level: DEFAULT_LEVEL\n        });\n\n        adapter = address(\n            new Mock4626CropsAdapter{ salt: _target.fillLast12Bytes() }(\n                divider,\n                _target,\n                MockTargetLike(_target).asset(),\n                rewardsRecipient,\n                factoryParams.ifee,\n                adapterParams,\n                rewardTokens\n            )\n        );\n\n        // We only want to execute this if divider is guarded\n        if (Divider(divider).guarded()) {\n            Divider(divider).setGuard(adapter, type(uint256).max);\n        }\n\n        ExtractableReward(adapter).setIsTrusted(restrictedAdmin, true);\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/implementations/compound/CAdapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Internal references\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { BaseAdapter } from \"../../abstract/BaseAdapter.sol\";\nimport { Crop } from \"../../abstract/extensions/Crop.sol\";\nimport { ExtractableReward } from \"../../abstract/extensions/ExtractableReward.sol\";\n\ninterface WETHLike {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\ninterface CTokenLike {\n    /// @notice cToken is convertible into an ever increasing quantity of the underlying asset, as interest accrues in\n    /// the market. This function returns the exchange rate between a cToken and the underlying asset.\n    /// @dev returns the current exchange rate as an uint, scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\n    function exchangeRateCurrent() external returns (uint256);\n\n    /// @notice Calculates the exchange rate from the underlying to the CToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateStored() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function underlying() external view returns (address);\n\n    /// The mint function transfers an asset into the protocol, which begins accumulating interest based\n    /// on the current Supply Rate for the asset. The user receives a quantity of cTokens equal to the\n    /// underlying tokens supplied, divided by the current Exchange Rate.\n    /// @param mintAmount The amount of the asset to be supplied, in units of the underlying asset.\n    /// @return 0 on success, otherwise an Error code\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    /// The redeem function converts a specified quantity of cTokens into the underlying asset, and returns\n    /// them to the user. The amount of underlying tokens received is equal to the quantity of cTokens redeemed,\n    /// multiplied by the current Exchange Rate. The amount redeemed must be less than the user's Account Liquidity\n    /// and the market's available liquidity.\n    /// @param redeemTokens The number of cTokens to be redeemed.\n    /// @return 0 on success, otherwise an Error code\n    function redeem(uint256 redeemTokens) external returns (uint256);\n}\n\ninterface CETHTokenLike {\n    ///@notice Send Ether to CEther to mint\n    function mint() external payable;\n}\n\ninterface ComptrollerLike {\n    /// @notice Claim all the comp accrued by holder in the specified markets\n    /// @param holder The address to claim COMP for\n    /// @param cTokens The list of markets to claim COMP in\n    function claimComp(address holder, address[] memory cTokens) external;\n\n    function markets(address target)\n        external\n        returns (\n            bool isListed,\n            uint256 collateralFactorMantissa,\n            bool isComped\n        );\n\n    function oracle() external returns (address);\n}\n\ninterface PriceOracleLike {\n    /// @notice Get the price of an underlying asset.\n    /// @param target The target asset to get the underlying price of.\n    /// @return The underlying asset price in ETH as a mantissa (scaled by 1e18).\n    /// Zero means the price is unavailable.\n    function getUnderlyingPrice(address target) external view returns (uint256);\n\n    function price(address underlying) external view returns (uint256);\n}\n\n/// @notice Adapter contract for cTokens\ncontract CAdapter is BaseAdapter, Crop, ExtractableReward {\n    using SafeTransferLib for ERC20;\n\n    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant CETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n\n    bool public immutable isCETH;\n    uint8 public immutable uDecimals;\n\n    uint256 internal lastRewardedBlock;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _underlying,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        AdapterParams memory _adapterParams,\n        address _reward\n    )\n        Crop(_divider, _reward)\n        BaseAdapter(_divider, _target, _underlying, _ifee, _adapterParams)\n        ExtractableReward(_rewardsRecipient)\n    {\n        isCETH = _target == CETH;\n        ERC20(_underlying).safeApprove(_target, type(uint256).max);\n        uDecimals = CTokenLike(_underlying).decimals();\n    }\n\n    function notify(\n        address _usr,\n        uint256 amt,\n        bool join\n    ) public override(BaseAdapter, Crop) {\n        super.notify(_usr, amt, join);\n    }\n\n    /// @return Exchange rate from Target to Underlying using Compound's `exchangeRateCurrent()`, normed to 18 decimals\n    function scale() external override returns (uint256) {\n        uint256 exRate = CTokenLike(target).exchangeRateCurrent();\n        return _to18Decimals(exRate);\n    }\n\n    function scaleStored() external view override returns (uint256) {\n        uint256 exRate = CTokenLike(target).exchangeRateStored();\n        return _to18Decimals(exRate);\n    }\n\n    function _claimReward() internal virtual override {\n        // Avoid calling _claimReward more than once per block\n        if (lastRewardedBlock != block.number) {\n            lastRewardedBlock = block.number;\n            address[] memory cTokens = new address[](1);\n            cTokens[0] = target;\n            ComptrollerLike(COMPTROLLER).claimComp(address(this), cTokens);\n        }\n    }\n\n    function getUnderlyingPrice() external view override returns (uint256 price) {\n        price = isCETH ? 1e18 : PriceOracleLike(adapterParams.oracle).price(underlying);\n    }\n\n    function wrapUnderlying(uint256 uBal) external override returns (uint256 tBal) {\n        ERC20 t = ERC20(target);\n\n        ERC20(underlying).safeTransferFrom(msg.sender, address(this), uBal); // pull underlying\n        if (isCETH) WETHLike(WETH).withdraw(uBal); // unwrap WETH into ETH\n\n        // Mint target\n        uint256 tBalBefore = t.balanceOf(address(this));\n        if (isCETH) {\n            CETHTokenLike(target).mint{ value: uBal }();\n        } else {\n            if (CTokenLike(target).mint(uBal) != 0) revert Errors.MintFailed();\n        }\n        uint256 tBalAfter = t.balanceOf(address(this));\n\n        // Transfer target to sender\n        t.safeTransfer(msg.sender, tBal = tBalAfter - tBalBefore);\n    }\n\n    function unwrapTarget(uint256 tBal) external override returns (uint256 uBal) {\n        ERC20 u = ERC20(underlying);\n        ERC20(target).safeTransferFrom(msg.sender, address(this), tBal); // pull target\n\n        // Redeem target for underlying\n        uint256 uBalBefore = isCETH ? address(this).balance : u.balanceOf(address(this));\n        if (CTokenLike(target).redeem(tBal) != 0) revert Errors.RedeemFailed();\n        uint256 uBalAfter = isCETH ? address(this).balance : u.balanceOf(address(this));\n        unchecked {\n            uBal = uBalAfter - uBalBefore;\n        }\n\n        if (isCETH) {\n            // Deposit ETH into WETH contract\n            (bool success, ) = WETH.call{ value: uBal }(\"\");\n            if (!success) revert Errors.TransferFailed();\n        }\n\n        // Transfer underlying to sender\n        ERC20(underlying).safeTransfer(msg.sender, uBal);\n    }\n\n    function _isValid(address _token) internal override returns (bool) {\n        return (_token != target && _token != adapterParams.stake && _token != reward);\n    }\n\n    function _to18Decimals(uint256 exRate) internal view returns (uint256) {\n        // From the Compound docs:\n        // \"exchangeRateCurrent() returns the exchange rate, scaled by 1 * 10^(18 - 8 + Underlying Token Decimals)\"\n        //\n        // The equation to norm an asset to 18 decimals is:\n        // `num * 10**(18 - decimals)`\n        //\n        // So, when we try to norm exRate to 18 decimals, we get the following:\n        // `exRate * 10**(18 - exRateDecimals)`\n        // -> `exRate * 10**(18 - (18 - 8 + uDecimals))`\n        // -> `exRate * 10**(8 - uDecimals)`\n        // -> `exRate / 10**(uDecimals - 8)`\n        return uDecimals >= 8 ? exRate / 10**(uDecimals - 8) : exRate * 10**(8 - uDecimals);\n    }\n\n    fallback() external payable {}\n}\n"},"@sense-finance/v1-core/src/adapters/implementations/fuse/FAdapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Internal references\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { Crops } from \"../../abstract/extensions/Crops.sol\";\nimport { ExtractableReward } from \"../../abstract/extensions/ExtractableReward.sol\";\nimport { BaseAdapter } from \"../../abstract/BaseAdapter.sol\";\nimport { CTokenLike } from \"../compound/CAdapter.sol\";\n\ninterface WETHLike {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\ninterface FETHTokenLike {\n    ///@notice Send Ether to CEther to mint\n    function mint() external payable;\n}\n\ninterface FTokenLike {\n    function isCEther() external view returns (bool);\n}\n\ninterface FComptrollerLike {\n    function markets(address target) external returns (bool isListed, uint256 collateralFactorMantissa);\n\n    function oracle() external returns (address);\n\n    function getRewardsDistributors() external view returns (address[] memory);\n}\n\ninterface RewardsDistributorLike {\n    ///\n    /// @notice Claim all the rewards accrued by holder in the specified markets\n    /// @param holder The address to claim rewards for\n    ///\n    function claimRewards(address holder) external;\n\n    function marketState(address marker) external view returns (uint224 index, uint32 lastUpdatedTimestamp);\n\n    function rewardToken() external view returns (address rewardToken);\n}\n\ninterface PriceOracleLike {\n    /// @notice Get the price of an underlying asset.\n    /// @param target The target asset to get the underlying price of.\n    /// @return The underlying asset price in ETH as a mantissa (scaled by 1e18).\n    /// Zero means the price is unavailable.\n    function getUnderlyingPrice(address target) external view returns (uint256);\n\n    function price(address underlying) external view returns (uint256);\n}\n\n/// @notice Adapter contract for fTokens\ncontract FAdapter is BaseAdapter, Crops, ExtractableReward {\n    using SafeTransferLib for ERC20;\n\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant FETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n\n    mapping(address => address) public rewardsDistributorsList; // rewards distributors for reward token\n\n    address public immutable comptroller;\n    bool public immutable isFETH;\n    uint8 public immutable uDecimals;\n\n    uint256 internal lastRewardedBlock;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _underlying,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        address _comptroller,\n        AdapterParams memory _adapterParams,\n        address[] memory _rewardTokens,\n        address[] memory _rewardsDistributorsList\n    )\n        Crops(_divider, _rewardTokens)\n        BaseAdapter(_divider, _target, _underlying, _ifee, _adapterParams)\n        ExtractableReward(_rewardsRecipient)\n    {\n        rewardTokens = _rewardTokens;\n        comptroller = _comptroller;\n        isFETH = FTokenLike(_target).isCEther();\n\n        ERC20(_underlying).safeApprove(_target, type(uint256).max);\n        uDecimals = CTokenLike(_underlying).decimals();\n\n        // Initialize rewardsDistributorsList mapping\n        for (uint256 i = 0; i < _rewardTokens.length; i++) {\n            rewardsDistributorsList[_rewardTokens[i]] = _rewardsDistributorsList[i];\n        }\n    }\n\n    function notify(\n        address _usr,\n        uint256 amt,\n        bool join\n    ) public override(BaseAdapter, Crops) {\n        super.notify(_usr, amt, join);\n    }\n\n    /// @return Exchange rate from Target to Underlying using Compound's `exchangeRateCurrent()`, normed to 18 decimals\n    function scale() external override returns (uint256) {\n        uint256 exRate = CTokenLike(target).exchangeRateCurrent();\n        return _to18Decimals(exRate);\n    }\n\n    function scaleStored() external view override returns (uint256) {\n        uint256 exRate = CTokenLike(target).exchangeRateStored();\n        return _to18Decimals(exRate);\n    }\n\n    function _claimRewards() internal virtual override {\n        // Avoid calling _claimRewards more than once per block\n        if (lastRewardedBlock != block.number) {\n            for (uint256 i = 0; i < rewardTokens.length; i++) {\n                if (rewardTokens[i] != address(0))\n                    RewardsDistributorLike(rewardsDistributorsList[rewardTokens[i]]).claimRewards(address(this));\n            }\n        }\n    }\n\n    function getUnderlyingPrice() external view override returns (uint256 price) {\n        price = isFETH ? 1e18 : PriceOracleLike(adapterParams.oracle).price(underlying);\n    }\n\n    function wrapUnderlying(uint256 uBal) external override returns (uint256 tBal) {\n        ERC20 t = ERC20(target);\n\n        ERC20(underlying).safeTransferFrom(msg.sender, address(this), uBal); // pull underlying\n        if (isFETH) WETHLike(WETH).withdraw(uBal); // unwrap WETH into ETH\n\n        // Mint target\n        uint256 tBalBefore = t.balanceOf(address(this));\n        if (isFETH) {\n            FETHTokenLike(target).mint{ value: uBal }();\n        } else {\n            if (CTokenLike(target).mint(uBal) != 0) revert Errors.MintFailed();\n        }\n        uint256 tBalAfter = t.balanceOf(address(this));\n\n        // Transfer target to sender\n        t.safeTransfer(msg.sender, tBal = tBalAfter - tBalBefore);\n    }\n\n    function unwrapTarget(uint256 tBal) external override returns (uint256 uBal) {\n        ERC20 u = ERC20(underlying);\n        ERC20(target).safeTransferFrom(msg.sender, address(this), tBal); // pull target\n\n        // Redeem target for underlying\n        uint256 uBalBefore = isFETH ? address(this).balance : u.balanceOf(address(this));\n        if (CTokenLike(target).redeem(tBal) != 0) revert Errors.RedeemFailed();\n        uint256 uBalAfter = isFETH ? address(this).balance : u.balanceOf(address(this));\n        unchecked {\n            uBal = uBalAfter - uBalBefore;\n        }\n\n        if (isFETH) {\n            // Deposit ETH into WETH contract\n            (bool success, ) = WETH.call{ value: uBal }(\"\");\n            if (!success) revert Errors.TransferFailed();\n        }\n\n        // Transfer underlying to sender\n        ERC20(underlying).safeTransfer(msg.sender, uBal);\n    }\n\n    function _isValid(address _token) internal override returns (bool) {\n        for (uint256 i = 0; i < rewardTokens.length; ) {\n            if (_token == rewardTokens[i]) return false;\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Check that token is neither the target nor the stake\n        return (_token != target && _token != adapterParams.stake);\n    }\n\n    /* ========== ADMIN ========== */\n\n    /// @notice Overrides both the rewardTokens and the rewardsDistributorsList arrays.\n    /// @param _rewardTokens New reward tokens array\n    /// @param _rewardsDistributorsList New rewards distributors list array\n    function setRewardTokens(address[] memory _rewardTokens, address[] memory _rewardsDistributorsList)\n        public\n        virtual\n        requiresTrust\n    {\n        super.setRewardTokens(_rewardTokens);\n        for (uint256 i = 0; i < _rewardTokens.length; i++) {\n            rewardsDistributorsList[_rewardTokens[i]] = _rewardsDistributorsList[i];\n        }\n        emit RewardsDistributorsChanged(_rewardsDistributorsList);\n    }\n\n    /* ========== INTERNAL UTILS ========== */\n\n    function _to18Decimals(uint256 exRate) internal view returns (uint256) {\n        // From the Compound docs:\n        // \"exchangeRateCurrent() returns the exchange rate, scaled by 1 * 10^(18 - 8 + Underlying Token Decimals)\"\n        //\n        // The equation to norm an asset to 18 decimals is:\n        // `num * 10**(18 - decimals)`\n        //\n        // So, when we try to norm exRate to 18 decimals, we get the following:\n        // `exRate * 10**(18 - exRateDecimals)`\n        // -> `exRate * 10**(18 - (18 - 8 + uDecimals))`\n        // -> `exRate * 10**(8 - uDecimals)`\n        // -> `exRate / 10**(uDecimals - 8)`\n        return uDecimals >= 8 ? exRate / 10**(uDecimals - 8) : exRate * 10**(8 - uDecimals);\n    }\n\n    /* ========== LOGS ========== */\n\n    event RewardsDistributorsChanged(address[] indexed rewardsDistributorsList);\n\n    /* ========== FALLBACK ========== */\n\n    fallback() external payable {}\n}\n"},"@sense-finance/v1-core/src/adapters/implementations/aura/AuraVaultWrapper.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.13;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { ERC4626 } from \"solmate/src/mixins/ERC4626.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\nimport { FixedMath } from \"../../../external/FixedMath.sol\";\nimport { ExtractableReward } from \"../../abstract/extensions/ExtractableReward.sol\";\n// import { IVault } from \"./IVault.sol\";\nimport { BalancerPool } from \"../../../external/balancer/Pool.sol\";\nimport { BalancerVault as IVault, IAsset } from \"../../../external/balancer/Vault.sol\";\nimport { RateProvider } from \"../../../external/balancer/RateProvider.sol\";\nimport \"hardhat/console.sol\";\n\ninterface IBalancerStablePreview {\n    // ComposableStablePreview ImmutableData\n    struct ImmutableData {\n        address[] poolTokens;\n        address[] rateProviders;\n        uint256[] rawScalingFactors;\n        bool[] isExemptFromYieldProtocolFee;\n        address LP;\n        bool noTokensExempt;\n        bool allTokensExempt;\n        uint256 bptIndex;\n        uint256 totalTokens;\n    }\n\n    function joinPoolPreview(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        IVault.JoinPoolRequest memory request,\n        bytes memory data\n    ) external view returns (uint256 amountBptOut);\n\n    function exitPoolPreview(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        IVault.ExitPoolRequest memory request,\n        bytes memory data\n    ) external view returns (uint256 amountTokenOut);\n}\n\ninterface IBooster {\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool);\n}\n\ninterface IBaseRewardPool4626 {\n    function pid() external view returns (uint256);\n}\n\n/// @title Aura Vault Wrapper\n/// @notice Wraps an Aura vault to make it transferable. Its asset token (underlying) is the base token\n/// of the Balancer pool.\n/// @dev This contracts inherits ERC4626 but it does not implement all of it's function\ncontract AuraVaultWrapper is ERC4626, ExtractableReward {\n    using FixedMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    error BoosterDepositFailed();\n    error NotImplemented();\n\n    /* ========== IMMUTABLE PARAMS ========== */\n\n    /// @notice The Aura vault contract\n    ERC4626 public immutable aToken;\n    uint256 public immutable auraPID;\n\n    /// @notice pool data\n    BalancerPool public immutable pool;\n    bytes32 internal immutable poolId;\n    address[] public rateProviders;\n    uint256[] internal scalingFactors;\n    bool[] internal exemptions = [false, false, false, false];\n    IAsset[] internal poolAssets;\n    IBalancerStablePreview public immutable previewHelper;\n\n    /* ========== CONSTANTS ========== */\n\n    IVault public constant balancerVault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n    IBooster public constant auraBooster = IBooster(0xA57b8d98dAE62B26Ec3bcC4a365338157060B234); // Aura Booster\n    uint256 public constant BPT_INDEX = 0;\n    bool public constant NO_TOKENS_EXEMPT = true;\n    bool public constant ALL_TOKENS_EXEMPT = false;\n\n    constructor(\n        ERC20 asset_,\n        ERC4626 aToken_,\n        IBalancerStablePreview previewHelper_\n    ) ERC4626(asset_, _vaultName(aToken_), _vaultSymbol(aToken_)) ExtractableReward(msg.sender) {\n        previewHelper = previewHelper_;\n        aToken = aToken_;\n        auraPID = IBaseRewardPool4626(address(aToken)).pid();\n\n        // set pool data\n        pool = BalancerPool(address(aToken.asset()));\n        poolId = pool.getPoolId();\n        (ERC20[] memory tokens, , ) = balancerVault.getPoolTokens(poolId);\n\n        for (uint8 i; i < tokens.length; i++) {\n            scalingFactors.push(10**tokens[i].decimals());\n            tokens[i].safeApprove(address(balancerVault), type(uint256).max);\n            poolAssets.push(IAsset(address(tokens[i])));\n        }\n        rateProviders = _convertRateProvidersToAddresses(pool.getRateProviders());\n\n        // approve Aura Booster to pull LP\n        ERC20(address(pool)).safeApprove(address(auraBooster), type(uint256).max);\n    }\n\n    /* ========== ERC4626 overrides ========== */\n\n    function totalAssets() public view virtual override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    function convertToShares(uint256 assets) public view override returns (uint256) {\n        IVault.JoinPoolRequest memory request = _assembleJoinRequest(assets);\n        return previewHelper.joinPoolPreview(poolId, address(this), address(this), request, _getImmutablePoolData());\n    }\n\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        IVault.ExitPoolRequest memory request = _assembleExitRequest(shares);\n        assets = previewHelper.exitPoolPreview(poolId, address(this), address(this), request, _getImmutablePoolData());\n    }\n\n    function beforeWithdraw(uint256, uint256 shares) internal virtual override {\n        aToken.withdraw(shares, address(this), address(this));\n        _redeemFromBalancer(shares);\n    }\n\n    function afterDeposit(\n        uint256 assets,\n        uint256 /*shares*/\n    ) internal virtual override {\n        // lock BPT into Aura Vault\n        if (!auraBooster.deposit(auraPID, _depositToBalancer(assets), true)) revert BoosterDepositFailed();\n    }\n\n    function previewMint(uint256) public view virtual override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function previewWithdraw(uint256) public view virtual override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    /* ========== Convenience Methods ========== */\n\n    function depositFromBPT(uint256 bptIn, address receiver) external {\n        ERC20(address(pool)).safeTransferFrom(msg.sender, address(this), bptIn);\n        _mint(receiver, bptIn);\n        if (!auraBooster.deposit(auraPID, bptIn, true)) revert BoosterDepositFailed(); // lock BPT into Aura Vault\n        emit DepositFromBPT(msg.sender, receiver, bptIn);\n    }\n\n    function withdrawToBPT(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n        _burn(owner, shares);\n        emit WithdrawToBPT(msg.sender, receiver, owner, shares);\n        aToken.withdraw(shares, address(this), address(this));\n        ERC20(address(pool)).safeTransfer(receiver, shares);\n    }\n\n    /* ========== ExtractableReward overrides ========== */\n\n    function _isValid(address _token) internal virtual override returns (bool) {\n        return true;\n    }\n\n    /* ========== ERC20 metadata generation ========== */\n\n    function _vaultName(ERC20 asset_) internal view virtual returns (string memory vaultName) {\n        vaultName = string.concat(\"Wrapped \", asset_.symbol());\n    }\n\n    function _vaultSymbol(ERC20 asset_) internal view virtual returns (string memory vaultSymbol) {\n        vaultSymbol = string.concat(\"w-\", asset_.symbol());\n    }\n\n    /* ========== Helpers ========== */\n\n    function _depositToBalancer(uint256 amt) internal virtual returns (uint256 bptOut) {\n        IVault.JoinPoolRequest memory request = _assembleJoinRequest(amt);\n        balancerVault.joinPool(poolId, address(this), address(this), request);\n        bptOut = ERC20(address(pool)).balanceOf(address(this));\n    }\n\n    function _assembleJoinRequest(uint256 amt) internal view virtual returns (IVault.JoinPoolRequest memory request) {\n        // max amounts in\n        uint256 amountsLength = _getBPTIndex() < type(uint256).max ? poolAssets.length - 1 : poolAssets.length;\n\n        uint256[] memory amountsIn = new uint256[](amountsLength);\n        uint256[] memory maxAmountsIn = new uint256[](poolAssets.length);\n        uint256 index = find(poolAssets, address(asset)); // find index of underlying\n        uint256 indexSkipBPT = index > _getBPTIndex() ? index - 1 : index;\n        maxAmountsIn[index] = amountsIn[indexSkipBPT] = amt;\n\n        // encode user data\n        uint256 minBptOut = 0;\n        bytes memory userData = abi.encode(IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, amountsIn, minBptOut);\n\n        request = IVault.JoinPoolRequest({\n            assets: poolAssets,\n            maxAmountsIn: maxAmountsIn,\n            userData: userData,\n            fromInternalBalance: false\n        });\n    }\n\n    function _redeemFromBalancer(uint256 lpAmt) internal virtual returns (uint256) {\n        uint256 balanceBefore = asset.balanceOf(address(this));\n\n        IVault.ExitPoolRequest memory request = _assembleExitRequest(lpAmt);\n        balancerVault.exitPool(poolId, address(this), payable(address(this)), request);\n\n        // calculate amount of tokens out\n        uint256 balanceAfter = asset.balanceOf(address(this));\n        return balanceAfter - balanceBefore;\n    }\n\n    function _assembleExitRequest(uint256 lpAmt) internal view virtual returns (IVault.ExitPoolRequest memory request) {\n        uint256[] memory minAmountsOut = new uint256[](poolAssets.length);\n\n        // encode user data\n        uint256 exitTokenIndex = find(poolAssets, address(asset));\n\n        // must drop BPT index as well\n        exitTokenIndex = _getBPTIndex() < exitTokenIndex ? exitTokenIndex - 1 : exitTokenIndex;\n        bytes memory userData = abi.encode(IVault.ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, lpAmt, exitTokenIndex);\n\n        request = IVault.ExitPoolRequest(poolAssets, minAmountsOut, userData, false);\n    }\n\n    /// @dev should be overriden if and only if BPT is one of the pool tokens\n    function _getBPTIndex() internal view virtual returns (uint256) {\n        return BPT_INDEX;\n    }\n\n    /// @notice return index of the element if found, else return uint256.max\n    function find(IAsset[] memory array, address element) internal pure returns (uint256 index) {\n        uint256 length = array.length;\n        for (uint256 i = 0; i < length; ) {\n            if (address(array[i]) == element) return i;\n            unchecked {\n                i++;\n            }\n        }\n        return type(uint256).max;\n    }\n\n    function _getImmutablePoolData() internal view virtual returns (bytes memory) {\n        IBalancerStablePreview.ImmutableData memory res;\n        res.poolTokens = _convertIAssetsToAddresses(poolAssets);\n        res.rateProviders = rateProviders;\n        res.rawScalingFactors = scalingFactors;\n        res.isExemptFromYieldProtocolFee = exemptions;\n        res.LP = address(pool);\n        res.noTokensExempt = NO_TOKENS_EXEMPT;\n        res.allTokensExempt = ALL_TOKENS_EXEMPT;\n        res.bptIndex = BPT_INDEX;\n        res.totalTokens = res.poolTokens.length;\n\n        return abi.encode(res);\n    }\n\n    function _convertIAssetsToAddresses(IAsset[] memory assets) internal pure returns (address[] memory addresses) {\n        assembly {\n            addresses := assets\n        }\n    }\n\n    function _convertRateProvidersToAddresses(RateProvider[] memory providers)\n        internal\n        pure\n        returns (address[] memory addresses)\n    {\n        assembly {\n            addresses := providers\n        }\n    }\n\n    function _convertERC20sToAssets(ERC20[] memory tokens) internal pure returns (IAsset[] memory assets) {\n        assembly {\n            assets := tokens\n        }\n    }\n\n    /* ========== Events ========== */\n\n    event DepositFromBPT(address indexed sender, address indexed receiver, uint256 indexed amount);\n    event WithdrawToBPT(address indexed sender, address indexed receiver, address owner, uint256 indexed amount);\n}\n"},"@sense-finance/v1-core/src/adapters/implementations/aura/OwnableAuraAdapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Internal references\nimport { AuraAdapter } from \"./AuraAdapter.sol\";\nimport { BaseAdapter } from \"../../abstract/BaseAdapter.sol\";\n\ninterface Opener {\n    function onSponsorWindowOpened(address, uint256) external;\n}\n\n/// @notice Adapter contract for Aura Vaults (aToken)\ncontract OwnableAuraAdapter is AuraAdapter {\n    uint256 internal open = 1;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        BaseAdapter.AdapterParams memory _adapterParams,\n        address[] memory _rewardTokens\n    ) AuraAdapter(_divider, _target, _rewardsRecipient, _ifee, _adapterParams, _rewardTokens) {}\n\n    function openSponsorWindow() external requiresTrust {\n        open = 2;\n        Opener(msg.sender).onSponsorWindowOpened(adapterParams.stake, adapterParams.stakeSize);\n        open = 1;\n    }\n\n    // @notice If the Sponsor Window is open (which can only be done by the owner of this contract),\n    // return the maturity bounds. Otherwise, return 0 making the sponsoring to revert.\n    function getMaturityBounds() external view override returns (uint256, uint256) {\n        return open == 2 ? (adapterParams.minm, adapterParams.maxm) : (0, 0);\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/implementations/aura/AuraAdapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\nimport { RateProvider } from \"../../../external/balancer/RateProvider.sol\";\n\n// Internal references\nimport { AuraVaultWrapper } from \"./AuraVaultWrapper.sol\";\nimport { BaseAdapter } from \"../../abstract/BaseAdapter.sol\";\nimport { Crops } from \"../../abstract/extensions/Crops.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { ExtractableReward } from \"../../abstract/extensions/ExtractableReward.sol\";\nimport { FixedMath } from \"../../../external/FixedMath.sol\";\nimport \"hardhat/console.sol\";\n\ninterface PriceOracleLike {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\ninterface IRewards {\n    function getReward() external returns (bool);\n\n    function getReward(address _account, bool _claimExtras) external returns (bool);\n\n    function extraRewardsLength() external view returns (uint256);\n\n    function extraRewards(uint256 _idx) external returns (address);\n}\n\n/// @notice Adapter contract for Aura Vaults (aToken)\ncontract AuraAdapter is BaseAdapter, Crops, ExtractableReward {\n    using FixedMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    /// @notice Cached scale value from the last call to `scale()`\n    uint256 public override scaleStored;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        BaseAdapter.AdapterParams memory _adapterParams,\n        address[] memory _rewardTokens\n    )\n        BaseAdapter(_divider, _target, address(AuraVaultWrapper(_target).asset()), _ifee, _adapterParams)\n        Crops(_divider, _rewardTokens)\n        ExtractableReward(_rewardsRecipient)\n    {\n        // approve target (wrapper) to pull WETH (used on wrapUnderlying())\n        ERC20(underlying).approve(target, type(uint256).max);\n        // set an inital cached scale value\n        scaleStored = _getRate();\n    }\n\n    /// @return exRate Eth per wstEtH (natively in 18 decimals)\n    function scale() external virtual override returns (uint256 exRate) {\n        exRate = _getRate();\n\n        // update value only if different than the previous\n        if (exRate != scaleStored) scaleStored = exRate;\n    }\n\n    function getUnderlyingPrice() external view override returns (uint256 rethPrice) {\n        rethPrice = RateProvider(AuraVaultWrapper(target).rateProviders(3)).getRate(); // RETH is the 4th rate provider\n    }\n\n    function unwrapTarget(uint256 amount) external override returns (uint256 assets) {\n        ERC20(target).safeTransferFrom(msg.sender, address(this), amount); // pull w-auraB-rETH-STABLE-vault\n        assets = AuraVaultWrapper(target).redeem(amount, msg.sender, address(this));\n    }\n\n    function wrapUnderlying(uint256 amount) external override returns (uint256 aToken) {\n        ERC20(underlying).safeTransferFrom(msg.sender, address(this), amount); // pull WETH\n        aToken = AuraVaultWrapper(target).deposit(amount, msg.sender);\n    }\n\n    function _isValid(address _token) internal override returns (bool) {\n        return (_token != target && _token != adapterParams.stake);\n    }\n\n    /* ========== Crops overrides ========== */\n\n    function notify(\n        address _usr,\n        uint256 amt,\n        bool join\n    ) public override(BaseAdapter, Crops) {\n        super.notify(_usr, amt, join);\n    }\n\n    function _claimRewards() internal override {\n        address aToken = address(AuraVaultWrapper(target).aToken());\n        uint256 extraRewardsLen = IRewards(aToken).extraRewardsLength();\n        if (extraRewardsLen == 0) {\n            IRewards(aToken).getReward(address(target), false);\n        } else {\n            // get also rewards from linked rewards\n            IRewards(aToken).getReward(address(target), true);\n\n            // extract extra rewards from target\n            for (uint256 i = 0; i < extraRewardsLen; i++) {\n                ExtractableReward(target).extractToken(IRewards(aToken).extraRewards(i));\n            }\n        }\n\n        // extract rewardTokens (BAL & AURA) from wrapper\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            ExtractableReward(target).extractToken(rewardTokens[i]);\n        }\n    }\n\n    /* ========== Utils ========== */\n\n    function _getRate() internal returns (uint256) {\n        return RateProvider(address(AuraVaultWrapper(target).pool())).getRate();\n    }\n}\n"},"@sense-finance/v1-core/src/tests/test-helpers/mocks/MockERC4626.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { ERC4626 } from \"../../../adapters/abstract/erc4626/ERC4626.sol\";\n\ncontract MockERC4626 is ERC4626 {\n    uint256 public beforeWithdrawHookCalledCounter = 0;\n    uint256 public afterDepositHookCalledCounter = 0;\n\n    constructor(\n        ERC20 _underlying,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC4626(_underlying, _name, _symbol, _decimals) {}\n\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    function beforeWithdraw(uint256, uint256) internal override {\n        beforeWithdrawHookCalledCounter++;\n    }\n\n    function afterDeposit(uint256, uint256) internal override {\n        afterDepositHookCalledCounter++;\n    }\n}\n"},"@sense-finance/v1-core/src/tests/test-helpers/mocks/fuse/MockOracle.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { PriceOracle } from \"@sense-finance/v1-fuse/src/external/PriceOracle.sol\";\nimport { CToken } from \"@sense-finance/v1-fuse/src/external/CToken.sol\";\n\ncontract MockOracle is PriceOracle {\n    uint256 public _price = 1e18;\n\n    function getUnderlyingPrice(CToken) external view override returns (uint256) {\n        return _price;\n    }\n\n    function price(address) external view override returns (uint256) {\n        return _price;\n    }\n\n    function setPrice(uint256 price_) external {\n        _price = price_;\n    }\n\n    function initialize(\n        address[] memory,\n        PriceOracle[] memory,\n        PriceOracle,\n        address,\n        bool\n    ) external {\n        return;\n    }\n\n    function add(address[] calldata underlyings, PriceOracle[] calldata _oracles) external {\n        return;\n    }\n\n    function setZero(address zero, address pool) external {\n        return;\n    }\n}\n"},"@sense-finance/v1-core/src/tests/test-helpers/mocks/fuse/MockComptroller.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\n\ncontract MockComptroller {\n    mapping(address => address) public ctokens;\n    mapping(address => address) public underlyings;\n    uint256 public nonce;\n\n    struct Market {\n        bool isListed;\n        uint256 collateralFactorMantissa;\n    }\n\n    function _deployMarket(\n        bool isCEther,\n        bytes calldata constructorData,\n        uint256 collateralFactorMantissa\n    ) external virtual returns (uint256) {\n        (address token, , , , , , , , ) = abi.decode(\n            constructorData,\n            (address, address, address, string, string, address, bytes, uint256, uint256)\n        );\n        require(ctokens[token] == address(0));\n        ctokens[token] = address(uint160(uint256(keccak256(abi.encodePacked(++nonce, blockhash(block.number))))));\n        underlyings[ctokens[token]] = token;\n        return 0;\n    }\n\n    function _acceptAdmin() external virtual returns (uint256) {\n        return 0;\n    }\n\n    function cTokensByUnderlying(address token) external virtual returns (address) {\n        if (ctokens[token] != address(0)) {\n            return ctokens[token];\n        }\n        return address(0);\n    }\n\n    function markets(address token) external virtual returns (Market memory) {\n        return Market({ isListed: underlyings[token] != address(0), collateralFactorMantissa: 0 });\n    }\n}\n\ncontract MockComptrollerRejectAdmin is MockComptroller {\n    function _acceptAdmin() external override returns (uint256) {\n        return 1;\n    }\n}\n\ncontract MockComptrollerFailAddMarket is MockComptroller {\n    function _deployMarket(\n        bool isCEther,\n        bytes calldata constructorData,\n        uint256 collateralFactorMantissa\n    ) external override returns (uint256) {\n        return 1;\n    }\n}\n"},"@sense-finance/v1-core/src/tests/test-helpers/mocks/fuse/MockFuseDirectory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\n\ncontract MockFuseDirectory {\n    address public comptroller;\n\n    constructor(address _comptroller) {\n        comptroller = _comptroller;\n    }\n\n    function deployPool(\n        string memory name,\n        address implementation,\n        bool enforceWhitelist,\n        uint256 closeFactor,\n        uint256 liquidationIncentive,\n        address priceOracle\n    ) external returns (uint256, address) {\n        return (0, comptroller);\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/erc4626/yield-daddy/euler/EulerERC4626WrapperFactory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { ERC4626 } from \"solmate/src/mixins/ERC4626.sol\";\nimport { IEulerMarkets } from \"../../../../../../lib/yield-daddy/src/euler/external/IEulerMarkets.sol\";\nimport { IEulerEToken } from \"../../../../../../lib/yield-daddy/src/euler/external/IEulerEToken.sol\";\nimport { EulerERC4626Factory } from \"../../../../../../lib/yield-daddy/src/euler/EulerERC4626Factory.sol\";\nimport { ERC4626Factory } from \"../../../../../../lib/yield-daddy/src/base/ERC4626Factory.sol\";\n\nimport { EulerERC4626 } from \"./EulerERC4626.sol\";\nimport { ERC4626WrapperFactory } from \"../base/ERC4626WrapperFactory.sol\";\n\n/// @title EulerERC4626WrapperFactory\n/// @author Yield Daddy (Timeless Finance)\n/// @notice This is NOT an adapter factory, it is a wrapper factory which allows one to\n/// create ERC4626 wrappers for eTokens (Euler tokens)\ncontract EulerERC4626WrapperFactory is EulerERC4626Factory, ERC4626WrapperFactory {\n    constructor(\n        address _euler,\n        IEulerMarkets _markets,\n        address _restrictedAdmin,\n        address _rewardsRecipient\n    ) EulerERC4626Factory(_euler, _markets) ERC4626WrapperFactory(_restrictedAdmin, _rewardsRecipient) {}\n\n    /// -----------------------------------------------------------------------\n    /// External functions\n    /// -----------------------------------------------------------------------\n\n    function createERC4626(ERC20 asset)\n        external\n        virtual\n        override(EulerERC4626Factory, ERC4626Factory)\n        returns (ERC4626 vault)\n    {\n        address eTokenAddress = markets.underlyingToEToken(address(asset));\n        if (eTokenAddress == address(0)) {\n            revert EulerERC4626Factory__ETokenNonexistent();\n        }\n\n        vault = new EulerERC4626{ salt: bytes32(0) }(asset, euler, IEulerEToken(eTokenAddress), rewardsRecipient);\n        EulerERC4626(address(vault)).setIsTrusted(restrictedAdmin, true);\n\n        emit CreateERC4626(asset, vault);\n    }\n\n    function computeERC4626Address(ERC20 asset)\n        external\n        view\n        virtual\n        override(EulerERC4626Factory, ERC4626Factory)\n        returns (ERC4626 vault)\n    {\n        vault = ERC4626(\n            _computeCreate2Address(\n                keccak256(\n                    abi.encodePacked(\n                        // Deployment bytecode:\n                        type(EulerERC4626).creationCode,\n                        // Constructor arguments:\n                        abi.encode(\n                            asset,\n                            euler,\n                            IEulerEToken(markets.underlyingToEToken(address(asset))),\n                            rewardsRecipient\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n"},"lib/auto-roller/src/BaseSplitCodeFactory.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.15;\n\n/**\n * @dev Base factory for contracts whose creation code is so large that the factory cannot hold it. This happens when\n * the contract's creation code grows close to 24kB.\n * @author Balancer Labs\n * https://github.com/balancer-labs/balancer-v2-monorepo/blob/master/pkg/solidity-utils/contracts/helpers/BaseSplitCodeFactory.sol\n *\n * Note that this factory cannot help with contracts that have a *runtime* (deployed) bytecode larger than 24kB.\n */\nabstract contract BaseSplitCodeFactory {\n    // The contract's creation code is stored as code in two separate addresses, and retrieved via `extcodecopy`. This\n    // means this factory supports contracts with creation code of up to 48kB.\n    // We rely on inline-assembly to achieve this, both to make the entire operation highly gas efficient, and because\n    // `extcodecopy` is not available in Solidity.\n\n    address private immutable _creationCodeContractA;\n    uint256 private immutable _creationCodeSizeA;\n\n    address private immutable _creationCodeContractB;\n    uint256 private immutable _creationCodeSizeB;\n\n    /**\n     * @dev The creation code of a contract Foo can be obtained inside Solidity with `type(Foo).creationCode`.\n     */\n    constructor(bytes memory creationCode) {\n        uint256 creationCodeSize = creationCode.length;\n\n        // We are going to deploy two contracts: one with approximately the first half of `creationCode`'s contents\n        // (A), and another with the remaining half (B).\n        // We store the lengths in both immutable and stack variables, since immutable variables cannot be read during\n        // construction.\n        uint256 creationCodeSizeA = creationCodeSize / 2;\n        _creationCodeSizeA = creationCodeSizeA;\n\n        uint256 creationCodeSizeB = creationCodeSize - creationCodeSizeA;\n        _creationCodeSizeB = creationCodeSizeB;\n\n        // To deploy the contracts, we're going to use `CodeDeployer.deploy()`, which expects a memory array with\n        // the code to deploy. Note that we cannot simply create arrays for A and B's code by copying or moving\n        // `creationCode`'s contents as they are expected to be very large (> 24kB), so we must operate in-place.\n\n        // Memory: [ code length ] [ A.data ] [ B.data ]\n\n        // Creating A's array is simple: we simply replace `creationCode`'s length with A's length. We'll later restore\n        // the original length.\n\n        bytes memory creationCodeA;\n        assembly {\n            creationCodeA := creationCode\n            mstore(creationCodeA, creationCodeSizeA)\n        }\n\n        // Memory: [ A.length ] [ A.data ] [ B.data ]\n        //         ^ creationCodeA\n\n        _creationCodeContractA = CodeDeployer.deploy(creationCodeA);\n\n        // Creating B's array is a bit more involved: since we cannot move B's contents, we are going to create a 'new'\n        // memory array starting at A's last 32 bytes, which will be replaced with B's length. We'll back-up this last\n        // byte to later restore it.\n\n        bytes memory creationCodeB;\n        bytes32 lastByteA;\n\n        assembly {\n            // `creationCode` points to the array's length, not data, so by adding A's length to it we arrive at A's\n            // last 32 bytes.\n            creationCodeB := add(creationCode, creationCodeSizeA)\n            lastByteA := mload(creationCodeB)\n            mstore(creationCodeB, creationCodeSizeB)\n        }\n\n        // Memory: [ A.length ] [ A.data[ : -1] ] [ B.length ][ B.data ]\n        //         ^ creationCodeA                ^ creationCodeB\n\n        _creationCodeContractB = CodeDeployer.deploy(creationCodeB);\n\n        // We now restore the original contents of `creationCode` by writing back the original length and A's last byte.\n        assembly {\n            mstore(creationCodeA, creationCodeSize)\n            mstore(creationCodeB, lastByteA)\n        }\n    }\n\n    /**\n     * @dev Returns the two addresses where the creation code of the contract created by this factory is stored.\n     */\n    function getCreationCodeContracts() public view returns (address contractA, address contractB) {\n        return (_creationCodeContractA, _creationCodeContractB);\n    }\n\n    /**\n     * @dev Returns the creation code of the contract this factory creates.\n     */\n    function getCreationCode() public view returns (bytes memory) {\n        return _getCreationCodeWithArgs(\"\");\n    }\n\n    /**\n     * @dev Returns the creation code that will result in a contract being deployed with `constructorArgs`.\n     */\n    function _getCreationCodeWithArgs(bytes memory constructorArgs) private view returns (bytes memory code) {\n        // This function exists because `abi.encode()` cannot be instructed to place its result at a specific address.\n        // We need for the ABI-encoded constructor arguments to be located immediately after the creation code, but\n        // cannot rely on `abi.encodePacked()` to perform concatenation as that would involve copying the creation code,\n        // which would be prohibitively expensive.\n        // Instead, we compute the creation code in a pre-allocated array that is large enough to hold *both* the\n        // creation code and the constructor arguments, and then copy the ABI-encoded arguments (which should not be\n        // overly long) right after the end of the creation code.\n\n        // Immutable variables cannot be used in assembly, so we store them in the stack first.\n        address creationCodeContractA = _creationCodeContractA;\n        uint256 creationCodeSizeA = _creationCodeSizeA;\n        address creationCodeContractB = _creationCodeContractB;\n        uint256 creationCodeSizeB = _creationCodeSizeB;\n\n        uint256 creationCodeSize = creationCodeSizeA + creationCodeSizeB;\n        uint256 constructorArgsSize = constructorArgs.length;\n\n        uint256 codeSize = creationCodeSize + constructorArgsSize;\n\n        assembly {\n            // First, we allocate memory for `code` by retrieving the free memory pointer and then moving it ahead of\n            // `code` by the size of the creation code plus constructor arguments, and 32 bytes for the array length.\n            code := mload(0x40)\n            mstore(0x40, add(code, add(codeSize, 32)))\n\n            // We now store the length of the code plus constructor arguments.\n            mstore(code, codeSize)\n\n            // Next, we concatenate the creation code stored in A and B.\n            let dataStart := add(code, 32)\n            extcodecopy(creationCodeContractA, dataStart, 0, creationCodeSizeA)\n            extcodecopy(creationCodeContractB, add(dataStart, creationCodeSizeA), 0, creationCodeSizeB)\n        }\n\n        // Finally, we copy the constructorArgs to the end of the array. Unfortunately there is no way to avoid this\n        // copy, as it is not possible to tell Solidity where to store the result of `abi.encode()`.\n        uint256 constructorArgsDataPtr;\n        uint256 constructorArgsCodeDataPtr;\n        assembly {\n            constructorArgsDataPtr := add(constructorArgs, 32)\n            constructorArgsCodeDataPtr := add(add(code, 32), creationCodeSize)\n        }\n\n        _memcpy(constructorArgsCodeDataPtr, constructorArgsDataPtr, constructorArgsSize);\n    }\n\n    /**\n     * @dev Deploys a contract with constructor arguments. To create `constructorArgs`, call `abi.encode()` with the\n     * contract's constructor arguments, in order.\n     */\n    function _create(bytes memory constructorArgs, bytes32 salt) internal virtual returns (address) {\n        bytes memory creationCode = _getCreationCodeWithArgs(constructorArgs);\n\n        address destination;\n        // can salt be bytes(0)?\n        assembly {\n            destination := create2(0, add(creationCode, 32), mload(creationCode), salt)\n        }\n\n        if (destination == address(0)) {\n            // Bubble up inner revert reason\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        return destination;\n    }\n\n    // From\n    // https://github.com/Arachnid/solidity-stringutils/blob/b9a6f6615cf18a87a823cbc461ce9e140a61c305/src/strings.sol\n    function _memcpy(\n        uint256 dest,\n        uint256 src,\n        uint256 len\n    ) private pure {\n        unchecked {\n            // Copy word-length chunks while possible\n            for (; len >= 32; len -= 32) {\n                assembly {\n                    mstore(dest, mload(src))\n                }\n                dest += 32;\n                src += 32;\n            }\n\n            // Copy remaining bytes\n            uint256 mask = 256**(32 - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n\n/**\n * @dev Library used to deploy contracts with specific code. This can be used for long-term storage of immutable data as\n * contract code, which can be retrieved via the `extcodecopy` opcode.\n * @author Balancer Labs\n */\nlibrary CodeDeployer {\n    // During contract construction, the full code supplied exists as code, and can be accessed via `codesize` and\n    // `codecopy`. This is not the contract's final code however: whatever the constructor returns is what will be\n    // stored as its code.\n    //\n    // We use this mechanism to have a simple constructor that stores whatever is appended to it. The following opcode\n    // sequence corresponds to the creation code of the following equivalent Solidity contract, plus padding to make the\n    // full code 32 bytes long:\n    //\n    // contract CodeDeployer {\n    //     constructor() payable {\n    //         uint256 size;\n    //         assembly {\n    //             size := sub(codesize(), 32) // size of appended data, as constructor is 32 bytes long\n    //             codecopy(0, 32, size) // copy all appended data to memory at position 0\n    //             return(0, size) // return appended data for it to be stored as code\n    //         }\n    //     }\n    // }\n    //\n    // More specifically, it is composed of the following opcodes (plus padding):\n    //\n    // [1] PUSH1 0x20\n    // [2] CODESIZE\n    // [3] SUB\n    // [4] DUP1\n    // [6] PUSH1 0x20\n    // [8] PUSH1 0x00\n    // [9] CODECOPY\n    // [11] PUSH1 0x00\n    // [12] RETURN\n    //\n    // The padding is just the 0xfe sequence (invalid opcode).\n    bytes32 private constant _DEPLOYER_CREATION_CODE =\n        0x602038038060206000396000f3fefefefefefefefefefefefefefefefefefefe;\n\n    /**\n     * @dev Deploys a contract with `code` as its code, returning the destination address.\n     *\n     * Reverts if deployment fails.\n     */\n    function deploy(bytes memory code) internal returns (address destination) {\n        bytes32 deployerCreationCode = _DEPLOYER_CREATION_CODE;\n\n        assembly {\n            let codeLength := mload(code)\n\n            // `code` is composed of length and data. We've already stored its length in `codeLength`, so we simply\n            // replace it with the deployer creation code (which is exactly 32 bytes long).\n            mstore(code, deployerCreationCode)\n\n            // At this point, `code` now points to the deployer creation code immediately followed by `code`'s data\n            // contents. This is exactly what the deployer expects to receive when created.\n            destination := create(0, code, add(codeLength, 32))\n\n            // Finally, we restore the original length in order to not mutate `code`.\n            mstore(code, codeLength)\n        }\n\n        // The create opcode returns the zero address when contract creation fails, so we revert if this happens.\n        require(destination != address(0));\n    }\n}"},"@sense-finance/v1-utils/src/Trust.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.0;\n\n/// @notice Ultra minimal authorization logic for smart contracts.\n/// @author From https://github.com/Rari-Capital/solmate/blob/fab107565a51674f3a3b5bfdaacc67f6179b1a9b/src/auth/Trust.sol\nabstract contract Trust {\n    event UserTrustUpdated(address indexed user, bool trusted);\n\n    mapping(address => bool) public isTrusted;\n\n    constructor(address initialUser) {\n        isTrusted[initialUser] = true;\n\n        emit UserTrustUpdated(initialUser, true);\n    }\n\n    function setIsTrusted(address user, bool trusted) public virtual requiresTrust {\n        isTrusted[user] = trusted;\n\n        emit UserTrustUpdated(user, trusted);\n    }\n\n    modifier requiresTrust() {\n        require(isTrusted[msg.sender], \"UNTRUSTED\");\n\n        _;\n    }\n}\n"},"solmate/src/tokens/ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"},"lib/auto-roller/src/SafeCast.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nlibrary SafeCast {\n    function safeCastTo216(uint256 x) internal pure returns (uint216 y) {\n        require(x < 1 << 216);\n\n        y = uint216(x);\n    }\n\n    function safeCastToInt(uint256 x) internal pure returns (int256 y) {\n        require(x < 1 << 255);\n\n        y = int256(x);\n    }\n\n    function safeCastToUint(int256 x) internal pure returns (uint256 y) {\n        require(x >= 0);\n\n        y = uint256(x);\n    }\n}"},"lib/auto-roller/src/external/DateTime.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n/// @author Taken from: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n\n// ----------------------------------------------------------------------------\n// DateTime Library v2.0\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary DateTime {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 constant SECONDS_PER_MINUTE = 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    uint256 constant DOW_MON = 1;\n    uint256 constant DOW_TUE = 2;\n    uint256 constant DOW_WED = 3;\n    uint256 constant DOW_THU = 4;\n    uint256 constant DOW_FRI = 5;\n    uint256 constant DOW_SAT = 6;\n    uint256 constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 _days) {\n        require(year >= 1970);\n        int256 _year = int256(year);\n        int256 _month = int256(month);\n        int256 _day = int256(day);\n\n        int256 __days = _day -\n            32075 +\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\n            4 +\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\n            12 -\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\n            4 -\n            OFFSET19700101;\n\n        _days = uint256(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n\n    function timestampFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n\n    function timestampFromDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 timestamp) {\n        timestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            hour *\n            SECONDS_PER_HOUR +\n            minute *\n            SECONDS_PER_MINUTE +\n            second;\n    }\n\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n\n    function _getDaysInMonth(uint256 year, uint256 month) internal pure returns (uint256 daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function addMonths(uint256 timestamp, uint256 _months) internal pure returns (uint256 newTimestamp) {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = ((month - 1) % 12) + 1;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp >= timestamp);\n    }\n\n    function addSeconds(uint256 timestamp, uint256 _seconds) internal pure returns (uint256 newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subSeconds(uint256 timestamp, uint256 _seconds) internal pure returns (uint256 newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n}\n"},"lib/auto-roller/src/interfaces/BalancerVault.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\n\ninterface BalancerVault {\n    struct JoinPoolRequest {\n        ERC20[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n    struct ExitPoolRequest {\n        ERC20[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            ERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 maxBlockNumber\n        );\n\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    function getProtocolFeesCollector() external returns (address);\n    function getAuthorizer() external returns (address);\n}"},"lib/auto-roller/src/interfaces/Space.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\n\nimport { BalancerVault } from \"./BalancerVault.sol\";\n\ninterface Space {\n    function getPoolId() external view returns (bytes32);\n    function totalSupply() external view returns (uint256);\n    function pti() external view returns (uint256);\n    function ts() external view returns (uint256);\n    function g2() external view returns (uint256);\n    \n    struct SwapRequest {\n        BalancerVault.SwapKind kind;\n        ERC20 tokenIn;\n        ERC20 tokenOut;\n        uint256 amount;\n        // Misc data\n        bytes32 poolId;\n        uint256 lastChangeBlock;\n        address from;\n        address to;\n        bytes userData;\n    }\n\n    function onSwap(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) \n    external \n    view // This is a lie. But it indeed will only mutate storage if called by the Balancer Vault, so it's true for our purposes here.\n    returns (uint256);\n\n    function balanceOf(address user) external view returns (uint256 amount);\n    function getPriceFromImpliedRate(uint256 impliedRate) external view returns (uint256 pTPriceInTarget);\n    function adjustedTotalSupply() external view returns (uint256 supply);\n    \n    function getEQReserves(\n        uint256 stretchedRate,\n        uint256 maturity,\n        uint256 ptReserves,\n        uint256 targetReserves,\n        uint256 totalSupply,\n        uint256 initScale\n    ) external view returns (\n        uint256 eqPTReserves,\n        uint256 eqTargetReserves\n    );\n\n    function onSwapPreview(\n        bool ptIn,\n        bool givenIn,\n        uint256 amountDelta,\n        uint256 reservesTokenIn,\n        uint256 reservesTokenOut,\n        uint256 totalSupply,\n        uint256 scale\n    ) external view returns (uint256);\n}"},"solmate/src/utils/SafeTransferLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(4, from) // Append the \"from\" argument.\n            mstore(36, to) // Append the \"to\" argument.\n            mstore(68, amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because that's the total length of our calldata (4 + 32 * 3)\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                call(gas(), token, 0, 0, 100, 0, 32)\n            )\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(4, to) // Append the \"to\" argument.\n            mstore(36, amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                call(gas(), token, 0, 0, 68, 0, 32)\n            )\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(4, to) // Append the \"to\" argument.\n            mstore(36, amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                call(gas(), token, 0, 0, 68, 0, 32)\n            )\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"},"solmate/src/mixins/ERC4626.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\nimport \"hardhat/console.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"},"solmate/src/utils/FixedPointMathLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\n    }\n\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is < 0.5 we return zero. This happens when\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n            if (x <= -42139678854452767551) return 0;\n\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n            if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5**18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // k is in the range [-61, 195].\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // p is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range (0.09, 0.25) * 2**96.\n\n            // We now need to multiply r by:\n            // * the scale factor s = ~6.031367120.\n            // * the 2**k factor from the range reduction.\n            // * the 1e18 / 2**96 factor for base conversion.\n            // We do this all at once, with an intermediate result in 2**213\n            // basis, so the final right shift is always by a positive amount.\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n        }\n    }\n\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            require(x > 0, \"UNDEFINED\");\n\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n            // We do this by multiplying by 2**96 / 10**18. But since\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n            // and add ln(2**96 / 10**18) at the end.\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            int256 k = int256(log2(uint256(x))) - 96;\n            x <<= uint256(159 - k);\n            x = int256(uint256(x) >> 159);\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // p is made monic, we will multiply by a scale factor later.\n            int256 p = x + 3273285459638523848632254066296;\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\n            p = p * x - (795164235651350426258249787498 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            // q is monic by convention.\n            int256 q = x + 5573035233440673466300451813936;\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial is known not to have zeros in the domain.\n                // No scaling required because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r is in the range (0, 0.125) * 2**96\n\n            // Finalization, we need to:\n            // * multiply by the scale factor s = 5.549…\n            // * add ln(2**96 / 10**18)\n            // * add k * ln(2)\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n            r *= 1677202110996718588342820967067443963516166;\n            // add ln(2) * k * 5e18 * 2**192\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n            // base conversion: mul 2**18 / 2**192\n            r >>= 174;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        require(x > 0, \"UNDEFINED\");\n\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // z will equal 0 if y is 0, unlike in Solidity where it will revert.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // z will equal 0 if y is 0, unlike in Solidity where it will revert.\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Will return 0 instead of reverting if y is zero.\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // Add 1 to x * y if x % y > 0.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"},"solmate/src/utils/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"},"hardhat/console.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"},"lib/morpho-core-v1/lib/solmate/src/utils/SafeTransferLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    event Debug(bool one, bool two, uint256 retsize);\n\n    /*///////////////////////////////////////////////////////////////\n                            ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (not just any non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the addition in the\n                // order of operations or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (not just any non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the addition in the\n                // order of operations or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (not just any non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the addition in the\n                // order of operations or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"},"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"},"lib/morpho-core-v1/lib/solmate/src/tokens/ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"solmate/src/test/utils/mocks/MockERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../../../tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {}\n\n    function mint(address to, uint256 value) public virtual {\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        _burn(from, value);\n    }\n}\n"},"@sense-finance/v1-utils/src/libs/Errors.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.4;\n\nlibrary Errors {\n    // Auth\n    error CombineRestricted();\n    error IssuanceRestricted();\n    error NotAuthorized();\n    error OnlyYT();\n    error OnlyDivider();\n    error OnlyPeriphery();\n    error OnlyPermissionless();\n    error OnlyAdapter();\n    error RedeemRestricted();\n    error Untrusted();\n\n    // Adapters\n    error TokenNotSupported();\n    error FlashCallbackFailed();\n    error SenderNotEligible();\n    error TargetMismatch();\n    error TargetNotSupported();\n    error InvalidAdapterType();\n    error PriceOracleNotFound();\n\n    // Divider\n    error AlreadySettled();\n    error CollectNotSettled();\n    error GuardCapReached();\n    error IssuanceFeeCapExceeded();\n    error IssueOnSettle();\n    error NotSettled();\n\n    // Input & validations\n    error AlreadyInitialized();\n    error DuplicateSeries();\n    error ExistingValue();\n    error InvalidAdapter();\n    error InvalidMaturity();\n    error InvalidParam();\n    error NotImplemented();\n    error OutOfWindowBoundaries();\n    error SeriesDoesNotExist();\n    error SwapTooSmall();\n    error TargetParamsNotSet();\n    error PoolParamsNotSet();\n    error PTParamsNotSet();\n    error AttemptFailed();\n    error InvalidPrice();\n    error BadContractInteration();\n\n    // Periphery\n    error FactoryNotSupported();\n    error FlashBorrowFailed();\n    error FlashUntrustedBorrower();\n    error FlashUntrustedLoanInitiator();\n    error UnexpectedSwapAmount();\n    error TooMuchLeftoverTarget();\n    error InvalidExchangeProxy();\n    error ZeroExSwapFailed(bytes);\n    error ZeroSwapAmt();\n    error InvalidQuote();\n\n    // Fuse\n    error AdapterNotSet();\n    error FailedBecomeAdmin();\n    error FailedAddTargetMarket();\n    error FailedToAddPTMarket();\n    error FailedAddLpMarket();\n    error OracleNotReady();\n    error PoolAlreadyDeployed();\n    error PoolNotDeployed();\n    error PoolNotSet();\n    error SeriesNotQueued();\n    error TargetExists();\n    error TargetNotInFuse();\n\n    // Tokens\n    error MintFailed();\n    error RedeemFailed();\n    error TransferFailed();\n}\n"},"@sense-finance/v1-core/src/external/flashloan/IERC3156FlashBorrower.sol":{"content":"pragma solidity ^0.8.0;\n\ninterface IERC3156FlashBorrower {\n    /// @dev Receive a flash loan.\n    /// @param initiator The initiator of the loan.\n    /// @param token The loan currency.\n    /// @param amount The amount of tokens lent.\n    /// @param fee The additional amount of tokens to repay.\n    /// @param data Arbitrary data structure, intended to contain user-defined parameters.\n    /// @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"},"@sense-finance/v1-core/src/external/flashloan/IERC3156FlashLender.sol":{"content":"pragma solidity ^0.8.0;\nimport \"./IERC3156FlashBorrower.sol\";\n\ninterface IERC3156FlashLender {\n    /// @dev The amount of currency available to be lent.\n    /// @param token The loan currency.\n    /// @return The amount of `token` that can be borrowed.\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /// @dev The fee to be charged for a given loan.\n    /// @param token The loan currency.\n    /// @param amount The amount of tokens lent.\n    /// @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /// @dev Initiate a flash loan.\n    /// @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n    /// @param token The loan currency.\n    /// @param amount The amount of tokens lent.\n    /// @param data Arbitrary data structure, intended to contain user-defined parameters.\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"},"@openzeppelin/contracts/security/Pausable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"},"@sense-finance/v1-utils/src/libs/Levels.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.0;\n\nlibrary Levels {\n    uint256 private constant _INIT_BIT = 0x1;\n    uint256 private constant _ISSUE_BIT = 0x2;\n    uint256 private constant _COMBINE_BIT = 0x4;\n    uint256 private constant _COLLECT_BIT = 0x8;\n    uint256 private constant _REDEEM_BIT = 0x10;\n    uint256 private constant _REDEEM_HOOK_BIT = 0x20;\n\n    function initRestricted(uint256 level) internal pure returns (bool) {\n        return level & _INIT_BIT != _INIT_BIT;\n    }\n\n    function issueRestricted(uint256 level) internal pure returns (bool) {\n        return level & _ISSUE_BIT != _ISSUE_BIT;\n    }\n\n    function combineRestricted(uint256 level) internal pure returns (bool) {\n        return level & _COMBINE_BIT != _COMBINE_BIT;\n    }\n\n    function collectDisabled(uint256 level) internal pure returns (bool) {\n        return level & _COLLECT_BIT != _COLLECT_BIT;\n    }\n\n    function redeemRestricted(uint256 level) internal pure returns (bool) {\n        return level & _REDEEM_BIT != _REDEEM_BIT;\n    }\n\n    function redeemHookDisabled(uint256 level) internal pure returns (bool) {\n        return level & _REDEEM_HOOK_BIT != _REDEEM_HOOK_BIT;\n    }\n}\n"},"@sense-finance/v1-core/src/tokens/YT.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Internal references\nimport { Divider } from \"../Divider.sol\";\nimport { Token } from \"./Token.sol\";\n\n/// @title Yield Token\n/// @notice Strips off excess before every transfer\ncontract YT is Token {\n    address public immutable adapter;\n    address public immutable divider;\n    uint256 public immutable maturity;\n\n    constructor(\n        address _adapter,\n        uint256 _maturity,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _divider\n    ) Token(_name, _symbol, _decimals, _divider) {\n        adapter = _adapter;\n        maturity = _maturity;\n        divider = _divider;\n    }\n\n    function collect() external returns (uint256 _collected) {\n        return Divider(divider).collect(msg.sender, adapter, maturity, 0, address(0));\n    }\n\n    function transfer(address to, uint256 value) public override returns (bool) {\n        Divider(divider).collect(msg.sender, adapter, maturity, value, to);\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public override returns (bool) {\n        if (value > 0) Divider(divider).collect(from, adapter, maturity, value, to);\n        return super.transferFrom(from, to, value);\n    }\n}\n"},"@sense-finance/v1-core/src/external/FixedMath.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n/// @title Fixed point arithmetic library\n/// @author Taken from https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol\nlibrary FixedMath {\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant RAY = 1e27;\n\n    function fmul(\n        uint256 x,\n        uint256 y,\n        uint256 baseUnit\n    ) internal pure returns (uint256) {\n        return mulDivDown(x, y, baseUnit); // Equivalent to (x * y) / baseUnit rounded down.\n    }\n\n    function fmul(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function fmulUp(\n        uint256 x,\n        uint256 y,\n        uint256 baseUnit\n    ) internal pure returns (uint256) {\n        return mulDivUp(x, y, baseUnit); // Equivalent to (x * y) / baseUnit rounded up.\n    }\n\n    function fmulUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function fdiv(\n        uint256 x,\n        uint256 y,\n        uint256 baseUnit\n    ) internal pure returns (uint256) {\n        return mulDivDown(x, baseUnit, y); // Equivalent to (x * baseUnit) / y rounded down.\n    }\n\n    function fdiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function fdivUp(\n        uint256 x,\n        uint256 y,\n        uint256 baseUnit\n    ) internal pure returns (uint256) {\n        return mulDivUp(x, baseUnit, y); // Equivalent to (x * baseUnit) / y rounded up.\n    }\n\n    function fdivUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n}\n"},"@sense-finance/v1-core/src/tokens/Token.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\n\n// Internal references\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\n\n/// @title Base Token\ncontract Token is ERC20, Trust {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _trusted\n    ) ERC20(_name, _symbol, _decimals) Trust(_trusted) {}\n\n    /// @param usr The address to send the minted tokens\n    /// @param amount The amount to be minted\n    function mint(address usr, uint256 amount) public requiresTrust {\n        _mint(usr, amount);\n    }\n\n    /// @param usr The address from where to burn tokens from\n    /// @param amount The amount to be burned\n    function burn(address usr, uint256 amount) public requiresTrust {\n        _burn(usr, amount);\n    }\n}\n"},"@sense-finance/v1-core/src/external/DateTime.sol":{"content":"pragma solidity 0.8.15;\n\n/// @author Taken from: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\nlibrary DateTime {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 constant SECONDS_PER_MINUTE = 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function toDateString(uint256 _timestamp)\n        internal\n        pure\n        returns (\n            string memory d,\n            string memory m,\n            string memory y\n        )\n    {\n        (uint256 year, uint256 month, uint256 day) = timestampToDate(_timestamp);\n        d = uintToString(day);\n        m = uintToString(month);\n        y = uintToString(year);\n        // append a 0 to numbers < 10 so we should, e.g, 01 instead of just 1\n        if (day < 10) d = string(abi.encodePacked(\"0\", d));\n        if (month < 10) m = string(abi.encodePacked(\"0\", m));\n    }\n\n    function format(uint256 _timestamp) internal pure returns (string memory datestring) {\n        string[12] memory months = [\n            \"Jan\",\n            \"Feb\",\n            \"Mar\",\n            \"Apr\",\n            \"May\",\n            \"June\",\n            \"July\",\n            \"Aug\",\n            \"Sept\",\n            \"Oct\",\n            \"Nov\",\n            \"Dec\"\n        ];\n        (uint256 year, uint256 month, uint256 day) = timestampToDate(_timestamp);\n        uint256 last = day % 10;\n        string memory suffix = \"th\";\n        if (day < 11 || day > 20) {\n            if (last == 1) suffix = \"st\";\n            if (last == 2) suffix = \"nd\";\n            if (last == 3) suffix = \"rd\";\n        }\n        return string(abi.encodePacked(uintToString(day), suffix, \" \", months[month - 1], \" \", uintToString(year)));\n    }\n\n    function getDayOfWeek(uint256 timestamp) internal pure returns (uint256 dayOfWeek) {\n        uint256 _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = ((_days + 3) % 7) + 1;\n    }\n\n    /// Taken from https://stackoverflow.com/questions/47129173/how-to-convert-uint-to-string-in-solidity\n    function uintToString(uint256 _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) return \"0\";\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 _days) {\n        require(year >= 1970);\n        int256 _year = int256(year);\n        int256 _month = int256(month);\n        int256 _day = int256(day);\n\n        int256 __days = _day -\n            32075 +\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\n            4 +\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\n            12 -\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\n            4 -\n            OFFSET19700101;\n\n        _days = uint256(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n}\n"},"@sense-finance/v1-core/src/external/IPermit2.sol":{"content":"// Minimal Permit2 interface, derived from\n// https://github.com/Uniswap/permit2/blob/main/src/interfaces/ISignatureTransfer.sol\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\n\ninterface IPermit2 {\n    // Token and amount in a permit message.\n    struct TokenPermissions {\n        // Token to transfer.\n        ERC20 token;\n        // Amount to transfer.\n        uint256 amount;\n    }\n\n    // The permit2 message.\n    struct PermitTransferFrom {\n        // Permitted token and amount.\n        TokenPermissions permitted;\n        // Unique identifier for this permit.\n        uint256 nonce;\n        // Expiration for this permit.\n        uint256 deadline;\n    }\n\n    // The permit2 message for batched transfers.\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    // Transfer details for permitTransferFrom().\n    struct SignatureTransferDetails {\n        // Recipient of tokens.\n        address to;\n        // Amount to transfer.\n        uint256 requestedAmount;\n    }\n\n    // Consume a permit2 message and transfer tokens.\n    function permitTransferFrom(\n        PermitTransferFrom calldata permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    // Consume a permit2 message and do a batched transfer of tokens.\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n}\n"},"@sense-finance/v1-core/src/external/balancer/Vault.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\n\ninterface IAsset {}\n\ninterface BalancerVault {\n    struct JoinPoolRequest {\n        IAsset[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n    struct ExitPoolRequest {\n        IAsset[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n    enum PoolSpecialization {\n        GENERAL,\n        MINIMAL_SWAP_INFO,\n        TWO_TOKEN\n    }\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n    enum JoinKind {\n        INIT,\n        EXACT_TOKENS_IN_FOR_BPT_OUT,\n        TOKEN_IN_FOR_EXACT_BPT_OUT\n    }\n    enum ExitKind {\n        EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n        BPT_IN_FOR_EXACT_TOKENS_OUT\n    }\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            ERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 maxBlockNumber\n        );\n\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    function getProtocolFeesCollector() external view returns (address);\n\n    function getAuthorizer() external returns (address);\n}\n"},"@sense-finance/v1-core/src/external/balancer/Pool.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { BalancerVault } from \"./Vault.sol\";\nimport { RateProvider } from \"./RateProvider.sol\";\n\ninterface BalancerPool {\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        returns (uint256[] memory results);\n\n    enum Variable {\n        PAIR_PRICE,\n        BPT_PRICE,\n        INVARIANT\n    }\n    struct OracleAverageQuery {\n        Variable variable;\n        uint256 secs;\n        uint256 ago;\n    }\n\n    function getSample(uint256 index)\n        external\n        view\n        returns (\n            int256 logPairPrice,\n            int256 accLogPairPrice,\n            int256 logBptPrice,\n            int256 accLogBptPrice,\n            int256 logInvariant,\n            int256 accLogInvariant,\n            uint256 timestamp\n        );\n\n    function getPoolId() external view returns (bytes32);\n\n    function getVault() external view returns (address);\n\n    function totalSupply() external view returns (uint256);\n\n    struct SwapRequest {\n        BalancerVault.SwapKind kind;\n        ERC20 tokenIn;\n        ERC20 tokenOut;\n        uint256 amount;\n        // Misc data\n        bytes32 poolId;\n        uint256 lastChangeBlock;\n        address from;\n        address to;\n        bytes userData;\n    }\n\n    function onSwap(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) external returns (uint256 amount);\n\n    function getIndices() external view returns (uint256 pti, uint256 targeti);\n\n    function getRateProviders() external view returns (RateProvider[] memory providers);\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/factories/BaseFactory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Internal references\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { BaseAdapter } from \"../BaseAdapter.sol\";\nimport { Divider } from \"../../../Divider.sol\";\nimport { FixedMath } from \"../../../external/FixedMath.sol\";\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\n\ninterface ERC20 {\n    function decimals() external view returns (uint256 decimals);\n}\n\ninterface ChainlinkOracleLike {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function decimals() external view returns (uint256 decimals);\n}\n\nabstract contract BaseFactory is Trust {\n    using FixedMath for uint256;\n\n    /* ========== CONSTANTS ========== */\n\n    address public constant ETH_USD_PRICEFEED = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419; // Chainlink ETH-USD price feed\n\n    /// @notice Sets level to `31` by default, which keeps all Divider lifecycle methods public\n    /// (`issue`, `combine`, `collect`, etc), but not the `onRedeem` hook.\n    uint48 public constant DEFAULT_LEVEL = 31;\n\n    /* ========== PUBLIC IMMUTABLES ========== */\n\n    /// @notice Sense core Divider address\n    address public immutable divider;\n\n    /// @notice Adapter admin address\n    address public restrictedAdmin;\n\n    /// @notice Rewards recipient\n    address public rewardsRecipient;\n\n    /// @notice params for adapters deployed with this factory\n    FactoryParams public factoryParams;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct FactoryParams {\n        address oracle; // oracle address\n        address stake; // token to stake at issuance\n        uint256 stakeSize; // amount to stake at issuance\n        uint256 minm; // min maturity (seconds after block.timstamp)\n        uint256 maxm; // max maturity (seconds after block.timstamp)\n        uint128 ifee; // issuance fee\n        uint16 mode; // 0 for monthly, 1 for weekly\n        uint64 tilt; // tilt\n        uint256 guard; // adapter guard (in usd, 18 decimals)\n    }\n\n    constructor(\n        address _divider,\n        address _restrictedAdmin,\n        address _rewardsRecipient,\n        FactoryParams memory _factoryParams\n    ) Trust(msg.sender) {\n        divider = _divider;\n        restrictedAdmin = _restrictedAdmin;\n        rewardsRecipient = _rewardsRecipient;\n        factoryParams = _factoryParams;\n    }\n\n    /* ========== REQUIRED DEPLOY ========== */\n\n    /// @notice Deploys both an adapter and a target wrapper for the given _target\n    /// @param _target Address of the Target token\n    /// @param _data Additional data needed to deploy the adapter\n    function deployAdapter(address _target, bytes memory _data) external virtual returns (address adapter) {}\n\n    /// Set adapter's guard to $100`000 in target\n    /// @notice if Underlying-ETH price feed returns 0, we set the guard to 100000 target.\n    function _setGuard(address _adapter) internal {\n        // We only want to execute this if divider is guarded\n        if (Divider(divider).guarded()) {\n            BaseAdapter adapter = BaseAdapter(_adapter);\n\n            // Get Underlying-ETH price (18 decimals)\n            try adapter.getUnderlyingPrice() returns (uint256 underlyingPriceInEth) {\n                // Get ETH-USD price from Chainlink (8 decimals)\n                (, int256 ethPrice, , uint256 ethUpdatedAt, ) = ChainlinkOracleLike(ETH_USD_PRICEFEED)\n                    .latestRoundData();\n\n                if (block.timestamp - ethUpdatedAt > 2 hours) revert Errors.InvalidPrice();\n\n                // Calculate Underlying-USD price (normalised to 18 deicmals)\n                uint256 price = underlyingPriceInEth.fmul(uint256(ethPrice), 1e8);\n\n                // Calculate Target-USD price (scale and price are in 18 decimals)\n                price = adapter.scale().fmul(price);\n\n                // Calculate guard with factory guard (18 decimals) and target price (18 decimals)\n                // normalised to target decimals and set it\n                Divider(divider).setGuard(\n                    _adapter,\n                    factoryParams.guard.fdiv(price, 10**ERC20(adapter.target()).decimals())\n                );\n            } catch {}\n        }\n    }\n\n    function setRestrictedAdmin(address _restrictedAdmin) external requiresTrust {\n        emit RestrictedAdminChanged(restrictedAdmin, _restrictedAdmin);\n        restrictedAdmin = _restrictedAdmin;\n    }\n\n    /// Set factory rewards recipient\n    /// @notice all future deployed adapters will have the new rewards recipient\n    /// @dev existing adapters rewards recipients will not be changed and can be\n    /// done through `setRewardsRecipient` on each adapter contract\n    function setRewardsRecipient(address _recipient) external requiresTrust {\n        emit RewardsRecipientChanged(rewardsRecipient, _recipient);\n        rewardsRecipient = _recipient;\n    }\n\n    /// @notice sets trusted address for an adapter\n    /// @dev factory must already be a trusted address for the adapter\n    function setAdapterTrusted(\n        address _adapter,\n        address _user,\n        bool _trusted\n    ) public requiresTrust {\n        Trust(_adapter).setIsTrusted(_user, _trusted);\n    }\n\n    /// Set factory params\n    /// @dev existing adapters will not be affected\n    function setFactoryParams(FactoryParams calldata _factoryParams) external requiresTrust {\n        emit FactoryParamsChanged(_factoryParams);\n        factoryParams = _factoryParams;\n    }\n\n    /* ========== LOGS ========== */\n\n    event RewardsRecipientChanged(address indexed oldRecipient, address indexed newRecipient);\n    event RestrictedAdminChanged(address indexed oldAdmin, address indexed newAdmin);\n    event FactoryParamsChanged(FactoryParams factoryParams);\n}\n"},"@sense-finance/v1-core/src/external/balancer/RateProvider.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\ninterface RateProvider {\n    function getRate() external view returns (uint256);\n}\n"},"solmate/src/utils/Bytes32AddressLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"},"@openzeppelin/contracts/proxy/Clones.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"},"@sense-finance/v1-fuse/src/external/PriceOracle.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { CToken } from \"./CToken.sol\";\n\n/// @title Price Oracle\n/// @author Compound\n/// @notice The minimum interface a contract must implement in order to work as an oracle for Fuse with Sense\n/// Original from: https://github.com/Rari-Capital/compound-protocol/blob/fuse-final/contracts/PriceOracle.sol\nabstract contract PriceOracle {\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\n    bool public constant isPriceOracle = true;\n\n    /// @notice Get the underlying price of a cToken asset\n    /// @param cToken The cToken to get the underlying price of\n    /// @return The underlying asset price mantissa (scaled by 1e18).\n    /// 0 means the price is unavailable.\n    function getUnderlyingPrice(CToken cToken) external view virtual returns (uint256);\n\n    /// @notice Get the price of an underlying asset.\n    /// @param underlying The underlying asset to get the price of.\n    /// @return The underlying asset price in ETH as a mantissa (scaled by 1e18).\n    /// 0 means the price is unavailable.\n    function price(address underlying) external view virtual returns (uint256);\n}\n"},"@sense-finance/v1-fuse/src/external/BalancerOracle.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\ninterface BalancerOracle {\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        returns (uint256[] memory results);\n\n    enum Variable {\n        PAIR_PRICE,\n        BPT_PRICE,\n        INVARIANT\n    }\n    struct OracleAverageQuery {\n        Variable variable;\n        uint256 secs;\n        uint256 ago;\n    }\n\n    function getSample(uint256 index)\n        external\n        view\n        returns (\n            int256 logPairPrice,\n            int256 accLogPairPrice,\n            int256 logBptPrice,\n            int256 accLogBptPrice,\n            int256 logInvariant,\n            int256 accLogInvariant,\n            uint256 timestamp\n        );\n\n    function getPoolId() external view returns (bytes32);\n\n    function getVault() external view returns (address);\n\n    function getIndices() external view returns (uint256 _pti, uint256 _targeti);\n\n    function totalSupply() external view returns (uint256);\n\n    function getTotalSamples() external pure returns (uint256);\n}\n"},"@sense-finance/v1-fuse/src/oracles/Target.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { PriceOracle } from \"../external/PriceOracle.sol\";\nimport { CToken } from \"../external/CToken.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\n// Internal references\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { Token } from \"@sense-finance/v1-core/src/tokens/Token.sol\";\nimport { FixedMath } from \"@sense-finance/v1-core/src/external/FixedMath.sol\";\nimport { BaseAdapter as Adapter } from \"@sense-finance/v1-core/src/adapters/abstract/BaseAdapter.sol\";\n\ncontract TargetOracle is PriceOracle, Trust {\n    using FixedMath for uint256;\n\n    /// @notice target address -> adapter address\n    mapping(address => address) public adapters;\n\n    constructor() Trust(msg.sender) {}\n\n    function setTarget(address target, address adapter) external requiresTrust {\n        adapters[target] = adapter;\n    }\n\n    function getUnderlyingPrice(CToken cToken) external view override returns (uint256) {\n        // For the sense Fuse pool, the underlying will be the Target. The semantics here can be a little confusing\n        // as we now have two layers of underlying, cToken -> Target (cToken's underlying) -> Target's underlying\n        Token target = Token(cToken.underlying());\n        return _price(address(target));\n    }\n\n    function price(address target) external view override returns (uint256) {\n        return _price(target);\n    }\n\n    function _price(address target) internal view returns (uint256) {\n        address adapter = adapters[address(target)];\n        if (adapter == address(0)) revert Errors.AdapterNotSet();\n\n        // Use the cached scale for view function compatibility\n        uint256 scale = Adapter(adapter).scaleStored();\n\n        // `Target / Target's underlying` * `Target's underlying / ETH` = `Price of Target in ETH`\n        //\n        // `scale` and the value returned by `getUnderlyingPrice` are expected to be WADs\n        return scale.fmul(Adapter(adapter).getUnderlyingPrice());\n    }\n}\n"},"@sense-finance/v1-fuse/src/oracles/LP.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { PriceOracle } from \"../external/PriceOracle.sol\";\nimport { CToken } from \"../external/CToken.sol\";\nimport { BalancerVault } from \"@sense-finance/v1-core/src/external/balancer/Vault.sol\";\nimport { BalancerPool } from \"@sense-finance/v1-core/src/external/balancer/Pool.sol\";\n\n// Internal references\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { FixedMath } from \"@sense-finance/v1-core/src/external/FixedMath.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { BaseAdapter as Adapter } from \"@sense-finance/v1-core/src/adapters/abstract/BaseAdapter.sol\";\n\ninterface SpaceLike {\n    function getFairBPTPrice(uint256 ptTwapDuration) external view returns (uint256);\n\n    function adapter() external view returns (address);\n}\n\ncontract LPOracle is PriceOracle, Trust {\n    using FixedMath for uint256;\n\n    /// @notice PT address -> pool address for oracle reads\n    mapping(address => address) public pools;\n    uint256 public twapPeriod;\n\n    constructor() Trust(msg.sender) {\n        twapPeriod = 5.5 hours;\n    }\n\n    function setTwapPeriod(uint256 _twapPeriod) external requiresTrust {\n        twapPeriod = _twapPeriod;\n    }\n\n    function getUnderlyingPrice(CToken cToken) external view override returns (uint256) {\n        // The underlying here will be an LP Token\n        return _price(cToken.underlying());\n    }\n\n    function price(address pt) external view override returns (uint256) {\n        return _price(pt);\n    }\n\n    function _price(address _pool) internal view returns (uint256) {\n        SpaceLike pool = SpaceLike(_pool);\n        address target = Adapter(pool.adapter()).target();\n\n        // Price per BPT in ETH terms, where the PT side of the pool is valued using the TWAP oracle\n        return pool.getFairBPTPrice(twapPeriod).fmul(PriceOracle(msg.sender).price(target));\n    }\n}\n"},"@sense-finance/v1-fuse/src/oracles/PT.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { PriceOracle } from \"../external/PriceOracle.sol\";\nimport { CToken } from \"../external/CToken.sol\";\nimport { BalancerOracle } from \"../external/BalancerOracle.sol\";\nimport { BalancerVault } from \"@sense-finance/v1-core/src/external/balancer/Vault.sol\";\n\n// Internal references\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { Token } from \"@sense-finance/v1-core/src/tokens/Token.sol\";\nimport { FixedMath } from \"@sense-finance/v1-core/src/external/FixedMath.sol\";\nimport { BaseAdapter as Adapter } from \"@sense-finance/v1-core/src/adapters/abstract/BaseAdapter.sol\";\n\ninterface SpaceLike {\n    function getImpliedRateFromPrice(uint256 pTPriceInTarget) external view returns (uint256);\n\n    function getPriceFromImpliedRate(uint256 impliedRate) external view returns (uint256);\n\n    function getTotalSamples() external pure returns (uint256);\n\n    function adapter() external view returns (address);\n}\n\ncontract PTOracle is PriceOracle, Trust {\n    using FixedMath for uint256;\n\n    /// @notice PT address -> pool address for oracle reads\n    mapping(address => address) public pools;\n    /// @notice Minimum implied rate this oracle will tolerate for PTs\n    uint256 public floorRate;\n    uint256 public twapPeriod;\n\n    constructor() Trust(msg.sender) {\n        floorRate = 3e18; // 300%\n        twapPeriod = 5.5 hours;\n    }\n\n    function setFloorRate(uint256 _floorRate) external requiresTrust {\n        floorRate = _floorRate;\n    }\n\n    function setTwapPeriod(uint256 _twapPeriod) external requiresTrust {\n        twapPeriod = _twapPeriod;\n    }\n\n    function setPrincipal(address pt, address pool) external requiresTrust {\n        pools[pt] = pool;\n    }\n\n    function getUnderlyingPrice(CToken cToken) external view override returns (uint256) {\n        // The underlying here will be a Principal Token\n        return _price(cToken.underlying());\n    }\n\n    function price(address pt) external view override returns (uint256) {\n        return _price(pt);\n    }\n\n    function _price(address pt) internal view returns (uint256) {\n        BalancerOracle pool = BalancerOracle(pools[address(pt)]);\n        if (pool == BalancerOracle(address(0))) revert Errors.PoolNotSet();\n\n        // if getSample(buffer_size) returns 0s, the oracle buffer is not full yet and a price can't be read\n        // https://dev.balancer.fi/references/contracts/apis/pools/weightedpool2tokens#api\n        (, , , , , , uint256 sampleTs) = pool.getSample(SpaceLike(address(pool)).getTotalSamples() - 1);\n        // Revert if the pool's oracle can't be used yet, preventing this market from being deployed\n        // on Fuse until we're able to read a TWAP\n        if (sampleTs == 0) revert Errors.OracleNotReady();\n\n        BalancerOracle.OracleAverageQuery[] memory queries = new BalancerOracle.OracleAverageQuery[](1);\n        // The BPT price slot in Space carries the implied rate TWAP\n        queries[0] = BalancerOracle.OracleAverageQuery({\n            variable: BalancerOracle.Variable.BPT_PRICE,\n            secs: twapPeriod,\n            ago: 1 hours // take the oracle from 1 hour ago plus twapPeriod ago to 1 hour ago\n        });\n\n        uint256[] memory results = pool.getTimeWeightedAverage(queries);\n        // note: impliedRate is pulled from the BPT price slot in BalancerOracle.OracleAverageQuery\n        uint256 impliedRate = results[0];\n\n        if (impliedRate > floorRate) {\n            impliedRate = floorRate;\n        }\n\n        address target = Adapter(SpaceLike(address(pool)).adapter()).target();\n\n        // `Principal Token / target` * `target / ETH` = `Price of Principal Token in ETH`\n        //\n        // Assumes the caller is the master oracle, which will have its own strategy for getting the underlying price\n        return\n            SpaceLike(address(pool)).getPriceFromImpliedRate(impliedRate).fmul(PriceOracle(msg.sender).price(target));\n    }\n}\n"},"@sense-finance/v1-fuse/src/oracles/Underlying.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { PriceOracle } from \"../external/PriceOracle.sol\";\nimport { CToken } from \"../external/CToken.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\n// Internal references\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { FixedMath } from \"@sense-finance/v1-core/src/external/FixedMath.sol\";\nimport { BaseAdapter as Adapter } from \"@sense-finance/v1-core/src/adapters/abstract/BaseAdapter.sol\";\n\ncontract UnderlyingOracle is PriceOracle, Trust {\n    using FixedMath for uint256;\n\n    /// @notice underlying address -> adapter address\n    mapping(address => address) public adapters;\n\n    constructor() Trust(msg.sender) {}\n\n    function setUnderlying(address underlying, address adapter) external requiresTrust {\n        adapters[underlying] = adapter;\n    }\n\n    function getUnderlyingPrice(CToken cToken) external view override returns (uint256) {\n        return _price(address(cToken.underlying()));\n    }\n\n    function price(address underlying) external view override returns (uint256) {\n        return _price(underlying);\n    }\n\n    function _price(address underlying) internal view returns (uint256) {\n        address adapter = adapters[address(underlying)];\n        if (adapter == address(0)) revert Errors.AdapterNotSet();\n\n        return Adapter(adapter).getUnderlyingPrice();\n    }\n}\n"},"@sense-finance/v1-fuse/src/external/CToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n/// @title Price Oracle\n/// @author Compound\ninterface CToken {\n    function underlying() external view returns (address);\n\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function decimals() external view returns (uint8);\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/factories/CropFactory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Internal references\nimport { Crop } from \"../extensions/Crop.sol\";\nimport { BaseFactory } from \"./BaseFactory.sol\";\n\nabstract contract CropFactory is BaseFactory {\n    address public reward;\n\n    constructor(\n        address _divider,\n        address _restrictedAdmin,\n        address _rewardsRecipient,\n        FactoryParams memory _factoryParams,\n        address _reward\n    ) BaseFactory(_divider, _restrictedAdmin, _rewardsRecipient, _factoryParams) {\n        reward = _reward;\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/extensions/ExtractableReward.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\n/// @title ExtractableReward\n/// @notice Allows to extract rewards from the contract to the `rewardsRecepient`\nabstract contract ExtractableReward is Trust {\n    /// -----------------------------------------------------------------------\n    /// Libraries usage\n    /// -----------------------------------------------------------------------\n\n    using SafeTransferLib for ERC20;\n\n    /// @notice Rewards recipient\n    address public rewardsRecipient;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(address _rewardsRecipient) Trust(msg.sender) {\n        rewardsRecipient = _rewardsRecipient;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Rewards extractor\n    /// -----------------------------------------------------------------------\n\n    /// @notice Receives a token address and returns whether it is an\n    /// extractable token or not\n    /// @dev To be overriden by the inheriting contract\n    function _isValid(address _token) internal virtual returns (bool);\n\n    /// @notice Transfers reward tokens from the adapter to Sense's reward container\n    function extractToken(address token) external {\n        if (!_isValid(token)) revert Errors.TokenNotSupported();\n        ERC20 t = ERC20(token);\n        uint256 tBal = t.balanceOf(address(this));\n        t.safeTransfer(rewardsRecipient, t.balanceOf(address(this)));\n        emit RewardsClaimed(token, rewardsRecipient, tBal);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Admin functions\n    /// -----------------------------------------------------------------------\n    function setRewardsRecipient(address recipient) external requiresTrust {\n        emit RewardsRecipientChanged(rewardsRecipient, recipient);\n        rewardsRecipient = recipient;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Logs\n    /// -----------------------------------------------------------------------\n    event RewardsRecipientChanged(address indexed oldRecipient, address indexed newRecipient);\n    event RewardsClaimed(address indexed token, address indexed recipient, uint256 indexed amount);\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/extensions/Crop.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Internal references\nimport { Divider } from \"../../../Divider.sol\";\nimport { BaseAdapter } from \"../BaseAdapter.sol\";\nimport { IClaimer } from \"../IClaimer.sol\";\nimport { FixedMath } from \"../../../external/FixedMath.sol\";\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\n/// @notice This is meant to be used with BaseAdapter.sol\nabstract contract Crop is Trust {\n    using SafeTransferLib for ERC20;\n    using FixedMath for uint256;\n\n    /// @notice Program state\n    address public claimer; // claimer address\n    address public reward;\n    uint256 public shares; // accumulated reward token per collected target\n    uint256 public rewardBal; // last recorded balance of reward token\n    uint256 public totalTarget; // total target accumulated by all users\n    mapping(address => uint256) public tBalance; // target balance per user\n    mapping(address => uint256) public rewarded; // reward token per user\n    mapping(address => uint256) public reconciledAmt; // reconciled target amount per user\n    mapping(address => mapping(uint256 => bool)) public reconciled; // whether a user has been reconciled for a given maturity\n\n    constructor(address _divider, address _reward) {\n        setIsTrusted(_divider, true);\n        reward = _reward;\n    }\n\n    /// @notice Distribute the rewards tokens to the user according to their shares\n    /// @dev The reconcile amount allows us to prevent diluting other users' rewards\n    function notify(\n        address _usr,\n        uint256 amt,\n        bool join\n    ) public virtual requiresTrust {\n        _distribute(_usr);\n        if (amt > 0) {\n            if (join) {\n                totalTarget += amt;\n                tBalance[_usr] += amt;\n            } else {\n                uint256 uReconciledAmt = reconciledAmt[_usr];\n                if (uReconciledAmt > 0) {\n                    if (amt < uReconciledAmt) {\n                        unchecked {\n                            uReconciledAmt -= amt;\n                        }\n                        amt = 0;\n                    } else {\n                        unchecked {\n                            amt -= uReconciledAmt;\n                        }\n                        uReconciledAmt = 0;\n                    }\n                    reconciledAmt[_usr] = uReconciledAmt;\n                }\n                if (amt > 0) {\n                    totalTarget -= amt;\n                    tBalance[_usr] -= amt;\n                }\n            }\n        }\n        rewarded[_usr] = tBalance[_usr].fmulUp(shares, FixedMath.RAY);\n    }\n\n    /// @notice Reconciles users target balances to zero by distributing rewards on their holdings,\n    /// to avoid dilution of next Series' YT holders.\n    /// This function should be called right after a Series matures and will save the user's YT balance\n    /// (in target terms) on reconciledAmt[usr]. When `notify()` is triggered, we take that amount and\n    /// subtract it from the user's target balance (`tBalance`) which will fix (or reconcile)\n    /// his position to prevent dilution.\n    /// @param _usrs Users to reconcile\n    /// @param _maturities Maturities of the series that we want to reconcile users on.\n    function reconcile(address[] calldata _usrs, uint256[] calldata _maturities) public {\n        Divider divider = Divider(BaseAdapter(address(this)).divider());\n        for (uint256 j = 0; j < _maturities.length; j++) {\n            for (uint256 i = 0; i < _usrs.length; i++) {\n                address usr = _usrs[i];\n                uint256 ytBal = ERC20(divider.yt(address(this), _maturities[j])).balanceOf(usr);\n                // We don't want to reconcile users if maturity has not been reached or if they have already been reconciled\n                if (_maturities[j] <= block.timestamp && ytBal > 0 && !reconciled[usr][_maturities[j]]) {\n                    _distribute(usr);\n                    uint256 tBal = ytBal.fdiv(divider.lscales(address(this), _maturities[j], usr));\n                    totalTarget -= tBal;\n                    tBalance[usr] -= tBal;\n                    reconciledAmt[usr] += tBal; // We increase reconciledAmt with the user's YT balance in target terms\n                    reconciled[usr][_maturities[j]] = true;\n                    emit Reconciled(usr, tBal, _maturities[j]);\n                }\n            }\n        }\n    }\n\n    /// @notice Distributes rewarded tokens to users proportionally based on their `tBalance`\n    /// @param _usr User to distribute reward tokens to\n    function _distribute(address _usr) internal {\n        _claimReward();\n\n        uint256 crop = ERC20(reward).balanceOf(address(this)) - rewardBal;\n        if (totalTarget > 0) shares += (crop.fdiv(totalTarget, FixedMath.RAY));\n\n        uint256 last = rewarded[_usr];\n        uint256 curr = tBalance[_usr].fmul(shares, FixedMath.RAY);\n        if (curr > last) {\n            unchecked {\n                ERC20(reward).safeTransfer(_usr, curr - last);\n            }\n        }\n        rewardBal = ERC20(reward).balanceOf(address(this));\n        emit Distributed(_usr, reward, curr > last ? curr - last : 0);\n    }\n\n    /// @notice Some protocols don't airdrop reward tokens, instead users must claim them.\n    /// This method may be overriden by child contracts to claim a protocol's rewards\n    function _claimReward() internal virtual {\n        if (claimer != address(0)) {\n            ERC20 target = ERC20(BaseAdapter(address(this)).target());\n            uint256 tBal = ERC20(target).balanceOf(address(this));\n\n            if (tBal > 0) {\n                // We send all the target balance to the claimer contract to it can claim rewards\n                ERC20(target).transfer(claimer, tBal);\n\n                // Make claimer to claim rewards\n                IClaimer(claimer).claim();\n\n                // Get the target back\n                if (ERC20(target).balanceOf(address(this)) < tBal) revert Errors.BadContractInteration();\n            }\n        }\n    }\n\n    /// @notice Overrides the rewardToken address.\n    /// @param _reward New reward token address\n    function setRewardToken(address _reward) public requiresTrust {\n        _claimReward();\n        reward = _reward;\n        emit RewardTokenChanged(reward);\n    }\n\n    /// @notice Sets `claimer`.\n    /// @param _claimer New claimer contract address\n    function setClaimer(address _claimer) public requiresTrust {\n        claimer = _claimer;\n        emit ClaimerChanged(claimer);\n    }\n\n    /* ========== LOGS ========== */\n\n    event Distributed(address indexed usr, address indexed token, uint256 amount);\n    event Reconciled(address indexed usr, uint256 tBal, uint256 maturity);\n    event RewardTokenChanged(address indexed reward);\n    event ClaimerChanged(address indexed claimer);\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/IClaimer.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\ninterface IClaimer {\n    /// @dev Claims rewards on protocol.\n    function claim() external;\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/extensions/Crops.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Internal references\nimport { Divider } from \"../../../Divider.sol\";\nimport { BaseAdapter } from \"../BaseAdapter.sol\";\nimport { IClaimer } from \"../IClaimer.sol\";\nimport { FixedMath } from \"../../../external/FixedMath.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\n\n/// @notice This is meant to be used with BaseAdapter.sol\nabstract contract Crops is Trust {\n    using SafeTransferLib for ERC20;\n    using FixedMath for uint256;\n\n    /// @notice Program state\n    address public claimer; // claimer address\n    uint256 public totalTarget; // total target accumulated by all users\n    mapping(address => uint256) public tBalance; // target balance per user\n    mapping(address => uint256) public reconciledAmt; // reconciled target amount per user\n    mapping(address => mapping(uint256 => bool)) public reconciled; // whether a user has been reconciled for a given maturity\n\n    address[] public rewardTokens; // reward tokens addresses\n    mapping(address => Crop) public data;\n\n    struct Crop {\n        // Accumulated reward token per collected target\n        uint256 shares;\n        // Last recorded balance of reward token\n        uint256 rewardBal;\n        // Rewarded token per user\n        mapping(address => uint256) rewarded;\n    }\n\n    constructor(address _divider, address[] memory _rewardTokens) {\n        setIsTrusted(_divider, true);\n        rewardTokens = _rewardTokens;\n    }\n\n    function notify(\n        address _usr,\n        uint256 amt,\n        bool join\n    ) public virtual requiresTrust {\n        _distribute(_usr);\n        if (amt > 0) {\n            if (join) {\n                totalTarget += amt;\n                tBalance[_usr] += amt;\n            } else {\n                uint256 uReconciledAmt = reconciledAmt[_usr];\n                if (uReconciledAmt > 0) {\n                    if (amt < uReconciledAmt) {\n                        unchecked {\n                            uReconciledAmt -= amt;\n                        }\n                        amt = 0;\n                    } else {\n                        unchecked {\n                            amt -= uReconciledAmt;\n                        }\n                        uReconciledAmt = 0;\n                    }\n                    reconciledAmt[_usr] = uReconciledAmt;\n                }\n                if (amt > 0) {\n                    totalTarget -= amt;\n                    tBalance[_usr] -= amt;\n                }\n            }\n        }\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            data[rewardTokens[i]].rewarded[_usr] = tBalance[_usr].fmulUp(data[rewardTokens[i]].shares, FixedMath.RAY);\n        }\n    }\n\n    /// @notice Reconciles users target balances to zero by distributing rewards on their holdings,\n    /// to avoid dilution of next Series' YT holders.\n    /// This function should be called right after a Series matures and will save the user's YT balance\n    /// (in target terms) on reconciledAmt[usr]. When `notify()` is triggered for on a new Series, we will\n    /// take that amount and subtract it from the user's target balance (`tBalance`) which will fix (or reconcile)\n    /// his position to prevent dilution.\n    /// @param _usrs Users to reconcile\n    /// @param _maturities Maturities of the series that we want to reconcile users on.\n    function reconcile(address[] calldata _usrs, uint256[] calldata _maturities) public {\n        Divider divider = Divider(BaseAdapter(address(this)).divider());\n        for (uint256 j = 0; j < _maturities.length; j++) {\n            for (uint256 i = 0; i < _usrs.length; i++) {\n                address usr = _usrs[i];\n                uint256 ytBal = ERC20(divider.yt(address(this), _maturities[j])).balanceOf(usr);\n                // We don't want to reconcile users if maturity has not been reached or if they have already been reconciled\n                if (_maturities[j] <= block.timestamp && ytBal > 0 && !reconciled[usr][_maturities[j]]) {\n                    _distribute(usr);\n                    uint256 tBal = ytBal.fdiv(divider.lscales(address(this), _maturities[j], usr));\n                    totalTarget -= tBal;\n                    tBalance[usr] -= tBal;\n                    reconciledAmt[usr] += tBal; // We increase reconciledAmt with the user's YT balance in target terms\n                    reconciled[usr][_maturities[j]] = true;\n                    emit Reconciled(usr, tBal, _maturities[j]);\n                }\n            }\n        }\n    }\n\n    /// @notice Distributes rewarded tokens to users proportionally based on their `tBalance`\n    /// @param _usr User to distribute reward tokens to\n    function _distribute(address _usr) internal {\n        _claimRewards();\n\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 crop = ERC20(rewardTokens[i]).balanceOf(address(this)) - data[rewardTokens[i]].rewardBal;\n            if (totalTarget > 0) data[rewardTokens[i]].shares += (crop.fdiv(totalTarget, FixedMath.RAY));\n\n            uint256 last = data[rewardTokens[i]].rewarded[_usr];\n            uint256 curr = tBalance[_usr].fmul(data[rewardTokens[i]].shares, FixedMath.RAY);\n            if (curr > last) {\n                unchecked {\n                    ERC20(rewardTokens[i]).safeTransfer(_usr, curr - last);\n                }\n            }\n            data[rewardTokens[i]].rewardBal = ERC20(rewardTokens[i]).balanceOf(address(this));\n            emit Distributed(_usr, rewardTokens[i], curr > last ? curr - last : 0);\n        }\n    }\n\n    /// @notice Some protocols don't airdrop reward tokens, instead users must claim them.\n    /// This method may be overriden by child contracts to claim a protocol's rewards\n    function _claimRewards() internal virtual {\n        if (claimer != address(0)) {\n            ERC20 target = ERC20(BaseAdapter(address(this)).target());\n            uint256 tBal = ERC20(target).balanceOf(address(this));\n\n            if (tBal > 0) {\n                // We send all the target balance to the claimer contract to it can claim rewards\n                ERC20(target).transfer(claimer, tBal);\n\n                // Make claimer to claim rewards\n                IClaimer(claimer).claim();\n\n                // Get the target back\n                if (ERC20(target).balanceOf(address(this)) < tBal) revert Errors.BadContractInteration();\n            }\n        }\n    }\n\n    /// @notice Overrides the rewardTokens array with a new one.\n    /// @dev Calls _claimRewards() in case the new array contains less reward tokens than the old one.\n    /// @param _rewardTokens New reward tokens array\n    function setRewardTokens(address[] memory _rewardTokens) public requiresTrust {\n        _claimRewards();\n        rewardTokens = _rewardTokens;\n        emit RewardTokensChanged(rewardTokens);\n    }\n\n    /// @notice Sets `claimer`.\n    /// @param _claimer New claimer contract address\n    function setClaimer(address _claimer) public requiresTrust {\n        claimer = _claimer;\n        emit ClaimerChanged(claimer);\n    }\n\n    /* ========== LOGS ========== */\n\n    event Distributed(address indexed usr, address indexed token, uint256 amount);\n    event RewardTokensChanged(address[] indexed rewardTokens);\n    event Reconciled(address indexed usr, uint256 tBal, uint256 maturity);\n    event ClaimerChanged(address indexed claimer);\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/erc4626/ERC4626CropsAdapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC4626Adapter } from \"./ERC4626Adapter.sol\";\nimport { BaseAdapter } from \"../BaseAdapter.sol\";\nimport { Crops } from \"../extensions/Crops.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n/// @notice Adapter contract for ERC4626 Vaults\ncontract ERC4626CropsAdapter is ERC4626Adapter, Crops {\n    using SafeTransferLib for ERC20;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        AdapterParams memory _adapterParams,\n        address[] memory _rewardTokens\n    ) ERC4626Adapter(_divider, _target, _rewardsRecipient, _ifee, _adapterParams) Crops(_divider, _rewardTokens) {}\n\n    function notify(\n        address _usr,\n        uint256 amt,\n        bool join\n    ) public override(BaseAdapter, Crops) {\n        super.notify(_usr, amt, join);\n    }\n\n    function _isValid(address _token) internal override returns (bool) {\n        for (uint256 i = 0; i < rewardTokens.length; ) {\n            if (_token == rewardTokens[i]) return false;\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Check that token is neither the target nor the stake\n        return (_token != target && _token != adapterParams.stake);\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/erc4626/ERC4626Adapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { ERC4626 } from \"solmate/src/mixins/ERC4626.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\n// Internal references\nimport { MasterPriceOracle } from \"../../implementations/oracles/MasterPriceOracle.sol\";\nimport { FixedMath } from \"../../../external/FixedMath.sol\";\nimport { BaseAdapter } from \"../BaseAdapter.sol\";\nimport { ExtractableReward } from \"../extensions/ExtractableReward.sol\";\n\n/// @notice Adapter contract for ERC4626 Vaults\ncontract ERC4626Adapter is BaseAdapter, ExtractableReward {\n    using SafeTransferLib for ERC20;\n    using FixedMath for uint256;\n\n    address public constant RARI_MASTER_ORACLE = 0x1887118E49e0F4A78Bd71B792a49dE03504A764D;\n\n    uint256 public immutable BASE_UINT;\n    uint256 public immutable SCALE_FACTOR;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        AdapterParams memory _adapterParams\n    )\n        BaseAdapter(_divider, _target, address(ERC4626(_target).asset()), _ifee, _adapterParams)\n        ExtractableReward(_rewardsRecipient)\n    {\n        BASE_UINT = 10**ERC4626(target).decimals();\n        SCALE_FACTOR = 10**(18 - ERC4626(underlying).decimals()); // we assume targets decimals <= 18\n        ERC20(underlying).safeApprove(target, type(uint256).max);\n    }\n\n    function scale() external override returns (uint256) {\n        return ERC4626(target).convertToAssets(BASE_UINT) * SCALE_FACTOR;\n    }\n\n    function scaleStored() external view override returns (uint256) {\n        return ERC4626(target).convertToAssets(BASE_UINT) * SCALE_FACTOR;\n    }\n\n    function getUnderlyingPrice() external view override returns (uint256 price) {\n        price = MasterPriceOracle(adapterParams.oracle).price(underlying);\n        if (price == 0) {\n            revert Errors.InvalidPrice();\n        }\n    }\n\n    function wrapUnderlying(uint256 assets) external override returns (uint256 _shares) {\n        ERC20(underlying).safeTransferFrom(msg.sender, address(this), assets);\n        _shares = ERC4626(target).deposit(assets, msg.sender);\n    }\n\n    function unwrapTarget(uint256 shares) external override returns (uint256 _assets) {\n        _assets = ERC4626(target).redeem(shares, msg.sender, msg.sender);\n    }\n\n    function _isValid(address _token) internal virtual override returns (bool) {\n        return (_token != target && _token != adapterParams.stake);\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/IPriceFeed.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n/// @title IPriceFeed\n/// @notice Returns prices of underlying tokens\n/// @author Taken from: https://github.com/Rari-Capital/fuse-v1/blob/development/src/oracles/BasePriceOracle.sol\ninterface IPriceFeed {\n    /// @notice Get the price of an underlying asset.\n    /// @param underlying The underlying asset to get the price of.\n    /// @return price The underlying asset price in ETH as a mantissa (scaled by 1e18).\n    /// Zero means the price is unavailable.\n    function price(address underlying) external view returns (uint256 price);\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/erc4626/ERC4626CropAdapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC4626Adapter } from \"./ERC4626Adapter.sol\";\nimport { BaseAdapter } from \"../BaseAdapter.sol\";\nimport { Crop } from \"../extensions/Crop.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n/// @notice Adapter contract for ERC4626 Vaults\ncontract ERC4626CropAdapter is ERC4626Adapter, Crop {\n    using SafeTransferLib for ERC20;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        AdapterParams memory _adapterParams,\n        address _reward\n    ) ERC4626Adapter(_divider, _target, _rewardsRecipient, _ifee, _adapterParams) Crop(_divider, _reward) {}\n\n    function notify(\n        address _usr,\n        uint256 amt,\n        bool join\n    ) public override(BaseAdapter, Crop) {\n        super.notify(_usr, amt, join);\n    }\n\n    function _isValid(address _token) internal override returns (bool) {\n        return (_token != target && _token != adapterParams.stake && _token != reward);\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/erc4626/OwnableERC4626Adapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC4626Adapter } from \"./ERC4626Adapter.sol\";\n\ninterface Opener {\n    function onSponsorWindowOpened(address, uint256) external;\n}\n\n/// @notice Ownable Adapter contract for Rolling Liquidity Vaults\n/// This adapter allows only the owner, which must comply with the Opener\n/// interface, to Sponsor a Series\ncontract OwnableERC4626Adapter is ERC4626Adapter {\n    uint256 internal open = 1;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        AdapterParams memory _adapterParams\n    ) ERC4626Adapter(_divider, _target, _rewardsRecipient, _ifee, _adapterParams) {}\n\n    function openSponsorWindow() external requiresTrust {\n        open = 2;\n        Opener(msg.sender).onSponsorWindowOpened(adapterParams.stake, adapterParams.stakeSize);\n        open = 1;\n    }\n\n    // @notice If the Sponsor Window is open (which can only be done by the owner of this contract),\n    // return the maturity bounds. Otherwise, return 0 making the sponsoring to revert.\n    function getMaturityBounds() external view override returns (uint256, uint256) {\n        return open == 2 ? (adapterParams.minm, adapterParams.maxm) : (0, 0);\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/erc4626/OwnableERC4626CropAdapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC4626CropAdapter } from \"./ERC4626CropAdapter.sol\";\n\ninterface Opener {\n    function onSponsorWindowOpened(address, uint256) external;\n}\n\n/// @notice Ownable Crop Adapter contract for Rolling Liquidity Vaults\n/// This adapter allows only the owner, which must comply with the Opener\n/// interface, to Sponsor a Series\ncontract OwnableERC4626CropAdapter is ERC4626CropAdapter {\n    uint256 internal open = 1;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _rewardsRecipient,\n        uint128 _ifee,\n        AdapterParams memory _adapterParams,\n        address _reward\n    ) ERC4626CropAdapter(_divider, _target, _rewardsRecipient, _ifee, _adapterParams, _reward) {}\n\n    function openSponsorWindow() external requiresTrust {\n        open = 2;\n        Opener(msg.sender).onSponsorWindowOpened(adapterParams.stake, adapterParams.stakeSize);\n        open = 1;\n    }\n\n    // @notice If the Sponsor Window is open (which can only be done by the owner of this contract),\n    // return the maturity bounds. Otherwise, return 0 making the sponsoring to revert.\n    function getMaturityBounds() external view override returns (uint256, uint256) {\n        return open == 2 ? (adapterParams.minm, adapterParams.maxm) : (0, 0);\n    }\n}\n"},"@openzeppelin/contracts/interfaces/IERC4626.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"},"@openzeppelin/contracts/token/ERC20/ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/erc4626/ERC4626.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Forked from solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @dev Modified to allow different decimals between the token and the underlying asset.\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply;\n        return\n            (assets == 0 || supply == 0)\n                ? assets.mulDivDown(10**decimals, 10**asset.decimals())\n                : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply;\n        return\n            (supply == 0)\n                ? shares.mulDivDown(10**asset.decimals(), 10**decimals)\n                : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        return\n            (supply == 0)\n                ? shares.mulDivUp(10**asset.decimals(), 10**decimals)\n                : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        return\n            (supply == 0)\n                ? assets.mulDivUp(10**decimals, 10**asset.decimals())\n                : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"},"@sense-finance/v1-core/lib/yield-daddy/src/euler/EulerERC4626Factory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.13;\n\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/src/mixins/ERC4626.sol\";\n\nimport {EulerERC4626} from \"./EulerERC4626.sol\";\nimport {IEulerEToken} from \"./external/IEulerEToken.sol\";\nimport {ERC4626Factory} from \"../base/ERC4626Factory.sol\";\nimport {IEulerMarkets} from \"./external/IEulerMarkets.sol\";\n\n/// @title EulerERC4626Factory\n/// @author zefram.eth\n/// @notice Factory for creating EulerERC4626 contracts\ncontract EulerERC4626Factory is ERC4626Factory {\n    /// -----------------------------------------------------------------------\n    /// Errors\n    /// -----------------------------------------------------------------------\n\n    /// @notice Thrown when trying to deploy an EulerERC4626 vault using an asset without an eToken\n    error EulerERC4626Factory__ETokenNonexistent();\n\n    /// -----------------------------------------------------------------------\n    /// Immutable params\n    /// -----------------------------------------------------------------------\n\n    /// @notice The Euler main contract address\n    /// @dev Target of ERC20 approval when depositing\n    address public immutable euler;\n\n    /// @notice The Euler markets module address\n    IEulerMarkets public immutable markets;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(address euler_, IEulerMarkets markets_) {\n        euler = euler_;\n        markets = markets_;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// External functions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc ERC4626Factory\n    function createERC4626(ERC20 asset) external virtual override returns (ERC4626 vault) {\n        address eTokenAddress = markets.underlyingToEToken(address(asset));\n        if (eTokenAddress == address(0)) {\n            revert EulerERC4626Factory__ETokenNonexistent();\n        }\n\n        vault = new EulerERC4626{salt: bytes32(0)}(asset, euler, IEulerEToken(eTokenAddress));\n\n        emit CreateERC4626(asset, vault);\n    }\n\n    /// @inheritdoc ERC4626Factory\n    function computeERC4626Address(ERC20 asset) external view virtual override returns (ERC4626 vault) {\n        vault = ERC4626(\n            _computeCreate2Address(\n                keccak256(\n                    abi.encodePacked(\n                        // Deployment bytecode:\n                        type(EulerERC4626).creationCode,\n                        // Constructor arguments:\n                        abi.encode(asset, euler, IEulerEToken(markets.underlyingToEToken(address(asset))))\n                    )\n                )\n            )\n        );\n    }\n}\n"},"@sense-finance/v1-core/lib/yield-daddy/src/base/ERC4626Factory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.13;\n\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/src/mixins/ERC4626.sol\";\nimport {Bytes32AddressLib} from \"solmate/src/utils/Bytes32AddressLib.sol\";\n\n/// @title ERC4626Factory\n/// @author zefram.eth\n/// @notice Abstract base contract for deploying ERC4626 wrappers\n/// @dev Uses CREATE2 deterministic deployment, so there can only be a single\n/// vault for each asset.\nabstract contract ERC4626Factory {\n    /// -----------------------------------------------------------------------\n    /// Library usage\n    /// -----------------------------------------------------------------------\n\n    using Bytes32AddressLib for bytes32;\n\n    /// -----------------------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------------------\n\n    /// @notice Emitted when a new ERC4626 vault has been created\n    /// @param asset The base asset used by the vault\n    /// @param vault The vault that was created\n    event CreateERC4626(ERC20 indexed asset, ERC4626 vault);\n\n    /// -----------------------------------------------------------------------\n    /// External functions\n    /// -----------------------------------------------------------------------\n\n    /// @notice Creates an ERC4626 vault for an asset\n    /// @dev Uses CREATE2 deterministic deployment, so there can only be a single\n    /// vault for each asset. Will revert if a vault has already been deployed for the asset.\n    /// @param asset The base asset used by the vault\n    /// @return vault The vault that was created\n    function createERC4626(ERC20 asset) external virtual returns (ERC4626 vault);\n\n    /// @notice Computes the address of the ERC4626 vault corresponding to an asset. Returns\n    /// a valid result regardless of whether the vault has already been deployed.\n    /// @param asset The base asset used by the vault\n    /// @return vault The vault corresponding to the asset\n    function computeERC4626Address(ERC20 asset) external view virtual returns (ERC4626 vault);\n\n    /// -----------------------------------------------------------------------\n    /// Internal functions\n    /// -----------------------------------------------------------------------\n\n    /// @notice Computes the address of a contract deployed by this factory using CREATE2, given\n    /// the bytecode hash of the contract. Can also be used to predict addresses of contracts yet to\n    /// be deployed.\n    /// @dev Always uses bytes32(0) as the salt\n    /// @param bytecodeHash The keccak256 hash of the creation code of the contract being deployed concatenated\n    /// with the ABI-encoded constructor arguments.\n    /// @return The address of the deployed contract\n    function _computeCreate2Address(bytes32 bytecodeHash) internal view virtual returns (address) {\n        return keccak256(abi.encodePacked(bytes1(0xFF), address(this), bytes32(0), bytecodeHash))\n            // Prefix:\n            // Creator:\n            // Salt:\n            // Bytecode hash:\n            .fromLast20Bytes(); // Convert the CREATE2 hash into an address.\n    }\n}\n"},"@sense-finance/v1-core/lib/yield-daddy/src/euler/external/IEulerEToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.13;\n\n/// @notice Tokenised representation of assets\ninterface IEulerEToken {\n    /// @notice Balance of a particular account, in underlying units (increases as interest is earned)\n    function balanceOfUnderlying(address account) external view returns (uint256);\n\n    /// @notice Transfer underlying tokens from sender to the Euler pool, and increase account's eTokens\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param amount In underlying units (use max uint256 for full underlying token balance)\n    function deposit(uint256 subAccountId, uint256 amount) external;\n\n    /// @notice Transfer underlying tokens from Euler pool to sender, and decrease account's eTokens\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param amount In underlying units (use max uint256 for full pool balance)\n    function withdraw(uint256 subAccountId, uint256 amount) external;\n}\n"},"@sense-finance/v1-core/lib/yield-daddy/src/euler/external/IEulerMarkets.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.13;\n\n/// @notice Activating and querying markets, and maintaining entered markets lists\ninterface IEulerMarkets {\n    /// @notice Given an underlying, lookup the associated EToken\n    /// @param underlying Token address\n    /// @return EToken address, or address(0) if not activated\n    function underlyingToEToken(address underlying) external view returns (address);\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/erc4626/yield-daddy/euler/EulerERC4626.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { IEulerEToken } from \"../../../../../../lib/yield-daddy/src/euler/external/IEulerEToken.sol\";\nimport { EulerERC4626 as Base } from \"../../../../../../lib/yield-daddy/src/euler/EulerERC4626.sol\";\nimport { ExtractableReward } from \"../../../extensions/ExtractableReward.sol\";\n\n/// @title EulerERC4626\n/// @author forked from Yield Daddy (Timeless Finance)\n/// @notice ERC4626 wrapper for Euler Finance\ncontract EulerERC4626 is Base, ExtractableReward {\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n    constructor(\n        ERC20 _asset,\n        address _euler,\n        IEulerEToken _eToken,\n        address _rewardsRecipient\n    ) Base(_asset, _euler, _eToken) ExtractableReward(_rewardsRecipient) {}\n\n    /// -----------------------------------------------------------------------\n    /// Overrides\n    /// -----------------------------------------------------------------------\n    function _isValid(address _token) internal override returns (bool) {\n        return _token != address(eToken);\n    }\n}\n"},"@sense-finance/v1-core/src/adapters/abstract/erc4626/yield-daddy/base/ERC4626WrapperFactory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { ERC4626Factory } from \"../../../../../../lib/yield-daddy/src/base/ERC4626Factory.sol\";\n\n/// @title ERC4626WrapperFactory\n/// @notice Adds restrictedAdmin and rewardsRecipient to ERC4626Factory from yield-daddy\nabstract contract ERC4626WrapperFactory is ERC4626Factory, Trust {\n    /// -----------------------------------------------------------------------\n    /// Params\n    /// -----------------------------------------------------------------------\n\n    /// @notice Wrapper admin\n    address public restrictedAdmin;\n\n    /// @notice Rewards recipient\n    address public rewardsRecipient;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(address _restrictedAdmin, address _rewardsRecipient) Trust(msg.sender) {\n        restrictedAdmin = _restrictedAdmin;\n        rewardsRecipient = _rewardsRecipient;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Admin functions\n    /// -----------------------------------------------------------------------\n    function setRestrictedAdmin(address _restrictedAdmin) external requiresTrust {\n        emit RestrictedAdminChanged(restrictedAdmin, _restrictedAdmin);\n        restrictedAdmin = _restrictedAdmin;\n    }\n\n    function setRewardsRecipient(address _recipient) external requiresTrust {\n        emit RewardsRecipientChanged(rewardsRecipient, _recipient);\n        rewardsRecipient = _recipient;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------------------\n\n    event RestrictedAdminChanged(address indexed restrictedAdmin, address indexed newRestrictedAdmin);\n    event RewardsRecipientChanged(address indexed oldRecipient, address indexed newRecipient);\n}\n"},"@sense-finance/v1-core/lib/yield-daddy/src/euler/EulerERC4626.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.13;\n\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/src/mixins/ERC4626.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\n\nimport {IEulerEToken} from \"./external/IEulerEToken.sol\";\n\n/// @title EulerERC4626\n/// @author zefram.eth\n/// @notice ERC4626 wrapper for Euler Finance\ncontract EulerERC4626 is ERC4626 {\n    /// -----------------------------------------------------------------------\n    /// Libraries usage\n    /// -----------------------------------------------------------------------\n\n    using SafeTransferLib for ERC20;\n\n    /// -----------------------------------------------------------------------\n    /// Immutable params\n    /// -----------------------------------------------------------------------\n\n    /// @notice The Euler main contract address\n    /// @dev Target of ERC20 approval when depositing\n    address public immutable euler;\n\n    /// @notice The Euler eToken contract\n    IEulerEToken public immutable eToken;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(ERC20 asset_, address euler_, IEulerEToken eToken_)\n        ERC4626(asset_, _vaultName(asset_), _vaultSymbol(asset_))\n    {\n        euler = euler_;\n        eToken = eToken_;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// ERC4626 overrides\n    /// -----------------------------------------------------------------------\n\n    function totalAssets() public view virtual override returns (uint256) {\n        return eToken.balanceOfUnderlying(address(this));\n    }\n\n    function beforeWithdraw(uint256 assets, uint256 /*shares*/ ) internal virtual override {\n        /// -----------------------------------------------------------------------\n        /// Withdraw assets from Euler\n        /// -----------------------------------------------------------------------\n\n        eToken.withdraw(0, assets);\n    }\n\n    function afterDeposit(uint256 assets, uint256 /*shares*/ ) internal virtual override {\n        /// -----------------------------------------------------------------------\n        /// Deposit assets into Euler\n        /// -----------------------------------------------------------------------\n\n        // approve to euler\n        asset.safeApprove(address(euler), assets);\n\n        // deposit into eToken\n        eToken.deposit(0, assets);\n    }\n\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        uint256 cash = asset.balanceOf(euler);\n        uint256 assetsBalance = convertToAssets(balanceOf[owner]);\n        return cash < assetsBalance ? cash : assetsBalance;\n    }\n\n    function maxRedeem(address owner) public view override returns (uint256) {\n        uint256 cash = asset.balanceOf(euler);\n        uint256 cashInShares = convertToShares(cash);\n        uint256 shareBalance = balanceOf[owner];\n        return cashInShares < shareBalance ? cashInShares : shareBalance;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// ERC20 metadata generation\n    /// -----------------------------------------------------------------------\n\n    function _vaultName(ERC20 asset_) internal view virtual returns (string memory vaultName) {\n        vaultName = string.concat(\"ERC4626-Wrapped Euler \", asset_.symbol());\n    }\n\n    function _vaultSymbol(ERC20 asset_) internal view virtual returns (string memory vaultSymbol) {\n        vaultSymbol = string.concat(\"we\", asset_.symbol());\n    }\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":100},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata","devdoc","userdoc","storageLayout","evm.gasEstimates"],"":["ast"]}},"metadata":{"useLiteralContent":true},"libraries":{"":{}}}}