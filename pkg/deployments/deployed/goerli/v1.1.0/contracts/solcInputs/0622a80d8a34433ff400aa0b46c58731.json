{
  "language": "Solidity",
  "sources": {
    "src/index.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@sense-finance/v1-core/src/Divider.sol\";\nimport \"@sense-finance/v1-core/src/Periphery.sol\";\nimport \"@sense-finance/v1-core/src/adapters/BaseAdapter.sol\";\nimport \"@sense-finance/v1-core/src/adapters/compound/CFactory.sol\";\nimport \"@sense-finance/v1-core/src/adapters/lido/WstETHAdapter.sol\";\nimport \"@sense-finance/v1-core/src/adapters/lido/WstETHAdapter.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/fuse/MockOracle.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/fuse/MockComptroller.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/fuse/MockFuseDirectory.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/MockAdapter.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/MockToken.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/MockTarget.sol\";\nimport \"@sense-finance/v1-core/src/tests/test-helpers/mocks/MockFactory.sol\";\nimport { CAdapter } from \"@sense-finance/v1-core/src/adapters/compound/CAdapter.sol\";\nimport { PoolManager } from \"@sense-finance/v1-fuse/src/PoolManager.sol\";\nimport { EmergencyStop } from \"@sense-finance/v1-utils/src/EmergencyStop.sol\";\n\nimport \"./Versioning.sol\";"
    },
    "@sense-finance/v1-core/src/Divider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport { ReentrancyGuard } from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\nimport { DateTime } from \"./external/DateTime.sol\";\nimport { FixedMath } from \"./external/FixedMath.sol\";\n\n// Internal references\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\nimport { Levels } from \"@sense-finance/v1-utils/src/libs/Levels.sol\";\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { YT } from \"./tokens/YT.sol\";\nimport { Token } from \"./tokens/Token.sol\";\nimport { BaseAdapter as Adapter } from \"./adapters/BaseAdapter.sol\";\n\n/// @title Sense Divider: Divide Assets in Two\n/// @author fedealconada + jparklev\n/// @notice You can use this contract to issue, combine, and redeem Sense ERC20 Principal and Yield Tokens\ncontract Divider is Trust, ReentrancyGuard, Pausable {\n    using SafeTransferLib for ERC20;\n    using FixedMath for uint256;\n    using Levels for uint256;\n\n    /* ========== PUBLIC CONSTANTS ========== */\n\n    /// @notice Buffer before and after the actual maturity in which only the sponsor can settle the Series\n    uint256 public constant SPONSOR_WINDOW = 3 hours;\n\n    /// @notice Buffer after the sponsor window in which anyone can settle the Series\n    uint256 public constant SETTLEMENT_WINDOW = 3 hours;\n\n    /// @notice 5% issuance fee cap\n    uint256 public constant ISSUANCE_FEE_CAP = 0.05e18;\n\n    /* ========== PUBLIC MUTABLE STORAGE ========== */\n\n    address public periphery;\n\n    /// @notice Sense community multisig\n    address public immutable cup;\n\n    /// @notice Principal/Yield tokens deployer\n    address public immutable tokenHandler;\n\n    /// @notice Permissionless flag\n    bool public permissionless;\n\n    /// @notice Guarded launch flag\n    bool public guarded = true;\n\n    /// @notice Number of adapters (including turned off)\n    uint248 public adapterCounter;\n\n    /// @notice adapter ID -> adapter address\n    mapping(uint256 => address) public adapterAddresses;\n\n    /// @notice adapter data\n    mapping(address => AdapterMeta) public adapterMeta;\n\n    /// @notice adapter -> maturity -> Series\n    mapping(address => mapping(uint256 => Series)) public series;\n\n    /// @notice adapter -> maturity -> user -> lscale (last scale)\n    mapping(address => mapping(uint256 => mapping(address => uint256))) public lscales;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct Series {\n        // Principal ERC20 token\n        address pt;\n        // Timestamp of series initialization\n        uint48 issuance;\n        // Yield ERC20 token\n        address yt;\n        // % of underlying principal initially reserved for Yield\n        uint96 tilt;\n        // Actor who initialized the Series\n        address sponsor;\n        // Tracks fees due to the series' settler\n        uint256 reward;\n        // Scale at issuance\n        uint256 iscale;\n        // Scale at maturity\n        uint256 mscale;\n        // Max scale value from this series' lifetime\n        uint256 maxscale;\n    }\n\n    struct AdapterMeta {\n        // Adapter ID\n        uint248 id;\n        // Adapter enabled/disabled\n        bool enabled;\n        // Max amount of Target allowed to be issued\n        uint256 guard;\n        // Adapter level\n        uint248 level;\n    }\n\n    constructor(address _cup, address _tokenHandler) Trust(msg.sender) {\n        cup = _cup;\n        tokenHandler = _tokenHandler;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /// @notice Enable an adapter\n    /// @dev when permissionless is disabled, only the Periphery can onboard adapters\n    /// @dev after permissionless is enabled, anyone can onboard adapters\n    /// @param adapter Adapter's address\n    function addAdapter(address adapter) external whenNotPaused {\n        if (!permissionless && msg.sender != periphery) revert Errors.OnlyPermissionless();\n        if (adapterMeta[adapter].id > 0 && !adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        _setAdapter(adapter, true);\n    }\n\n    /// @notice Initializes a new Series\n    /// @dev Deploys two ERC20 contracts, one for PTs and the other one for YTs\n    /// @dev Transfers some fixed amount of stake asset to this contract\n    /// @param adapter Adapter to associate with the Series\n    /// @param maturity Maturity date for the new Series, in units of unix time\n    /// @param sponsor Sponsor of the Series that puts up a token stake and receives the issuance fees\n    function initSeries(\n        address adapter,\n        uint256 maturity,\n        address sponsor\n    ) external nonReentrant whenNotPaused returns (address pt, address yt) {\n        if (periphery != msg.sender) revert Errors.OnlyPeriphery();\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        if (_exists(adapter, maturity)) revert Errors.DuplicateSeries();\n        if (!_isValid(adapter, maturity)) revert Errors.InvalidMaturity();\n\n        // Transfer stake asset stake from caller to adapter\n        (address target, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n\n        // Deploy Principal & Yield Tokens for this new Series\n        (pt, yt) = TokenHandler(tokenHandler).deploy(adapter, adapterMeta[adapter].id, maturity);\n\n        // Initialize the new Series struct\n        uint256 scale = Adapter(adapter).scale();\n\n        series[adapter][maturity].pt = pt;\n        series[adapter][maturity].issuance = uint48(block.timestamp);\n        series[adapter][maturity].yt = yt;\n        series[adapter][maturity].tilt = uint96(Adapter(adapter).tilt());\n        series[adapter][maturity].sponsor = sponsor;\n        series[adapter][maturity].iscale = scale;\n        series[adapter][maturity].maxscale = scale;\n\n        ERC20(stake).safeTransferFrom(msg.sender, adapter, stakeSize);\n\n        emit SeriesInitialized(adapter, maturity, pt, yt, sponsor, target);\n    }\n\n    /// @notice Settles a Series and transfers the settlement reward to the caller\n    /// @dev The Series' sponsor has a grace period where only they can settle the Series\n    /// @dev After that, the reward becomes MEV\n    /// @param adapter Adapter to associate with the Series\n    /// @param maturity Maturity date for the new Series\n    function settleSeries(address adapter, uint256 maturity) external nonReentrant whenNotPaused {\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n        if (_settled(adapter, maturity)) revert Errors.AlreadySettled();\n        if (!_canBeSettled(adapter, maturity)) revert Errors.OutOfWindowBoundaries();\n\n        // The maturity scale value is all a Series needs for us to consider it \"settled\"\n        uint256 mscale = Adapter(adapter).scale();\n        series[adapter][maturity].mscale = mscale;\n\n        if (mscale > series[adapter][maturity].maxscale) {\n            series[adapter][maturity].maxscale = mscale;\n        }\n\n        // Reward the caller for doing the work of settling the Series at around the correct time\n        (address target, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n        ERC20(target).safeTransferFrom(adapter, msg.sender, series[adapter][maturity].reward);\n        ERC20(stake).safeTransferFrom(adapter, msg.sender, stakeSize);\n\n        emit SeriesSettled(adapter, maturity, msg.sender);\n    }\n\n    /// @notice Mint Principal & Yield Tokens of a specific Series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series [unix time]\n    /// @param tBal Balance of Target to deposit\n    /// @dev The balance of PTs and YTs minted will be the same value in units of underlying (less fees)\n    function issue(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal\n    ) external nonReentrant whenNotPaused returns (uint256 uBal) {\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n        if (_settled(adapter, maturity)) revert Errors.IssueOnSettle();\n\n        uint256 level = adapterMeta[adapter].level;\n        if (level.issueRestricted() && msg.sender != adapter) revert Errors.IssuanceRestricted();\n\n        ERC20 target = ERC20(Adapter(adapter).target());\n\n        // Take the issuance fee out of the deposited Target, and put it towards the settlement reward\n        uint256 issuanceFee = Adapter(adapter).ifee();\n        if (issuanceFee > ISSUANCE_FEE_CAP) revert Errors.IssuanceFeeCapExceeded();\n        uint256 fee = tBal.fmul(issuanceFee);\n\n        unchecked {\n            // Safety: bounded by the Target's total token supply\n            series[adapter][maturity].reward += fee;\n        }\n        uint256 tBalSubFee = tBal - fee;\n\n        // Ensure the caller won't hit the issuance cap with this action\n        unchecked {\n            // Safety: bounded by the Target's total token supply\n            if (guarded && target.balanceOf(adapter) + tBal > adapterMeta[address(adapter)].guard)\n                revert Errors.GuardCapReached();\n        }\n\n        // Update values on adapter\n        Adapter(adapter).notify(msg.sender, tBalSubFee, true);\n\n        uint256 scale = level.collectDisabled() ? series[adapter][maturity].iscale : Adapter(adapter).scale();\n\n        // Determine the amount of Underlying equal to the Target being sent in (the principal)\n        uBal = tBalSubFee.fmul(scale);\n\n        // If the caller has not collected on YT before, use the current scale, otherwise\n        // use the harmonic mean of the last and the current scale value\n        lscales[adapter][maturity][msg.sender] = lscales[adapter][maturity][msg.sender] == 0\n            ? scale\n            : _reweightLScale(\n                adapter,\n                maturity,\n                YT(series[adapter][maturity].yt).balanceOf(msg.sender),\n                uBal,\n                msg.sender,\n                scale\n            );\n\n        // Mint equal amounts of PT and YT\n        Token(series[adapter][maturity].pt).mint(msg.sender, uBal);\n        YT(series[adapter][maturity].yt).mint(msg.sender, uBal);\n\n        target.safeTransferFrom(msg.sender, adapter, tBal);\n\n        emit Issued(adapter, maturity, uBal, msg.sender);\n    }\n\n    /// @notice Reconstitute Target by burning PT and YT\n    /// @dev Explicitly burns YTs before maturity, and implicitly does it at/after maturity through `_collect()`\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal Balance of PT and YT to burn\n    function combine(\n        address adapter,\n        uint256 maturity,\n        uint256 uBal\n    ) external nonReentrant whenNotPaused returns (uint256 tBal) {\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n\n        uint256 level = adapterMeta[adapter].level;\n        if (level.combineRestricted() && msg.sender != adapter) revert Errors.CombineRestricted();\n\n        // Burn the PT\n        Token(series[adapter][maturity].pt).burn(msg.sender, uBal);\n\n        // Collect whatever excess is due\n        uint256 collected = _collect(msg.sender, adapter, maturity, uBal, uBal, address(0));\n\n        uint256 cscale = series[adapter][maturity].mscale;\n        bool settled = _settled(adapter, maturity);\n        if (!settled) {\n            // If it's not settled, then YT won't be burned automatically in `_collect()`\n            YT(series[adapter][maturity].yt).burn(msg.sender, uBal);\n            // If collect has been restricted, use the initial scale, otherwise use the current scale\n            cscale = level.collectDisabled()\n                ? series[adapter][maturity].iscale\n                : lscales[adapter][maturity][msg.sender];\n        }\n\n        // Convert from units of Underlying to units of Target\n        tBal = uBal.fdiv(cscale);\n        ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, msg.sender, tBal);\n\n        // Notify only when Series is not settled as when it is, the _collect() call above would trigger a _redeemYT which will call notify\n        if (!settled) Adapter(adapter).notify(msg.sender, tBal, false);\n        unchecked {\n            // Safety: bounded by the Target's total token supply\n            tBal += collected;\n        }\n        emit Combined(adapter, maturity, tBal, msg.sender);\n    }\n\n    /// @notice Burn PT of a Series once it's been settled\n    /// @dev The balance of redeemable Target is a function of the change in Scale\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal Amount of PT to burn, which should be equivalent to the amount of Underlying owed to the caller\n    function redeem(\n        address adapter,\n        uint256 maturity,\n        uint256 uBal\n    ) external nonReentrant whenNotPaused returns (uint256 tBal) {\n        // If a Series is settled, we know that it must have existed as well, so that check is unnecessary\n        if (!_settled(adapter, maturity)) revert Errors.NotSettled();\n\n        uint256 level = adapterMeta[adapter].level;\n        if (level.redeemRestricted() && msg.sender == adapter) revert Errors.RedeemRestricted();\n\n        // Burn the caller's PT\n        Token(series[adapter][maturity].pt).burn(msg.sender, uBal);\n\n        // Principal Token holder's share of the principal = (1 - part of the principal that belongs to Yield)\n        uint256 zShare = FixedMath.WAD - series[adapter][maturity].tilt;\n\n        // If Principal Token are at a loss and Yield have some principal to help cover the shortfall,\n        // take what we can from Yield Token's principal\n        if (series[adapter][maturity].mscale.fdiv(series[adapter][maturity].maxscale) >= zShare) {\n            tBal = (uBal * zShare) / series[adapter][maturity].mscale;\n        } else {\n            tBal = uBal.fdiv(series[adapter][maturity].maxscale);\n        }\n\n        if (!level.redeemHookDisabled()) {\n            Adapter(adapter).onRedeem(uBal, series[adapter][maturity].mscale, series[adapter][maturity].maxscale, tBal);\n        }\n\n        ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, msg.sender, tBal);\n        emit PTRedeemed(adapter, maturity, tBal);\n    }\n\n    function collect(\n        address usr,\n        address adapter,\n        uint256 maturity,\n        uint256 uBalTransfer,\n        address to\n    ) external nonReentrant onlyYT(adapter, maturity) whenNotPaused returns (uint256 collected) {\n        uint256 uBal = YT(msg.sender).balanceOf(usr);\n        return _collect(usr, adapter, maturity, uBal, uBalTransfer > 0 ? uBalTransfer : uBal, to);\n    }\n\n    /// @notice Collect YT excess before, at, or after maturity\n    /// @dev If `to` is set, we copy the lscale value from usr to this address\n    /// @param usr User who's collecting for their YTs\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal yield Token balance\n    /// @param uBalTransfer original transfer value\n    /// @param to address to set the lscale value from usr\n    function _collect(\n        address usr,\n        address adapter,\n        uint256 maturity,\n        uint256 uBal,\n        uint256 uBalTransfer,\n        address to\n    ) internal returns (uint256 collected) {\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n\n        // If the adapter is disabled, its Yield Token can only collect\n        // if associated Series has been settled, which implies that an admin\n        // has backfilled it\n        if (!adapterMeta[adapter].enabled && !_settled(adapter, maturity)) revert Errors.InvalidAdapter();\n\n        Series memory _series = series[adapter][maturity];\n\n        // Get the scale value from the last time this holder collected (default to maturity)\n        uint256 lscale = lscales[adapter][maturity][usr];\n\n        uint256 level = adapterMeta[adapter].level;\n        if (level.collectDisabled()) {\n            // If this Series has been settled, we ensure everyone's YT will\n            // collect yield accrued since issuance\n            if (_settled(adapter, maturity)) {\n                lscale = series[adapter][maturity].iscale;\n                // If the Series is not settled, we ensure no collections can happen\n            } else {\n                return 0;\n            }\n        }\n\n        // If the Series has been settled, this should be their last collect, so redeem the user's Yield Tokens for them\n        if (_settled(adapter, maturity)) {\n            _redeemYT(usr, adapter, maturity, uBal);\n        } else {\n            // If we're not settled and we're past maturity + the sponsor window,\n            // anyone can settle this Series so revert until someone does\n            if (block.timestamp > maturity + SPONSOR_WINDOW) {\n                revert Errors.CollectNotSettled();\n                // Otherwise, this is a valid pre-settlement collect and we need to determine the scale value\n            } else {\n                uint256 cscale = Adapter(adapter).scale();\n                // If this is larger than the largest scale we've seen for this Series, use it\n                if (cscale > _series.maxscale) {\n                    _series.maxscale = cscale;\n                    lscales[adapter][maturity][usr] = cscale;\n                    // If not, use the previously noted max scale value\n                } else {\n                    lscales[adapter][maturity][usr] = _series.maxscale;\n                }\n            }\n        }\n\n        // Determine how much underlying has accrued since the last time this user collected, in units of Target.\n        // (Or take the last time as issuance if they haven't yet)\n        //\n        // Reminder: `Underlying / Scale = Target`\n        // So the following equation is saying, for some amount of Underlying `u`:\n        // \"Balance of Target that equaled `u` at the last collection _minus_ Target that equals `u` now\"\n        //\n        // Because maxscale must be increasing, the Target balance needed to equal `u` decreases, and that \"excess\"\n        // is what Yield holders are collecting\n        uint256 tBalNow = uBal.fdivUp(_series.maxscale); // preventive round-up towards the protocol\n        uint256 tBalPrev = uBal.fdiv(lscale);\n        unchecked {\n            collected = tBalPrev > tBalNow ? tBalPrev - tBalNow : 0;\n        }\n        ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, usr, collected);\n        Adapter(adapter).notify(usr, collected, false); // Distribute reward tokens\n\n        // If this collect is a part of a token transfer to another address, set the receiver's\n        // last collection to a synthetic scale weighted based on the scale on their last collect,\n        // the time elapsed, and the current scale\n        if (to != address(0)) {\n            uint256 ytBal = YT(_series.yt).balanceOf(to);\n            // If receiver holds yields, we set lscale to a computed \"synthetic\" lscales value that,\n            // for the updated yield balance, still assigns the correct amount of yield.\n            lscales[adapter][maturity][to] = ytBal > 0\n                ? _reweightLScale(adapter, maturity, ytBal, uBalTransfer, to, _series.maxscale)\n                : _series.maxscale;\n            uint256 tBalTransfer = uBalTransfer.fdiv(_series.maxscale);\n            Adapter(adapter).notify(usr, tBalTransfer, false);\n            Adapter(adapter).notify(to, tBalTransfer, true);\n        }\n        series[adapter][maturity] = _series;\n\n        emit Collected(adapter, maturity, collected);\n    }\n\n    /// @notice calculate the harmonic mean of the current scale and the last scale,\n    /// weighted by amounts associated with each\n    function _reweightLScale(\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal,\n        uint256 uBal,\n        address receiver,\n        uint256 scale\n    ) internal view returns (uint256) {\n        // Target Decimals * 18 Decimals [from fdiv] / (Target Decimals * 18 Decimals [from fdiv] / 18 Decimals)\n        // = 18 Decimals, which is the standard for scale values\n        return (ytBal + uBal).fdiv((ytBal.fdiv(lscales[adapter][maturity][receiver]) + uBal.fdiv(scale)));\n    }\n\n    function _redeemYT(\n        address usr,\n        address adapter,\n        uint256 maturity,\n        uint256 uBal\n    ) internal {\n        // Burn the users's YTs\n        YT(series[adapter][maturity].yt).burn(usr, uBal);\n\n        // Default principal for a YT\n        uint256 tBal = 0;\n\n        // Principal Token holder's share of the principal = (1 - part of the principal that belongs to Yield Tokens)\n        uint256 zShare = FixedMath.WAD - series[adapter][maturity].tilt;\n\n        // If PTs are at a loss and YTs had their principal cut to help cover the shortfall,\n        // calculate how much YTs have left\n        if (series[adapter][maturity].mscale.fdiv(series[adapter][maturity].maxscale) >= zShare) {\n            tBal = uBal.fdiv(series[adapter][maturity].maxscale) - (uBal * zShare) / series[adapter][maturity].mscale;\n            ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, usr, tBal);\n        }\n\n        // Always notify the Adapter of the full Target balance that will no longer\n        // have its rewards distributed\n        Adapter(adapter).notify(usr, uBal.fdivUp(series[adapter][maturity].maxscale), false);\n\n        emit YTRedeemed(adapter, maturity, tBal);\n    }\n\n    /* ========== ADMIN ========== */\n\n    /// @notice Enable or disable a adapter\n    /// @param adapter Adapter's address\n    /// @param isOn Flag setting this adapter to enabled or disabled\n    function setAdapter(address adapter, bool isOn) public requiresTrust {\n        _setAdapter(adapter, isOn);\n    }\n\n    /// @notice Set adapter's guard\n    /// @param adapter Adapter address\n    /// @param cap The max target that can be deposited on the Adapter\n    function setGuard(address adapter, uint256 cap) external requiresTrust {\n        adapterMeta[adapter].guard = cap;\n        emit GuardChanged(adapter, cap);\n    }\n\n    /// @notice Set guarded mode\n    /// @param _guarded bool\n    function setGuarded(bool _guarded) external requiresTrust {\n        guarded = _guarded;\n        emit GuardedChanged(_guarded);\n    }\n\n    /// @notice Set periphery's contract\n    /// @param _periphery Target address\n    function setPeriphery(address _periphery) external requiresTrust {\n        periphery = _periphery;\n        emit PeripheryChanged(_periphery);\n    }\n\n    /// @notice Set paused flag\n    /// @param _paused boolean\n    function setPaused(bool _paused) external requiresTrust {\n        _paused ? _pause() : _unpause();\n    }\n\n    /// @notice Set permissioless mode\n    /// @param _permissionless bool\n    function setPermissionless(bool _permissionless) external requiresTrust {\n        permissionless = _permissionless;\n        emit PermissionlessChanged(_permissionless);\n    }\n\n    /// @notice Backfill a Series' Scale value at maturity if keepers failed to settle it\n    /// @param adapter Adapter's address\n    /// @param maturity Maturity date for the Series\n    /// @param mscale Value to set as the Series' Scale value at maturity\n    /// @param _usrs Values to set on lscales mapping\n    /// @param _lscales Values to set on lscales mapping\n    function backfillScale(\n        address adapter,\n        uint256 maturity,\n        uint256 mscale,\n        address[] calldata _usrs,\n        uint256[] calldata _lscales\n    ) external requiresTrust {\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n\n        uint256 cutoff = maturity + SPONSOR_WINDOW + SETTLEMENT_WINDOW;\n        // Admin can never backfill before maturity\n        if (block.timestamp <= cutoff) revert Errors.OutOfWindowBoundaries();\n\n        // Set user's last scale values the Series (needed for the `collect` method)\n        for (uint256 i = 0; i < _usrs.length; i++) {\n            lscales[adapter][maturity][_usrs[i]] = _lscales[i];\n        }\n\n        if (mscale > 0) {\n            Series memory _series = series[adapter][maturity];\n            // Set the maturity scale for the Series (needed for `redeem` methods)\n            series[adapter][maturity].mscale = mscale;\n            if (mscale > _series.maxscale) {\n                series[adapter][maturity].maxscale = mscale;\n            }\n\n            (address target, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n\n            address stakeDst = adapterMeta[adapter].enabled ? cup : _series.sponsor;\n            ERC20(target).safeTransferFrom(adapter, cup, _series.reward);\n            series[adapter][maturity].reward = 0;\n            ERC20(stake).safeTransferFrom(adapter, stakeDst, stakeSize);\n        }\n\n        emit Backfilled(adapter, maturity, mscale, _usrs, _lscales);\n    }\n\n    /* ========== INTERNAL VIEWS ========== */\n\n    function _exists(address adapter, uint256 maturity) internal view returns (bool) {\n        return series[adapter][maturity].pt != address(0);\n    }\n\n    function _settled(address adapter, uint256 maturity) internal view returns (bool) {\n        return series[adapter][maturity].mscale > 0;\n    }\n\n    function _canBeSettled(address adapter, uint256 maturity) internal view returns (bool) {\n        uint256 cutoff = maturity + SPONSOR_WINDOW + SETTLEMENT_WINDOW;\n        // If the sender is the sponsor for the Series\n        if (msg.sender == series[adapter][maturity].sponsor) {\n            return maturity - SPONSOR_WINDOW <= block.timestamp && cutoff >= block.timestamp;\n        } else {\n            return maturity + SPONSOR_WINDOW < block.timestamp && cutoff >= block.timestamp;\n        }\n    }\n\n    function _isValid(address adapter, uint256 maturity) internal view returns (bool) {\n        (uint256 minm, uint256 maxm) = Adapter(adapter).getMaturityBounds();\n        if (maturity < block.timestamp + minm || maturity > block.timestamp + maxm) return false;\n        (, , uint256 day, uint256 hour, uint256 minute, uint256 second) = DateTime.timestampToDateTime(maturity);\n\n        if (hour != 0 || minute != 0 || second != 0) return false;\n        uint256 mode = Adapter(adapter).mode();\n        if (mode == 0) {\n            return day == 1;\n        }\n        if (mode == 1) {\n            return DateTime.getDayOfWeek(maturity) == 1;\n        }\n        return false;\n    }\n\n    /* ========== INTERNAL UTILS ========== */\n\n    function _setAdapter(address adapter, bool isOn) internal {\n        AdapterMeta memory am = adapterMeta[adapter];\n        if (am.enabled == isOn) revert Errors.ExistingValue();\n        am.enabled = isOn;\n\n        // If this adapter is being added for the first time\n        if (isOn && am.id == 0) {\n            am.id = ++adapterCounter;\n            adapterAddresses[am.id] = adapter;\n        }\n\n        // Set level and target (can only be done once);\n        am.level = uint248(Adapter(adapter).level());\n        adapterMeta[adapter] = am;\n        emit AdapterChanged(adapter, am.id, isOn);\n    }\n\n    /* ========== PUBLIC GETTERS ========== */\n\n    /// @notice Returns address of Principal Token\n    function pt(address adapter, uint256 maturity) public view returns (address) {\n        return series[adapter][maturity].pt;\n    }\n\n    /// @notice Returns address of Yield Token\n    function yt(address adapter, uint256 maturity) public view returns (address) {\n        return series[adapter][maturity].yt;\n    }\n\n    function mscale(address adapter, uint256 maturity) public view returns (uint256) {\n        return series[adapter][maturity].mscale;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyYT(address adapter, uint256 maturity) {\n        if (series[adapter][maturity].yt != msg.sender) revert Errors.OnlyYT();\n        _;\n    }\n\n    /* ========== LOGS ========== */\n\n    /// @notice Admin\n    event Backfilled(\n        address indexed adapter,\n        uint256 indexed maturity,\n        uint256 mscale,\n        address[] _usrs,\n        uint256[] _lscales\n    );\n    event GuardChanged(address indexed adapter, uint256 cap);\n    event AdapterChanged(address indexed adapter, uint256 indexed id, bool indexed isOn);\n    event PeripheryChanged(address indexed periphery);\n\n    /// @notice Series lifecycle\n    /// *---- beginning\n    event SeriesInitialized(\n        address adapter,\n        uint256 indexed maturity,\n        address pt,\n        address yt,\n        address indexed sponsor,\n        address indexed target\n    );\n    /// -***- middle\n    event Issued(address indexed adapter, uint256 indexed maturity, uint256 balance, address indexed sender);\n    event Combined(address indexed adapter, uint256 indexed maturity, uint256 balance, address indexed sender);\n    event Collected(address indexed adapter, uint256 indexed maturity, uint256 collected);\n    /// ----* end\n    event SeriesSettled(address indexed adapter, uint256 indexed maturity, address indexed settler);\n    event PTRedeemed(address indexed adapter, uint256 indexed maturity, uint256 redeemed);\n    event YTRedeemed(address indexed adapter, uint256 indexed maturity, uint256 redeemed);\n    /// *----* misc\n    event GuardedChanged(bool indexed guarded);\n    event PermissionlessChanged(bool indexed permissionless);\n}\n\ncontract TokenHandler is Trust {\n    /// @notice Program state\n    address public divider;\n\n    constructor() Trust(msg.sender) {}\n\n    function init(address _divider) external requiresTrust {\n        if (divider != address(0)) revert Errors.AlreadyInitialized();\n        divider = _divider;\n    }\n\n    function deploy(\n        address adapter,\n        uint248 id,\n        uint256 maturity\n    ) external returns (address pt, address yt) {\n        if (msg.sender != divider) revert Errors.OnlyDivider();\n\n        ERC20 target = ERC20(Adapter(adapter).target());\n        uint8 decimals = target.decimals();\n        string memory symbol = target.symbol();\n        (string memory d, string memory m, string memory y) = DateTime.toDateString(maturity);\n        string memory date = DateTime.format(maturity);\n        string memory datestring = string(abi.encodePacked(d, \"-\", m, \"-\", y));\n        string memory adapterId = DateTime.uintToString(id);\n        pt = address(\n            new Token(\n                string(abi.encodePacked(date, \" \", symbol, \" Sense Principal Token, A\", adapterId)),\n                string(abi.encodePacked(\"sP-\", symbol, \":\", datestring, \":\", adapterId)),\n                decimals,\n                divider\n            )\n        );\n\n        yt = address(\n            new YT(\n                adapter,\n                maturity,\n                string(abi.encodePacked(date, \" \", symbol, \" Sense Yield Token, A\", adapterId)),\n                string(abi.encodePacked(\"sY-\", symbol, \":\", datestring, \":\", adapterId)),\n                decimals,\n                divider\n            )\n        );\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/Periphery.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport { FixedMath } from \"./external/FixedMath.sol\";\nimport { BalancerVault, IAsset } from \"./external/balancer/Vault.sol\";\nimport { BalancerPool } from \"./external/balancer/Pool.sol\";\nimport { IERC3156FlashBorrower } from \"./external/flashloan/IERC3156FlashBorrower.sol\";\n\n// Internal references\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { Levels } from \"@sense-finance/v1-utils/src/libs/Levels.sol\";\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { BaseAdapter as Adapter } from \"./adapters/BaseAdapter.sol\";\nimport { BaseFactory as AdapterFactory } from \"./adapters/BaseFactory.sol\";\nimport { Divider } from \"./Divider.sol\";\nimport { PoolManager } from \"@sense-finance/v1-fuse/src/PoolManager.sol\";\n\ninterface SpaceFactoryLike {\n    function create(address, uint256) external returns (address);\n\n    function pools(address adapter, uint256 maturity) external view returns (address);\n}\n\n/// @title Periphery\ncontract Periphery is Trust, IERC3156FlashBorrower {\n    using FixedMath for uint256;\n    using SafeTransferLib for ERC20;\n    using Levels for uint256;\n\n    /* ========== PUBLIC CONSTANTS ========== */\n\n    /// @notice Lower bound on the amount of Claim tokens one can swap in for Target\n    uint256 public constant MIN_YT_SWAP_IN = 0.000001e18;\n\n    /// @notice Acceptable error when estimating the tokens resulting from a specific swap\n    uint256 public constant PRICE_ESTIMATE_ACCEPTABLE_ERROR = 0.00000001e18;\n\n    /* ========== PUBLIC IMMUTABLES ========== */\n\n    /// @notice Sense core Divider address\n    Divider public immutable divider;\n\n    /// @notice Sense core Divider address\n    PoolManager public immutable poolManager;\n\n    /// @notice Sense core Divider address\n    SpaceFactoryLike public immutable spaceFactory;\n\n    /// @notice Sense core Divider address\n    BalancerVault public immutable balancerVault;\n\n    /* ========== PUBLIC MUTABLE STORAGE ========== */\n\n    /// @notice adapter factories -> is supported\n    mapping(address => bool) public factories;\n\n    /// @notice adapter -> bool\n    mapping(address => bool) public verified;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct PoolLiquidity {\n        ERC20[] tokens;\n        uint256[] amounts;\n        uint256 minBptOut;\n    }\n\n    constructor(\n        address _divider,\n        address _poolManager,\n        address _spaceFactory,\n        address _balancerVault\n    ) Trust(msg.sender) {\n        divider = Divider(_divider);\n        poolManager = PoolManager(_poolManager);\n        spaceFactory = SpaceFactoryLike(_spaceFactory);\n        balancerVault = BalancerVault(_balancerVault);\n    }\n\n    /* ========== SERIES / ADAPTER MANAGEMENT ========== */\n\n    /// @notice Sponsor a new Series in any adapter previously onboarded onto the Divider\n    /// @dev Called by an external address, initializes a new series in the Divider\n    /// @param adapter Adapter to associate with the Series\n    /// @param maturity Maturity date for the Series, in units of unix time\n    /// @param withPool Whether to deploy a Space pool or not (only works for unverified adapters)\n    function sponsorSeries(\n        address adapter,\n        uint256 maturity,\n        bool withPool\n    ) external returns (address pt, address yt) {\n        (, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n\n        // Transfer stakeSize from sponsor into this contract\n        ERC20(stake).safeTransferFrom(msg.sender, address(this), stakeSize);\n\n        // Approve divider to withdraw stake assets\n        ERC20(stake).approve(address(divider), stakeSize);\n\n        (pt, yt) = divider.initSeries(adapter, maturity, msg.sender);\n\n        // Space pool is always created for verified adapters whilst is optional for unverified ones.\n        // Automatically queueing series is only for verified adapters\n        if (verified[adapter]) {\n            poolManager.queueSeries(adapter, maturity, spaceFactory.create(adapter, maturity));\n        } else {\n            if (withPool) {\n                spaceFactory.create(adapter, maturity);\n            }\n        }\n        emit SeriesSponsored(adapter, maturity, msg.sender);\n    }\n\n    /// @notice Deploy and onboard a Adapter\n    /// @dev Called by external address, deploy a new Adapter via an Adapter Factory\n    /// @param f Factory to use\n    /// @param target Target to onboard\n    function deployAdapter(address f, address target) external returns (address adapter) {\n        if (!factories[f]) revert Errors.FactoryNotSupported();\n        if (!AdapterFactory(f).exists(target)) revert Errors.TargetNotSupported();\n        adapter = AdapterFactory(f).deployAdapter(target);\n        emit AdapterDeployed(adapter);\n        _verifyAdapter(adapter, true);\n        _onboardAdapter(adapter, true);\n    }\n\n    /* ========== LIQUIDITY UTILS ========== */\n\n    /// @notice Swap Target to Principal Tokens of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param tBal Balance of Target to sell\n    /// @param minAccepted Min accepted amount of PT\n    /// @return ptBal amount of PT received\n    function swapTargetForPTs(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal,\n        uint256 minAccepted\n    ) external returns (uint256 ptBal) {\n        ERC20(Adapter(adapter).target()).safeTransferFrom(msg.sender, address(this), tBal); // pull target\n        return _swapTargetForPTs(adapter, maturity, tBal, minAccepted);\n    }\n\n    /// @notice Swap Underlying to Principal Tokens of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal Balance of Underlying to sell\n    /// @param minAccepted Min accepted amount of PT\n    /// @return ptBal amount of PT received\n    function swapUnderlyingForPTs(\n        address adapter,\n        uint256 maturity,\n        uint256 uBal,\n        uint256 minAccepted\n    ) external returns (uint256 ptBal) {\n        ERC20 underlying = ERC20(Adapter(adapter).underlying());\n        underlying.safeTransferFrom(msg.sender, address(this), uBal); // pull underlying\n        uint256 tBal = Adapter(adapter).wrapUnderlying(uBal); // wrap underlying into target\n        ptBal = _swapTargetForPTs(adapter, maturity, tBal, minAccepted);\n    }\n\n    /// @notice Swap Target to Yield Tokens of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param tBal Balance of Target to sell\n    /// @param minAccepted Min accepted amount of YT\n    /// @return ytBal amount of YT received\n    function swapTargetForYTs(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal,\n        uint256 minAccepted\n    ) external returns (uint256 ytBal) {\n        ERC20(Adapter(adapter).target()).safeTransferFrom(msg.sender, address(this), tBal);\n        ytBal = _swapTargetForYTs(adapter, maturity, tBal, minAccepted);\n    }\n\n    /// @notice Swap Underlying to Yield of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal Balance of Underlying to sell\n    /// @param minAccepted Min accepted amount of YT\n    /// @return ytBal amount of YT received\n    function swapUnderlyingForYTs(\n        address adapter,\n        uint256 maturity,\n        uint256 uBal,\n        uint256 minAccepted\n    ) external returns (uint256 ytBal) {\n        ERC20 underlying = ERC20(Adapter(adapter).underlying());\n        underlying.safeTransferFrom(msg.sender, address(this), uBal); // pull target\n        uint256 tBal = Adapter(adapter).wrapUnderlying(uBal); // wrap underlying into target\n        ytBal = _swapTargetForYTs(adapter, maturity, tBal, minAccepted);\n    }\n\n    /// @notice Swap Principal Tokens for Target of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param ptBal Balance of PT to sell\n    /// @param minAccepted Min accepted amount of Target\n    function swapPTsForTarget(\n        address adapter,\n        uint256 maturity,\n        uint256 ptBal,\n        uint256 minAccepted\n    ) external returns (uint256 tBal) {\n        tBal = _swapPTsForTarget(adapter, maturity, ptBal, minAccepted); // swap Principal Tokens for target\n        ERC20(Adapter(adapter).target()).safeTransfer(msg.sender, tBal); // transfer target to msg.sender\n    }\n\n    /// @notice Swap Principal Tokens for Underlying of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param ptBal Balance of PT to sell\n    /// @param minAccepted Min accepted amount of Target\n    function swapPTsForUnderlying(\n        address adapter,\n        uint256 maturity,\n        uint256 ptBal,\n        uint256 minAccepted\n    ) external returns (uint256 uBal) {\n        uint256 tBal = _swapPTsForTarget(adapter, maturity, ptBal, minAccepted); // swap Principal Tokens for target\n        uBal = Adapter(adapter).unwrapTarget(tBal); // unwrap target into underlying\n        ERC20(Adapter(adapter).underlying()).safeTransfer(msg.sender, uBal); // transfer underlying to msg.sender\n    }\n\n    /// @notice Swap YT for Target of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param ytBal Balance of Yield Tokens to swap\n    function swapYTsForTarget(\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal\n    ) external returns (uint256 tBal) {\n        tBal = _swapYTsForTarget(msg.sender, adapter, maturity, ytBal);\n        ERC20(Adapter(adapter).target()).safeTransfer(msg.sender, tBal);\n    }\n\n    /// @notice Swap YT for Underlying of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param ytBal Balance of Yield Tokens to swap\n    function swapYTsForUnderlying(\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal\n    ) external returns (uint256 uBal) {\n        uint256 tBal = _swapYTsForTarget(msg.sender, adapter, maturity, ytBal);\n        uBal = Adapter(adapter).unwrapTarget(tBal);\n        ERC20(Adapter(adapter).underlying()).safeTransfer(msg.sender, uBal);\n    }\n\n    /// @notice Adds liquidity providing target\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param tBal Balance of Target to provide\n    /// @param mode 0 = issues and sell YT, 1 = issue and hold YT\n    /// @param minBptOut Minimum BPT the user will accept out for this transaction\n    /// @dev see return description of _addLiquidity\n    function addLiquidityFromTarget(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal,\n        uint8 mode,\n        uint256 minBptOut\n    )\n        external\n        returns (\n            uint256 tAmount,\n            uint256 issued,\n            uint256 lpShares\n        )\n    {\n        ERC20(Adapter(adapter).target()).safeTransferFrom(msg.sender, address(this), tBal);\n        (tAmount, issued, lpShares) = _addLiquidity(adapter, maturity, tBal, mode, minBptOut);\n    }\n\n    /// @notice Adds liquidity providing underlying\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal Balance of Underlying to provide\n    /// @param mode 0 = issues and sell YT, 1 = issue and hold YT\n    /// @param minBptOut Minimum BPT the user will accept out for this transaction\n    /// @dev see return description of _addLiquidity\n    function addLiquidityFromUnderlying(\n        address adapter,\n        uint256 maturity,\n        uint256 uBal,\n        uint8 mode,\n        uint256 minBptOut\n    )\n        external\n        returns (\n            uint256 tAmount,\n            uint256 issued,\n            uint256 lpShares\n        )\n    {\n        ERC20 underlying = ERC20(Adapter(adapter).underlying());\n        underlying.safeTransferFrom(msg.sender, address(this), uBal);\n        // Wrap Underlying into Target\n        uint256 tBal = Adapter(adapter).wrapUnderlying(uBal);\n        (tAmount, issued, lpShares) = _addLiquidity(adapter, maturity, tBal, mode, minBptOut);\n    }\n\n    /// @notice Removes liquidity providing an amount of LP tokens and returns target\n    /// @dev More info on `minAmountsOut`: https://github.com/balancer-labs/docs-developers/blob/main/resources/joins-and-exits/pool-exits.md#minamountsout\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param lpBal Balance of LP tokens to provide\n    /// @param minAmountsOut minimum accepted amounts of PTs and Target given the amount of LP shares provided\n    /// @param minAccepted only used when removing liquidity on/after maturity and its the min accepted when swapping Principal Tokens to underlying\n    /// @param intoTarget if true, it will try to swap PTs into Target. Will revert if there's not enough liquidity to perform the swap.\n    /// @return tBal amount of target received and ptBal amount of Principal Tokens (in case it's called after maturity and redeem is restricted)\n    function removeLiquidity(\n        address adapter,\n        uint256 maturity,\n        uint256 lpBal,\n        uint256[] memory minAmountsOut,\n        uint256 minAccepted,\n        bool intoTarget\n    ) external returns (uint256 tBal, uint256 ptBal) {\n        (tBal, ptBal) = _removeLiquidity(adapter, maturity, lpBal, minAmountsOut, minAccepted, intoTarget);\n        ERC20(Adapter(adapter).target()).safeTransfer(msg.sender, tBal); // Send Target back to the User\n    }\n\n    /// @notice Removes liquidity providing an amount of LP tokens and returns underlying\n    /// @dev More info on `minAmountsOut`: https://github.com/balancer-labs/docs-developers/blob/main/resources/joins-and-exits/pool-exits.md#minamountsout\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param lpBal Balance of LP tokens to provide\n    /// @param minAmountsOut minimum accepted amounts of PTs and Target given the amount of LP shares provided\n    /// @param minAccepted only used when removing liquidity on/after maturity and its the min accepted when swapping Principal Tokens to underlying\n    /// @param intoTarget if true, it will try to swap PTs into Target. Will revert if there's not enough liquidity to perform the swap.\n    /// @return uBal amount of underlying received and ptBal Principal Tokens (in case it's called after maturity and redeem is restricted or intoTarget is false)\n    function removeLiquidityAndUnwrapTarget(\n        address adapter,\n        uint256 maturity,\n        uint256 lpBal,\n        uint256[] memory minAmountsOut,\n        uint256 minAccepted,\n        bool intoTarget\n    ) external returns (uint256 uBal, uint256 ptBal) {\n        uint256 tBal;\n        (tBal, ptBal) = _removeLiquidity(adapter, maturity, lpBal, minAmountsOut, minAccepted, intoTarget);\n        ERC20(Adapter(adapter).underlying()).safeTransfer(msg.sender, uBal = Adapter(adapter).unwrapTarget(tBal)); // Send Underlying back to the User\n    }\n\n    /// @notice Migrates liquidity position from one series to another\n    /// @dev More info on `minAmountsOut`: https://github.com/balancer-labs/docs-developers/blob/main/resources/joins-and-exits/pool-exits.md#minamountsout\n    /// @param srcAdapter Adapter address for the source Series\n    /// @param dstAdapter Adapter address for the destination Series\n    /// @param srcMaturity Maturity date for the source Series\n    /// @param dstMaturity Maturity date for the destination Series\n    /// @param lpBal Balance of LP tokens to provide\n    /// @param minAmountsOut Minimum accepted amounts of PTs and Target given the amount of LP shares provided\n    /// @param minAccepted Min accepted amount of target when swapping Principal Tokens (only used when removing liquidity on/after maturity)\n    /// @param mode 0 = issues and sell YT, 1 = issue and hold YT\n    /// @param intoTarget if true, it will try to swap PTs into Target. Will revert if there's not enough liquidity to perform the swap\n    /// @param minBptOut Minimum BPT the user will accept out for this transaction\n    /// @dev see return description of _addLiquidity. It also returns amount of PTs (in case it's called after maturity and redeem is restricted or inttoTarget is false)\n    function migrateLiquidity(\n        address srcAdapter,\n        address dstAdapter,\n        uint256 srcMaturity,\n        uint256 dstMaturity,\n        uint256 lpBal,\n        uint256[] memory minAmountsOut,\n        uint256 minAccepted,\n        uint8 mode,\n        bool intoTarget,\n        uint256 minBptOut\n    )\n        external\n        returns (\n            uint256 tAmount,\n            uint256 issued,\n            uint256 lpShares,\n            uint256 ptBal\n        )\n    {\n        if (Adapter(srcAdapter).target() != Adapter(dstAdapter).target()) revert Errors.TargetMismatch();\n        uint256 tBal;\n        (tBal, ptBal) = _removeLiquidity(srcAdapter, srcMaturity, lpBal, minAmountsOut, minAccepted, intoTarget);\n        (tAmount, issued, lpShares) = _addLiquidity(dstAdapter, dstMaturity, tBal, mode, minBptOut);\n    }\n\n    /* ========== ADMIN ========== */\n\n    /// @notice Enable or disable a factory\n    /// @param f Factory's address\n    /// @param isOn Flag setting this factory to enabled or disabled\n    function setFactory(address f, bool isOn) external requiresTrust {\n        if (factories[f] == isOn) revert Errors.ExistingValue();\n        factories[f] = isOn;\n        emit FactoryChanged(f, isOn);\n    }\n\n    /// @dev Verifies an Adapter and optionally adds the Target to the money market\n    /// @param adapter Adapter to verify\n    function verifyAdapter(address adapter, bool addToPool) public requiresTrust {\n        _verifyAdapter(adapter, addToPool);\n    }\n\n    function _verifyAdapter(address adapter, bool addToPool) private {\n        verified[adapter] = true;\n        if (addToPool) poolManager.addTarget(Adapter(adapter).target(), adapter);\n        emit AdapterVerified(adapter);\n    }\n\n    /// @notice Onboard a single Adapter w/o needing a factory\n    /// @dev Called by a trusted address, approves Target for issuance, and onboards adapter to the Divider\n    /// @param adapter Adapter to onboard\n    /// @param addAdapter Whether to call divider.addAdapter or not (useful e.g when upgrading Periphery)\n    function onboardAdapter(address adapter, bool addAdapter) public {\n        if (!divider.permissionless() && !isTrusted[msg.sender]) revert Errors.OnlyPermissionless();\n        _onboardAdapter(adapter, addAdapter);\n    }\n\n    function _onboardAdapter(address adapter, bool addAdapter) private {\n        ERC20 target = ERC20(Adapter(adapter).target());\n        target.approve(address(divider), type(uint256).max);\n        target.approve(address(adapter), type(uint256).max);\n        ERC20(Adapter(adapter).underlying()).approve(address(adapter), type(uint256).max);\n        if (addAdapter) divider.addAdapter(adapter);\n        emit AdapterOnboarded(adapter);\n    }\n\n    /* ========== INTERNAL UTILS ========== */\n\n    function _swap(\n        address assetIn,\n        address assetOut,\n        uint256 amountIn,\n        bytes32 poolId,\n        uint256 minAccepted\n    ) internal returns (uint256 amountOut) {\n        // approve vault to spend tokenIn\n        ERC20(assetIn).approve(address(balancerVault), amountIn);\n\n        BalancerVault.SingleSwap memory request = BalancerVault.SingleSwap({\n            poolId: poolId,\n            kind: BalancerVault.SwapKind.GIVEN_IN,\n            assetIn: IAsset(assetIn),\n            assetOut: IAsset(assetOut),\n            amount: amountIn,\n            userData: hex\"\"\n        });\n\n        BalancerVault.FundManagement memory funds = BalancerVault.FundManagement({\n            sender: address(this),\n            fromInternalBalance: false,\n            recipient: payable(address(this)),\n            toInternalBalance: false\n        });\n\n        amountOut = balancerVault.swap(request, funds, minAccepted, type(uint256).max);\n        emit Swapped(msg.sender, poolId, assetIn, assetOut, amountIn, amountOut, msg.sig);\n    }\n\n    function _swapPTsForTarget(\n        address adapter,\n        uint256 maturity,\n        uint256 ptBal,\n        uint256 minAccepted\n    ) internal returns (uint256 tBal) {\n        address principalToken = divider.pt(adapter, maturity);\n        ERC20(principalToken).safeTransferFrom(msg.sender, address(this), ptBal); // pull principal\n        BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n        tBal = _swap(principalToken, Adapter(adapter).target(), ptBal, pool.getPoolId(), minAccepted); // swap Principal Tokens for underlying\n    }\n\n    function _swapTargetForPTs(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal,\n        uint256 minAccepted\n    ) internal returns (uint256 ptBal) {\n        address principalToken = divider.pt(adapter, maturity);\n        BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n        ptBal = _swap(Adapter(adapter).target(), principalToken, tBal, pool.getPoolId(), minAccepted); // swap target for Principal Tokens\n        ERC20(principalToken).safeTransfer(msg.sender, ptBal); // transfer bought principal to user\n    }\n\n    function _swapTargetForYTs(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal,\n        uint256 minAccepted\n    ) internal returns (uint256 issued) {\n        BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n\n        // issue pts and yts & swap pts for target\n        issued = divider.issue(adapter, maturity, tBal);\n        tBal = _swap(divider.pt(adapter, maturity), Adapter(adapter).target(), issued, pool.getPoolId(), minAccepted);\n\n        // transfer yts & target to user\n        ERC20(Adapter(adapter).target()).safeTransfer(msg.sender, tBal);\n        ERC20(divider.yt(adapter, maturity)).safeTransfer(msg.sender, issued);\n    }\n\n    function _swapYTsForTarget(\n        address sender,\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal\n    ) internal returns (uint256 tBal) {\n        address yt = divider.yt(adapter, maturity);\n\n        // Because there's some margin of error in the pricing functions here, smaller\n        // swaps will be unreliable. Tokens with more than 18 decimals are not supported.\n        if (ytBal * 10**(18 - ERC20(yt).decimals()) <= MIN_YT_SWAP_IN) revert Errors.SwapTooSmall();\n        BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n\n        // Transfer YTs into this contract if needed\n        if (sender != address(this)) ERC20(yt).safeTransferFrom(msg.sender, address(this), ytBal);\n\n        // Calculate target to borrow by calling AMM\n        bytes32 poolId = pool.getPoolId();\n        (uint256 pti, uint256 targeti) = pool.getIndices();\n        (ERC20[] memory tokens, uint256[] memory balances, ) = balancerVault.getPoolTokens(poolId);\n        // Determine how much Target we'll need in to get `ytBal` balance of PT out\n        // (space doesn't directly use of the fields from `SwapRequest` beyond `poolId`, so the values after are placeholders)\n        uint256 targetToBorrow = BalancerPool(pool).onSwap(\n            BalancerPool.SwapRequest({\n                kind: BalancerVault.SwapKind.GIVEN_OUT,\n                tokenIn: tokens[targeti],\n                tokenOut: tokens[pti],\n                amount: ytBal,\n                poolId: poolId,\n                lastChangeBlock: 0,\n                from: address(0),\n                to: address(0),\n                userData: \"\"\n            }),\n            balances[targeti],\n            balances[pti]\n        );\n\n        // Flash borrow target (following actions in `onFlashLoan`)\n        tBal = _flashBorrowAndSwap(\"0x\", adapter, maturity, ytBal, targetToBorrow);\n    }\n\n    /// @return tAmount if mode = 0, target received from selling YTs, otherwise, returns 0\n    /// @return issued returns amount of YTs issued (and received) except first provision which returns 0\n    /// @return lpShares Space LP shares received given the liquidity added\n    function _addLiquidity(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal,\n        uint8 mode,\n        uint256 minBptOut\n    )\n        internal\n        returns (\n            uint256 tAmount,\n            uint256 issued,\n            uint256 lpShares\n        )\n    {\n        // (1) compute target, issue PTs & YTs & add liquidity to space\n        (issued, lpShares) = _computeIssueAddLiq(adapter, maturity, tBal, minBptOut);\n\n        if (issued > 0) {\n            // issue = 0 means that we are on the first pool provision or that the pt:target ratio is 0:target\n            if (mode == 0) {\n                // (2) Sell YTs\n                tAmount = _swapYTsForTarget(address(this), adapter, maturity, issued);\n                // (3) Send remaining Target back to the User\n                ERC20(Adapter(adapter).target()).safeTransfer(msg.sender, tAmount);\n            } else {\n                // (4) Send YTs back to the User\n                ERC20(divider.yt(adapter, maturity)).safeTransfer(msg.sender, issued);\n            }\n        }\n    }\n\n    /// @dev Calculates amount of Principal Tokens in target terms (see description on `_computeTarget`) then issues\n    /// PTs and YTs with the calculated amount and finally adds liquidity to space with the PTs issued\n    /// and the diff between the target initially passed and the calculated amount\n    function _computeIssueAddLiq(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal,\n        uint256 minBptOut\n    ) internal returns (uint256 issued, uint256 lpShares) {\n        BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n        // Compute target\n        (ERC20[] memory tokens, uint256[] memory balances, ) = balancerVault.getPoolTokens(pool.getPoolId());\n        (uint256 pti, uint256 targeti) = pool.getIndices(); // Ensure we have the right token Indices\n\n        // We do not add Principal Token liquidity if it haven't been initialized yet\n        bool ptInitialized = balances[pti] != 0;\n        uint256 ptBalInTarget = ptInitialized ? _computeTarget(adapter, balances[pti], balances[targeti], tBal) : 0;\n\n        // Issue PT & YT (skip if first pool provision)\n        issued = ptBalInTarget > 0 ? divider.issue(adapter, maturity, ptBalInTarget) : 0;\n\n        // Add liquidity to Space & send the LP Shares to recipient\n        uint256[] memory amounts = new uint256[](2);\n        amounts[targeti] = tBal - ptBalInTarget;\n        amounts[pti] = issued;\n        lpShares = _addLiquidityToSpace(pool, PoolLiquidity(tokens, amounts, minBptOut));\n    }\n\n    /// @dev Based on pt:target ratio from current pool reserves and tBal passed\n    /// calculates amount of tBal needed so as to issue PTs that would keep the ratio\n    function _computeTarget(\n        address adapter,\n        uint256 ptiBal,\n        uint256 targetiBal,\n        uint256 tBal\n    ) internal returns (uint256 tBalForIssuance) {\n        uint256 tBase = 10**ERC20(Adapter(adapter).target()).decimals();\n        uint256 ifee = Adapter(adapter).ifee();\n        return\n            tBal.fmul(\n                ptiBal.fdiv(Adapter(adapter).scale().fmul(FixedMath.WAD - ifee).fmul(targetiBal) + ptiBal, tBase),\n                tBase\n            );\n    }\n\n    function _removeLiquidity(\n        address adapter,\n        uint256 maturity,\n        uint256 lpBal,\n        uint256[] memory minAmountsOut,\n        uint256 minAccepted,\n        bool intoTarget\n    ) internal returns (uint256 tBal, uint256 ptBal) {\n        address target = Adapter(adapter).target();\n        address pt = divider.pt(adapter, maturity);\n        BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n        bytes32 poolId = pool.getPoolId();\n\n        // (0) Pull LP tokens from sender\n        ERC20(address(pool)).safeTransferFrom(msg.sender, address(this), lpBal);\n\n        // (1) Remove liquidity from Space\n        uint256 _ptBal;\n        (tBal, _ptBal) = _removeLiquidityFromSpace(poolId, pt, target, minAmountsOut, lpBal);\n        if (divider.mscale(adapter, maturity) > 0) {\n            if (uint256(Adapter(adapter).level()).redeemRestricted()) {\n                ptBal = _ptBal;\n            } else {\n                // (2) Redeem Principal Tokens for Target\n                tBal += divider.redeem(adapter, maturity, _ptBal);\n            }\n        } else {\n            // (2) Sell Principal Tokens for Target (if there are)\n            if (_ptBal > 0 && intoTarget) {\n                tBal += _swap(pt, target, _ptBal, poolId, minAccepted);\n            } else {\n                ptBal = _ptBal;\n            }\n        }\n        if (ptBal > 0) ERC20(pt).safeTransfer(msg.sender, ptBal); // Send PT back to the User\n    }\n\n    /// @notice Initiates a flash loan of Target, swaps target amount to PTs and combines\n    /// @param adapter adapter\n    /// @param maturity maturity\n    /// @param ytBalIn YT amount the user has sent in\n    /// @param amount target amount to borrow\n    /// @return tBal amount of Target obtained from a sale of YTs\n    function _flashBorrowAndSwap(\n        bytes memory data,\n        address adapter,\n        uint256 maturity,\n        uint256 ytBalIn,\n        uint256 amount\n    ) internal returns (uint256 tBal) {\n        ERC20 target = ERC20(Adapter(adapter).target());\n        bytes memory data = abi.encode(adapter, maturity, ytBalIn);\n        bool result = Adapter(adapter).flashLoan(this, address(target), amount, data);\n        tBal = target.balanceOf(address(this));\n        if (!result) revert Errors.FlashBorrowFailed();\n    }\n\n    /// @dev ERC-3156 Flash loan callback\n    function onFlashLoan(\n        address initiator,\n        address, /* token */\n        uint256 amount,\n        uint256, /* fee */\n        bytes calldata data\n    ) external returns (bytes32) {\n        (address adapter, uint256 maturity, uint256 ytBalIn) = abi.decode(data, (address, uint256, uint256));\n        if (msg.sender != address(adapter)) revert Errors.FlashUntrustedBorrower();\n        if (initiator != address(this)) revert Errors.FlashUntrustedLoanInitiator();\n        address yt = divider.yt(adapter, maturity);\n        BalancerPool pool = BalancerPool(spaceFactory.pools(adapter, maturity));\n\n        // Because Space utilizes power ofs liberally in its invariant, there is some error\n        // in the amountIn we estimated that we'd need in `_swapYTsForTarget` to get a `ptBal` out\n        // that matched our Yield Token balance. Tokens with more than 18 decimals are not supported.\n        uint256 acceptableError = ERC20(yt).decimals() < 9\n            ? 1\n            : PRICE_ESTIMATE_ACCEPTABLE_ERROR / 10**(18 - ERC20(yt).decimals());\n\n        // Swap Target for PTs\n        uint256 ptBal = _swap(\n            Adapter(adapter).target(),\n            divider.pt(adapter, maturity),\n            amount,\n            pool.getPoolId(),\n            ytBalIn - acceptableError\n        );\n\n        // We take the lowest of the two balances, as long as they're within a margin of acceptable error.\n        if (ptBal >= ytBalIn + acceptableError && ptBal <= ytBalIn - acceptableError)\n            revert Errors.UnexpectedSwapAmount();\n\n        // Combine PTs and YTs\n        divider.combine(adapter, maturity, ptBal < ytBalIn ? ptBal : ytBalIn);\n\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n\n    function _addLiquidityToSpace(BalancerPool pool, PoolLiquidity memory liq) internal returns (uint256 lpBal) {\n        bytes32 poolId = pool.getPoolId();\n        IAsset[] memory assets = _convertERC20sToAssets(liq.tokens);\n        for (uint8 i; i < liq.tokens.length; i++) {\n            // Tokens and amounts must be in same order\n            liq.tokens[i].approve(address(balancerVault), liq.amounts[i]);\n        }\n\n        // Behaves like EXACT_TOKENS_IN_FOR_BPT_OUT, user sends precise quantities of tokens,\n        // and receives an estimated but unknown (computed at run time) quantity of BPT\n        BalancerVault.JoinPoolRequest memory request = BalancerVault.JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: liq.amounts,\n            userData: abi.encode(liq.amounts, liq.minBptOut),\n            fromInternalBalance: false\n        });\n        balancerVault.joinPool(poolId, address(this), msg.sender, request);\n        lpBal = ERC20(address(pool)).balanceOf(msg.sender);\n    }\n\n    function _removeLiquidityFromSpace(\n        bytes32 poolId,\n        address pt,\n        address target,\n        uint256[] memory minAmountsOut,\n        uint256 lpBal\n    ) internal returns (uint256 tBal, uint256 ptBal) {\n        // ExitPoolRequest params\n        (ERC20[] memory tokens, , ) = balancerVault.getPoolTokens(poolId);\n        IAsset[] memory assets = _convertERC20sToAssets(tokens);\n        BalancerVault.ExitPoolRequest memory request = BalancerVault.ExitPoolRequest({\n            assets: assets,\n            minAmountsOut: minAmountsOut,\n            userData: abi.encode(lpBal),\n            toInternalBalance: false\n        });\n        balancerVault.exitPool(poolId, address(this), payable(address(this)), request);\n\n        tBal = ERC20(target).balanceOf(address(this));\n        ptBal = ERC20(pt).balanceOf(address(this));\n    }\n\n    /// @notice From: https://github.com/balancer-labs/balancer-examples/blob/master/packages/liquidity-provision/contracts/LiquidityProvider.sol#L33\n    /// @dev This helper function is a fast and cheap way to convert between IERC20[] and IAsset[] types\n    function _convertERC20sToAssets(ERC20[] memory tokens) internal pure returns (IAsset[] memory assets) {\n        assembly {\n            assets := tokens\n        }\n    }\n\n    /* ========== LOGS ========== */\n\n    event FactoryChanged(address indexed factory, bool indexed isOn);\n    event SeriesSponsored(address indexed adapter, uint256 indexed maturity, address indexed sponsor);\n    event AdapterDeployed(address indexed adapter);\n    event AdapterOnboarded(address indexed adapter);\n    event AdapterVerified(address indexed adapter);\n    event Swapped(\n        address indexed sender,\n        bytes32 indexed poolId,\n        address assetIn,\n        address assetOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        bytes4 indexed sig\n    );\n}\n"
    },
    "@sense-finance/v1-core/src/adapters/BaseAdapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport { IERC3156FlashLender } from \"../external/flashloan/IERC3156FlashLender.sol\";\nimport { IERC3156FlashBorrower } from \"../external/flashloan/IERC3156FlashBorrower.sol\";\n\n// Internal references\nimport { Divider } from \"../Divider.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\n/// @title Assign value to Target tokens\nabstract contract BaseAdapter is IERC3156FlashLender {\n    using SafeTransferLib for ERC20;\n\n    /* ========== CONSTANTS ========== */\n\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /* ========== PUBLIC IMMUTABLES ========== */\n\n    /// @notice Sense core Divider address\n    address public immutable divider;\n\n    /// @notice Target token to divide\n    address public immutable target;\n\n    /// @notice Underlying for the Target\n    address public immutable underlying;\n\n    /// @notice Oracle address\n    address public immutable oracle;\n\n    /// @notice Token to stake at issuance\n    address public immutable stake;\n\n    /// @notice Amount to stake at issuance\n    uint256 public immutable stakeSize;\n\n    /// @notice Min maturity (seconds after block.timstamp)\n    uint256 public immutable minm;\n\n    /// @notice Max maturity (seconds after block.timstamp)\n    uint256 public immutable maxm;\n\n    /// @notice 0 for monthly, 1 for weekly\n    uint256 public immutable mode;\n\n    /// @notice Issuance fee\n    uint256 public immutable ifee;\n\n    /// @notice WAD number representing the percentage of the total\n    /// principal that's set aside for Yield Tokens (e.g. 0.1e18 means that 10% of the principal is reserved).\n    /// @notice If `0`, it means no principal is set aside for Yield Tokens\n    uint256 public immutable tilt;\n\n    /// @notice The number this function returns will be used to determine its access by checking for binary\n    /// digits using the following scheme:<onRedeem(y/n)><collect(y/n)><combine(y/n)><issue(y/n)>\n    /// (e.g. 0101 enables `collect` and `issue`, but not `combine`)\n    uint256 public immutable level;\n\n    /* ========== METADATA STORAGE ========== */\n\n    string public name;\n\n    string public symbol;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _underlying,\n        address _oracle,\n        uint256 _ifee,\n        address _stake,\n        uint256 _stakeSize,\n        uint256 _minm,\n        uint256 _maxm,\n        uint256 _mode,\n        uint256 _tilt,\n        uint256 _level\n    ) {\n        // Sanity check\n        if (_minm >= _maxm) revert Errors.InvalidMaturityOffsets();\n        divider = _divider;\n        target = _target;\n        underlying = _underlying;\n        oracle = _oracle;\n        ifee = _ifee;\n        stake = _stake;\n        stakeSize = _stakeSize;\n        minm = _minm;\n        maxm = _maxm;\n        mode = _mode;\n        tilt = _tilt;\n        name = string(abi.encodePacked(ERC20(_target).name(), \" Adapter\"));\n        symbol = string(abi.encodePacked(ERC20(_target).symbol(), \"-adapter\"));\n        level = _level;\n\n        ERC20(_target).approve(_divider, type(uint256).max);\n        ERC20(_stake).approve(_divider, type(uint256).max);\n    }\n\n    /// @notice Loan `amount` target to `receiver`, and takes it back after the callback.\n    /// @param receiver The contract receiving target, needs to implement the\n    /// `onFlashLoan(address user, address adapter, uint256 maturity, uint256 amount)` interface.\n    /// @param amount The amount of target lent.\n    /// @param data (encoded adapter address, maturity and YT amount the use has sent in)\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address, /* fee */\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n        ERC20(target).safeTransfer(address(receiver), amount);\n        bytes32 keccak = IERC3156FlashBorrower(receiver).onFlashLoan(msg.sender, target, amount, 0, data);\n        if (keccak != CALLBACK_SUCCESS) revert Errors.FlashCallbackFailed();\n        ERC20(target).safeTransferFrom(address(receiver), address(this), amount);\n        return true;\n    }\n\n    /* ========== REQUIRED VALUE GETTERS ========== */\n\n    /// @notice Calculate and return this adapter's Scale value for the current timestamp. To be overriden by child contracts\n    /// @dev For some Targets, such as cTokens, this is simply the exchange rate, or `supply cToken / supply underlying`\n    /// @dev For other Targets, such as AMM LP shares, specialized logic will be required\n    /// @dev This function _must_ return a WAD number representing the current exchange rate\n    /// between the Target and the Underlying.\n    /// @return value WAD Scale value\n    function scale() external virtual returns (uint256);\n\n    /// @notice Cached scale value getter\n    /// @dev For situations where you need scale from a view function\n    function scaleStored() external view virtual returns (uint256);\n\n    /// @notice Returns the current price of the underlying in ETH terms\n    function getUnderlyingPrice() external view virtual returns (uint256);\n\n    /* ========== REQUIRED UTILITIES ========== */\n\n    /// @notice Deposits underlying `amount`in return for target. Must be overriden by child contracts\n    /// @param amount Underlying amount\n    /// @return amount of target returned\n    function wrapUnderlying(uint256 amount) external virtual returns (uint256);\n\n    /// @notice Deposits target `amount`in return for underlying. Must be overriden by child contracts\n    /// @param amount Target amount\n    /// @return amount of underlying returned\n    function unwrapTarget(uint256 amount) external virtual returns (uint256);\n\n    function flashFee(address token, uint256) external view returns (uint256) {\n        if (token != target) revert Errors.TokenNotSupported();\n        return 0;\n    }\n\n    function maxFlashLoan(address token) external view override returns (uint256) {\n        return ERC20(token).balanceOf(address(this));\n    }\n\n    /* ========== OPTIONAL HOOKS ========== */\n\n    /// @notice Notification whenever the Divider adds or removes Target\n    function notify(\n        address, /* usr */\n        uint256, /* amt */\n        bool /* join */\n    ) public virtual {\n        return;\n    }\n\n    /// @notice Hook called whenever a user redeems PT\n    function onRedeem(\n        uint256, /* uBal */\n        uint256, /* mscale */\n        uint256, /* maxscale */\n        uint256 /* tBal */\n    ) public virtual {\n        return;\n    }\n\n    /* ========== PUBLIC STORAGE ACCESSORS ========== */\n\n    function getMaturityBounds() external view returns (uint256, uint256) {\n        return (minm, maxm);\n    }\n\n    function getStakeAndTarget()\n        external\n        view\n        returns (\n            address,\n            address,\n            uint256\n        )\n    {\n        return (target, stake, stakeSize);\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/adapters/compound/CFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// Internal references\nimport { CropFactory } from \"../CropFactory.sol\";\nimport { CAdapter, ComptrollerLike } from \"./CAdapter.sol\";\n\n// External references\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\ncontract CFactory is CropFactory {\n    using Bytes32AddressLib for address;\n\n    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    constructor(\n        address _divider,\n        FactoryParams memory _factoryParams,\n        address _reward\n    ) CropFactory(_divider, COMPTROLLER, _factoryParams, _reward) {}\n\n    function exists(address _target) external virtual override returns (bool isListed) {\n        (isListed, , ) = ComptrollerLike(protocol).markets(_target);\n    }\n\n    function deployAdapter(address _target) external override returns (address adapter) {\n        // Use the CREATE2 opcode to deploy a new Adapter contract.\n        // This will revert if a CAdapter with the provided target has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        adapter = address(\n            new CAdapter{ salt: _target.fillLast12Bytes() }(\n                divider,\n                _target,\n                factoryParams.oracle,\n                factoryParams.ifee,\n                factoryParams.stake,\n                factoryParams.stakeSize,\n                factoryParams.minm,\n                factoryParams.maxm,\n                factoryParams.mode,\n                factoryParams.tilt,\n                DEFAULT_LEVEL,\n                reward\n            )\n        );\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/adapters/lido/WstETHAdapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { FixedMath } from \"../../external/FixedMath.sol\";\n\n// Internal references\nimport { BaseAdapter } from \"../BaseAdapter.sol\";\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\ninterface WstETHLike {\n    /// @notice https://github.com/lidofinance/lido-dao/blob/master/contracts/0.6.12/WstETH.sol\n    /// @dev returns the current exchange rate of stETH to wstETH in wei (18 decimals)\n    function stEthPerToken() external view returns (uint256);\n\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n}\n\ninterface StETHLike {\n    /// @notice Send funds to the pool with optional _referral parameter\n    /// @dev This function is alternative way to submit funds. Supports optional referral address.\n    /// @return Amount of StETH shares generated\n    function submit(address _referral) external payable returns (uint256);\n\n    /// @return the amount of tokens owned by the `_account`.\n    ///\n    /// @dev Balances are dynamic and equal the `_account`'s share in the amount of the\n    /// total Ether controlled by the protocol. See `sharesOf`.\n    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);\n}\n\ninterface CurveStableSwapLike {\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external payable returns (uint256);\n}\n\ninterface WETHLike {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\ninterface StEthPriceFeedLike {\n    function safe_price_value() external view returns (uint256);\n}\n\n/// @notice Adapter contract for wstETH\ncontract WstETHAdapter is BaseAdapter {\n    using FixedMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    address public constant CETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant WSTETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n    address public constant STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n    address public constant CURVESINGLESWAP = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;\n    address public constant STETHPRICEFEED = 0xAb55Bf4DfBf469ebfe082b7872557D1F87692Fe6;\n\n    // On 2022.02.28, a swap from 100k stETH ($250m+ worth) to ETH was quoted\n    // by https://curve.fi/steth to incur 0.39% slippage, so we went with 0.5%\n    // to capture practically all unwrap/wrap sizes through the Sense adapter.\"\n    uint256 public constant SLIPPAGE_TOLERANCE = 0.005e18;\n\n    /// @notice Cached scale value from the last call to `scale()`\n    uint256 public override scaleStored;\n\n    constructor(\n        address _divider,\n        address _oracle,\n        uint256 _ifee,\n        address _stake,\n        uint256 _stakeSize,\n        uint256 _minm,\n        uint256 _maxm,\n        uint16 _mode,\n        uint64 _tilt\n    ) BaseAdapter(_divider, WSTETH, WETH, _oracle, _ifee, _stake, _stakeSize, _minm, _maxm, _mode, _tilt, 31) {\n        // approve wstETH contract to pull stETH (used on wrapUnderlying())\n        ERC20(STETH).approve(WSTETH, type(uint256).max);\n        // approve Curve stETH/ETH pool to pull stETH (used on unwrapTarget())\n        ERC20(STETH).approve(CURVESINGLESWAP, type(uint256).max);\n        // set an inital cached scale value\n        scaleStored = _wstEthToEthRate();\n    }\n\n    /// @return exRate Eth per wstEtH (natively in 18 decimals)\n    function scale() external virtual override returns (uint256 exRate) {\n        exRate = _wstEthToEthRate();\n\n        if (exRate != scaleStored) {\n            // update value only if different than the previous\n            scaleStored = exRate;\n        }\n    }\n\n    function getUnderlyingPrice() external pure override returns (uint256 price) {\n        price = 1e18;\n    }\n\n    function unwrapTarget(uint256 amount) external override returns (uint256 eth) {\n        ERC20(WSTETH).safeTransferFrom(msg.sender, address(this), amount); // pull wstETH\n        WstETHLike(WSTETH).unwrap(amount); // unwrap wstETH into stETH\n\n        // exchange stETH to ETH exchange on Curve\n        // to calculate the minDy, we use Lido's safe_price_value() which should prevent from flash loan / sandwhich attacks\n        // and we are also adding a slippage tolerance of 0.5%\n        uint256 stEthEth = StEthPriceFeedLike(STETHPRICEFEED).safe_price_value(); // returns the cached stETH/ETH safe price\n        eth = CurveStableSwapLike(CURVESINGLESWAP).exchange(\n            int128(1),\n            int128(0),\n            amount,\n            stEthEth.fmul(amount).fmul(FixedMath.WAD - SLIPPAGE_TOLERANCE)\n        );\n\n        // deposit ETH into WETH contract\n        (bool success, ) = WETH.call{ value: eth }(\"\");\n        if (!success) revert Errors.TransferFailed();\n\n        ERC20(WETH).safeTransfer(msg.sender, eth); // transfer WETH back to sender (periphery)\n    }\n\n    function wrapUnderlying(uint256 amount) external override returns (uint256 wstETH) {\n        ERC20(WETH).safeTransferFrom(msg.sender, address(this), amount); // pull WETH\n        WETHLike(WETH).withdraw(amount); // unwrap WETH into ETH\n        uint256 stETH = StETHLike(STETH).submit{ value: amount }(address(0)); // stake ETH (returns wstETH)\n        ERC20(WSTETH).safeTransfer(msg.sender, wstETH = WstETHLike(WSTETH).wrap(stETH)); // transfer wstETH to msg.sender\n    }\n\n    function _wstEthToEthRate() internal view returns (uint256 exRate) {\n        // In order to account for the stETH/ETH CurveStableSwap rate,\n        // we use `safe_price_value` from Lido's stETH price feed.\n        // https://docs.lido.fi/contracts/steth-price-feed#steth-price-feed-specification\n        uint256 stEthEth = StEthPriceFeedLike(STETHPRICEFEED).safe_price_value(); // returns the cached stETH/ETH safe price\n        uint256 wstETHstETH = StETHLike(STETH).getPooledEthByShares(1 ether); // stETH tokens per one wstETH\n        exRate = stEthEth.fmul(wstETHstETH);\n    }\n\n    fallback() external payable {\n        if (msg.sender != WETH && msg.sender != CURVESINGLESWAP) revert Errors.SenderNotEligible();\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/tests/test-helpers/mocks/fuse/MockOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\nimport { PriceOracle } from \"@sense-finance/v1-fuse/src/external/PriceOracle.sol\";\nimport { CToken } from \"@sense-finance/v1-fuse/src/external/CToken.sol\";\n\ncontract MockOracle is PriceOracle {\n    uint256 public _price = 1e18;\n\n    function getUnderlyingPrice(CToken) external view override returns (uint256) {\n        return _price;\n    }\n\n    function price(address) external view override returns (uint256) {\n        return _price;\n    }\n\n    function setPrice(uint256 price_) external {\n        _price = price_;\n    }\n\n    function initialize(\n        address[] memory underlyings,\n        PriceOracle[] memory _oracles,\n        PriceOracle _defaultOracle,\n        address _admin,\n        bool _canAdminOverwrite\n    ) external {\n        return;\n    }\n\n    function add(address[] calldata underlyings, PriceOracle[] calldata _oracles) external {\n        return;\n    }\n\n    function setZero(address zero, address pool) external {\n        return;\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/tests/test-helpers/mocks/fuse/MockComptroller.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\ncontract MockComptroller {\n    mapping(address => address) public ctokens;\n    mapping(address => address) public underlyings;\n    uint256 public nonce;\n\n    struct Market {\n        bool isListed;\n        uint256 collateralFactorMantissa;\n    }\n\n    function _deployMarket(\n        bool isCEther,\n        bytes calldata constructorData,\n        uint256 collateralFactorMantissa\n    ) external virtual returns (uint256) {\n        (address token, , , , , , , , ) = abi.decode(\n            constructorData,\n            (address, address, address, string, string, address, bytes, uint256, uint256)\n        );\n        require(ctokens[token] == address(0));\n        ctokens[token] = address(uint160(uint256(keccak256(abi.encodePacked(++nonce, blockhash(block.number))))));\n        underlyings[ctokens[token]] = token;\n        return 0;\n    }\n\n    function _acceptAdmin() external virtual returns (uint256) {\n        return 0;\n    }\n\n    function cTokensByUnderlying(address token) external virtual returns (address) {\n        if (ctokens[token] != address(0)) {\n            return ctokens[token];\n        }\n        return address(0);\n    }\n\n    function markets(address token) external virtual returns (Market memory) {\n        return Market({ isListed: underlyings[token] != address(0), collateralFactorMantissa: 0 });\n    }\n}\n\ncontract MockComptrollerRejectAdmin is MockComptroller {\n    function _acceptAdmin() external override returns (uint256) {\n        return 1;\n    }\n}\n\ncontract MockComptrollerFailAddMarket is MockComptroller {\n    function _deployMarket(\n        bool isCEther,\n        bytes calldata constructorData,\n        uint256 collateralFactorMantissa\n    ) external override returns (uint256) {\n        return 1;\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/tests/test-helpers/mocks/fuse/MockFuseDirectory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\ncontract MockFuseDirectory {\n    address public comptroller;\n\n    constructor(address _comptroller) {\n        comptroller = _comptroller;\n    }\n\n    function deployPool(\n        string memory name,\n        address implementation,\n        bool enforceWhitelist,\n        uint256 closeFactor,\n        uint256 liquidationIncentive,\n        address priceOracle\n    ) external returns (uint256, address) {\n        return (0, comptroller);\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/tests/test-helpers/mocks/MockAdapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport { BaseAdapter } from \"../../../adapters/BaseAdapter.sol\";\nimport { CropAdapter } from \"../../../adapters/CropAdapter.sol\";\nimport { FixedMath } from \"../../../external/FixedMath.sol\";\nimport { Divider } from \"../../../Divider.sol\";\nimport { YT } from \"../../../tokens/YT.sol\";\nimport { MockTarget } from \"./MockTarget.sol\";\nimport { MockToken } from \"./MockToken.sol\";\n\ncontract MockAdapter is CropAdapter {\n    using FixedMath for uint256;\n\n    uint256 internal value;\n    uint256 public INITIAL_VALUE;\n    address public under;\n    uint256 internal GROWTH_PER_SECOND = 792744799594; // 25% APY\n    uint256 public onRedeemCalls;\n\n    struct LScale {\n        // Timestamp of the last scale value\n        uint256 timestamp;\n        // Last scale value\n        uint256 value;\n    }\n\n    /// @notice Cached scale value from the last call to `scale()`\n    LScale public lscale;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _oracle,\n        uint256 _ifee,\n        address _stake,\n        uint256 _stakeSize,\n        uint256 _minm,\n        uint256 _maxm,\n        uint16 _mode,\n        uint64 _tilt,\n        uint256 _level,\n        address _reward\n    )\n        CropAdapter(\n            _divider,\n            _target,\n            MockTarget(_target).underlying(),\n            _oracle,\n            _ifee,\n            _stake,\n            _stakeSize,\n            _minm,\n            _maxm,\n            _mode,\n            _tilt,\n            _level,\n            _reward\n        )\n    {}\n\n    function scale() external virtual override returns (uint256 _value) {\n        if (value > 0) {\n            _value = value;\n            lscale.value = _value;\n            lscale.timestamp = block.timestamp;\n        }\n        if (INITIAL_VALUE == 0) {\n            INITIAL_VALUE = 1e18;\n        }\n        uint256 gps = GROWTH_PER_SECOND.fmul(99 * (10**(18 - 2)), FixedMath.WAD);\n        uint256 timeDiff = block.timestamp - lscale.timestamp;\n        _value = lscale.value > 0 ? (gps * timeDiff).fmul(lscale.value, FixedMath.WAD) + lscale.value : INITIAL_VALUE;\n\n        if (_value != lscale.value) {\n            // update value only if different than the previous\n            lscale.value = _value;\n            lscale.timestamp = block.timestamp;\n        }\n    }\n\n    function scaleStored() external view virtual override returns (uint256 _value) {\n        return lscale.value;\n    }\n\n    function _claimReward() internal virtual override {\n        //        MockToken(reward).mint(address(this), 1e18);\n    }\n\n    function wrapUnderlying(uint256 uBal) external virtual override returns (uint256) {\n        MockTarget target = MockTarget(target);\n        MockToken underlying = MockToken(target.underlying());\n        underlying.transferFrom(msg.sender, address(this), uBal);\n        uint256 mintAmount = uBal.fdivUp(lscale.value, FixedMath.WAD);\n        target.mint(msg.sender, mintAmount);\n        return mintAmount;\n    }\n\n    function unwrapTarget(uint256 tBal) external virtual override returns (uint256) {\n        MockTarget target = MockTarget(target);\n        target.transferFrom(msg.sender, address(this), tBal); // pull target\n        uint256 mintAmount = tBal.fmul(lscale.value, FixedMath.WAD);\n        MockToken(target.underlying()).mint(msg.sender, mintAmount);\n        return mintAmount;\n    }\n\n    function getUnderlyingPrice() external view virtual override returns (uint256) {\n        return 1e18;\n    }\n\n    function onRedeem(\n        uint256, /* uBal */\n        uint256, /* mscale */\n        uint256, /* maxscale */\n        uint256 /* tBal */\n    ) public virtual override {\n        onRedeemCalls++;\n    }\n\n    function setScale(uint256 _value) external {\n        value = _value;\n    }\n\n    function doInitSeries(uint256 maturity, address sponsor) external {\n        Divider(divider).initSeries(address(this), maturity, sponsor);\n    }\n\n    function doIssue(uint256 maturity, uint256 tBal) external {\n        MockTarget(target).transferFrom(msg.sender, address(this), tBal);\n        Divider(divider).issue(address(this), maturity, tBal);\n        (address pt, , address yt, , , , , , ) = Divider(divider).series(address(this), maturity);\n        MockToken(pt).transfer(msg.sender, MockToken(pt).balanceOf(address(this)));\n        MockToken(yt).transfer(msg.sender, MockToken(yt).balanceOf(address(this)));\n    }\n\n    function doCombine(uint256 maturity, uint256 uBal) external returns (uint256 tBal) {\n        tBal = Divider(divider).combine(address(this), maturity, uBal);\n    }\n\n    function doRedeemPrincipal(uint256 maturity, uint256 uBal) external {\n        Divider(divider).redeem(address(this), maturity, uBal);\n    }\n}\n\ncontract MockBaseAdapter is BaseAdapter {\n    constructor(\n        address _divider,\n        address _target,\n        address _oracle,\n        uint256 _ifee,\n        address _stake,\n        uint256 _stakeSize,\n        uint256 _minm,\n        uint256 _maxm,\n        uint16 _mode,\n        uint64 _tilt,\n        uint256 _level\n    )\n        BaseAdapter(\n            _divider,\n            _target,\n            MockTarget(_target).underlying(),\n            _oracle,\n            _ifee,\n            _stake,\n            _stakeSize,\n            _minm,\n            _maxm,\n            _mode,\n            _tilt,\n            _level\n        )\n    {}\n\n    function scale() external virtual override returns (uint256 _value) {\n        return 100e18;\n    }\n\n    function scaleStored() external view virtual override returns (uint256) {\n        return 100e18;\n    }\n\n    function wrapUnderlying(uint256 amount) external override returns (uint256) {\n        return 0;\n    }\n\n    function unwrapTarget(uint256 amount) external override returns (uint256) {\n        return 0;\n    }\n\n    function getUnderlyingPrice() external view override returns (uint256) {\n        return 1e18;\n    }\n\n    function doSetAdapter(Divider d, address _adapter) public {\n        d.setAdapter(_adapter, true);\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/tests/test-helpers/mocks/MockToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\n// Internal references\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\n\ncontract MockToken is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal\n    ) ERC20(_name, _symbol, _decimal) {}\n\n    function mint(address account, uint256 amount) external virtual {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) external virtual {\n        _burn(account, amount);\n    }\n}\n\ncontract AuthdMockToken is ERC20, Trust {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal\n    ) ERC20(_name, _symbol, _decimal) Trust(msg.sender) {}\n\n    function mint(address account, uint256 amount) external virtual requiresTrust {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) external virtual requiresTrust {\n        _burn(account, amount);\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/tests/test-helpers/mocks/MockTarget.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { MockToken, AuthdMockToken } from \"./MockToken.sol\";\nimport { ERC20 as ZeppelinERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockTarget is MockToken {\n    address public underlying;\n\n    constructor(\n        address _underlying,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal\n    ) MockToken(_name, _symbol, _decimal) {\n        underlying = _underlying;\n    }\n}\n\ncontract AuthdMockTarget is AuthdMockToken {\n    address public underlying;\n\n    constructor(\n        address _underlying,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal\n    ) AuthdMockToken(_name, _symbol, _decimal) {\n        underlying = _underlying;\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/tests/test-helpers/mocks/MockFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// Internal references\nimport { CropFactory } from \"../../../adapters/CropFactory.sol\";\nimport { Divider } from \"../../../Divider.sol\";\nimport { MockAdapter } from \"./MockAdapter.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\n// External references\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\ncontract MockFactory is CropFactory {\n    using Bytes32AddressLib for address;\n\n    mapping(address => bool) public targets;\n\n    constructor(\n        address _divider,\n        FactoryParams memory _factoryParams,\n        address _reward\n    ) CropFactory(_divider, address(0), _factoryParams, _reward) {}\n\n    function exists(address _target) external virtual override returns (bool) {\n        return targets[_target];\n    }\n\n    function addTarget(address _target, bool status) external {\n        targets[_target] = status;\n    }\n\n    function deployAdapter(address _target) external override returns (address) {\n        if (Divider(divider).periphery() != msg.sender) revert Errors.OnlyPeriphery();\n\n        // Use the CREATE2 opcode to deploy a new Adapter contract.\n        // This will revert if a CAdapter with the provided target has already\n        // been deployed, as the salt would be the same and we can't deploy with it twice.\n        return\n            address(\n                new MockAdapter{ salt: _target.fillLast12Bytes() }(\n                    divider,\n                    _target,\n                    factoryParams.oracle,\n                    factoryParams.ifee,\n                    factoryParams.stake,\n                    factoryParams.stakeSize,\n                    factoryParams.minm,\n                    factoryParams.maxm,\n                    factoryParams.mode,\n                    factoryParams.tilt,\n                    DEFAULT_LEVEL,\n                    reward\n                )\n            );\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/adapters/compound/CAdapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n// Internal references\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { CropAdapter } from \"../CropAdapter.sol\";\n\ninterface WETHLike {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\ninterface CTokenLike {\n    /// @notice cToken is convertible into an ever increasing quantity of the underlying asset, as interest accrues in\n    /// the market. This function returns the exchange rate between a cToken and the underlying asset.\n    /// @dev returns the current exchange rate as an uint, scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\n    function exchangeRateCurrent() external returns (uint256);\n\n    /// @notice Calculates the exchange rate from the underlying to the CToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateStored() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function underlying() external view returns (address);\n\n    /// The mint function transfers an asset into the protocol, which begins accumulating interest based\n    /// on the current Supply Rate for the asset. The user receives a quantity of cTokens equal to the\n    /// underlying tokens supplied, divided by the current Exchange Rate.\n    /// @param mintAmount The amount of the asset to be supplied, in units of the underlying asset.\n    /// @return 0 on success, otherwise an Error code\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    /// The redeem function converts a specified quantity of cTokens into the underlying asset, and returns\n    /// them to the user. The amount of underlying tokens received is equal to the quantity of cTokens redeemed,\n    /// multiplied by the current Exchange Rate. The amount redeemed must be less than the user's Account Liquidity\n    /// and the market's available liquidity.\n    /// @param redeemTokens The number of cTokens to be redeemed.\n    /// @return 0 on success, otherwise an Error code\n    function redeem(uint256 redeemTokens) external returns (uint256);\n}\n\ninterface CETHTokenLike {\n    ///@notice Send Ether to CEther to mint\n    function mint() external payable;\n}\n\ninterface ComptrollerLike {\n    /// @notice Claim all the comp accrued by holder in all markets\n    /// @param holder The address to claim COMP for\n    function claimComp(address holder) external;\n\n    function markets(address target)\n        external\n        returns (\n            bool isListed,\n            uint256 collateralFactorMantissa,\n            bool isComped\n        );\n\n    function oracle() external returns (address);\n}\n\ninterface PriceOracleLike {\n    /// @notice Get the price of an underlying asset.\n    /// @param target The target asset to get the underlying price of.\n    /// @return The underlying asset price in ETH as a mantissa (scaled by 1e18).\n    /// Zero means the price is unavailable.\n    function getUnderlyingPrice(address target) external view returns (uint256);\n}\n\n/// @notice Adapter contract for cTokens\ncontract CAdapter is CropAdapter {\n    using SafeTransferLib for ERC20;\n\n    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant CETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n\n    bool public immutable isCETH;\n    uint8 public immutable uDecimals;\n\n    constructor(\n        address _divider,\n        address _target,\n        address _oracle,\n        uint256 _ifee,\n        address _stake,\n        uint256 _stakeSize,\n        uint256 _minm,\n        uint256 _maxm,\n        uint16 _mode,\n        uint64 _tilt,\n        uint256 _level,\n        address _reward\n    )\n        CropAdapter(\n            _divider,\n            _target,\n            _target == CETH ? WETH : CTokenLike(_target).underlying(),\n            _oracle,\n            _ifee,\n            _stake,\n            _stakeSize,\n            _minm,\n            _maxm,\n            _mode,\n            _tilt,\n            _level,\n            _reward\n        )\n    {\n        isCETH = _target == CETH;\n        ERC20(underlying).approve(_target, type(uint256).max);\n        uDecimals = CTokenLike(underlying).decimals();\n    }\n\n    /// @return Exchange rate from Target to Underlying using Compound's `exchangeRateCurrent()`, normed to 18 decimals\n    function scale() external override returns (uint256) {\n        uint256 exRate = CTokenLike(target).exchangeRateCurrent();\n        return _to18Decimals(exRate);\n    }\n\n    function scaleStored() external view override returns (uint256) {\n        uint256 exRate = CTokenLike(target).exchangeRateStored();\n        return _to18Decimals(exRate);\n    }\n\n    function _claimReward() internal virtual override {\n        ComptrollerLike(COMPTROLLER).claimComp(address(this));\n    }\n\n    function getUnderlyingPrice() external view override returns (uint256 price) {\n        price = isCETH ? 1e18 : PriceOracleLike(oracle).getUnderlyingPrice(target);\n    }\n\n    function wrapUnderlying(uint256 uBal) external override returns (uint256 tBal) {\n        ERC20 t = ERC20(target);\n\n        ERC20(underlying).safeTransferFrom(msg.sender, address(this), uBal); // pull underlying\n        if (isCETH) WETHLike(WETH).withdraw(uBal); // unwrap WETH into ETH\n\n        // Mint target\n        uint256 tBalBefore = t.balanceOf(address(this));\n        if (isCETH) {\n            CETHTokenLike(target).mint{ value: uBal }();\n        } else {\n            if (CTokenLike(target).mint(uBal) != 0) revert Errors.MintFailed();\n        }\n        uint256 tBalAfter = t.balanceOf(address(this));\n\n        // Transfer target to sender\n        t.safeTransfer(msg.sender, tBal = tBalAfter - tBalBefore);\n    }\n\n    function unwrapTarget(uint256 tBal) external override returns (uint256 uBal) {\n        ERC20 u = ERC20(underlying);\n        ERC20(target).safeTransferFrom(msg.sender, address(this), tBal); // pull target\n\n        // Redeem target for underlying\n        uint256 uBalBefore = isCETH ? address(this).balance : u.balanceOf(address(this));\n        if (CTokenLike(target).redeem(tBal) != 0) revert Errors.RedeemFailed();\n        uint256 uBalAfter = isCETH ? address(this).balance : u.balanceOf(address(this));\n        unchecked {\n            uBal = uBalAfter - uBalBefore;\n        }\n\n        if (isCETH) {\n            // Deposit ETH into WETH contract\n            (bool success, ) = WETH.call{ value: uBal }(\"\");\n            if (!success) revert Errors.TransferFailed();\n        }\n\n        // Transfer underlying to sender\n        ERC20(underlying).safeTransfer(msg.sender, uBal);\n    }\n\n    function _to18Decimals(uint256 exRate) internal view returns (uint256) {\n        // From the Compound docs:\n        // \"exchangeRateCurrent() returns the exchange rate, scaled by 1 * 10^(18 - 8 + Underlying Token Decimals)\"\n        //\n        // The equation to norm an asset to 18 decimals is:\n        // `num * 10**(18 - decimals)`\n        //\n        // So, when we try to norm exRate to 18 decimals, we get the following:\n        // `exRate * 10**(18 - exRateDecimals)`\n        // -> `exRate * 10**(18 - (18 - 8 + uDecimals))`\n        // -> `exRate * 10**(8 - uDecimals)`\n        // -> `exRate / 10**(uDecimals - 8)`\n        return uDecimals >= 8 ? exRate / 10**(uDecimals - 8) : exRate * 10**(8 - uDecimals);\n    }\n\n    fallback() external payable {}\n}\n"
    },
    "@sense-finance/v1-fuse/src/PoolManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External reference\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\nimport { PriceOracle } from \"./external/PriceOracle.sol\";\nimport { BalancerOracle } from \"./external/BalancerOracle.sol\";\n\n// Internal references\nimport { UnderlyingOracle } from \"./oracles/Underlying.sol\";\nimport { TargetOracle } from \"./oracles/Target.sol\";\nimport { PTOracle } from \"./oracles/PT.sol\";\nimport { LPOracle } from \"./oracles/LP.sol\";\n\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { Divider } from \"@sense-finance/v1-core/src/Divider.sol\";\nimport { BaseAdapter as Adapter } from \"@sense-finance/v1-core/src/adapters/BaseAdapter.sol\";\n\ninterface FuseDirectoryLike {\n    function deployPool(\n        string memory name,\n        address implementation,\n        bool enforceWhitelist,\n        uint256 closeFactor,\n        uint256 liquidationIncentive,\n        address priceOracle\n    ) external returns (uint256, address);\n}\n\ninterface ComptrollerLike {\n    /// Deploy cToken, add the market to the markets mapping, and set it as listed and set the collateral factor\n    /// Admin function to deploy cToken, set isListed, and add support for the market and set the collateral factor\n    function _deployMarket(\n        bool isCEther,\n        bytes calldata constructorData,\n        uint256 collateralFactorMantissa\n    ) external returns (uint256);\n\n    /// Accepts transfer of admin rights. msg.sender must be pendingAdmin\n    function _acceptAdmin() external returns (uint256);\n\n    /// All cTokens addresses mapped by their underlying token addresses\n    function cTokensByUnderlying(address underlying) external view returns (address);\n\n    /// A list of all markets\n    function markets(address cToken) external view returns (bool, uint256);\n\n    /// Pause borrowing for a specific market\n    function _setBorrowPaused(address cToken, bool state) external returns (bool);\n}\n\ninterface MasterOracleLike {\n    function initialize(\n        address[] memory underlyings,\n        PriceOracle[] memory _oracles,\n        PriceOracle _defaultOracle,\n        address _admin,\n        bool _canAdminOverwrite\n    ) external;\n\n    function add(address[] calldata underlyings, PriceOracle[] calldata _oracles) external;\n\n    function getUnderlyingPrice(address cToken) external view returns (uint256);\n}\n\n/// @title Fuse Pool Manager\n/// @notice Consolidated Fuse interactions\ncontract PoolManager is Trust {\n    /* ========== PUBLIC IMMUTABLES ========== */\n\n    /// @notice Implementation of Fuse's comptroller\n    address public immutable comptrollerImpl;\n\n    /// @notice Implementation of Fuse's cERC20\n    address public immutable cERC20Impl;\n\n    /// @notice Fuse's pool directory\n    address public immutable fuseDirectory;\n\n    /// @notice Sense core Divider address\n    address public immutable divider;\n\n    /// @notice Implementation of Fuse's master oracle that routes to individual asset oracles\n    address public immutable oracleImpl;\n\n    /// @notice Sense oracle for SEnse Targets\n    address public immutable targetOracle;\n\n    /// @notice Sense oracle for Sense Principal Tokens\n    address public immutable ptOracle;\n\n    /// @notice Sense oracle for Space LP Shares\n    address public immutable lpOracle;\n\n    /// @notice Sense oracle for Underlying assets\n    address public immutable underlyingOracle;\n\n    /* ========== PUBLIC MUTABLE STORAGE ========== */\n\n    /// @notice Fuse comptroller for the Sense pool\n    address public comptroller;\n\n    /// @notice Master oracle for Sense's assets deployed on Fuse\n    address public masterOracle;\n\n    /// @notice Fuse param config\n    AssetParams public targetParams;\n    AssetParams public ptParams;\n    AssetParams public lpTokenParams;\n\n    /// @notice Series Pools: adapter -> maturity -> (series status (pt/lp shares), AMM pool)\n    mapping(address => mapping(uint256 => Series)) public sSeries;\n\n    /* ========== ENUMS ========== */\n\n    enum SeriesStatus {\n        NONE,\n        QUEUED,\n        ADDED\n    }\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct AssetParams {\n        address irModel;\n        uint256 reserveFactor;\n        uint256 collateralFactor;\n    }\n\n    struct Series {\n        // Series addition status\n        SeriesStatus status;\n        // Space pool for this Series\n        address pool;\n    }\n\n    constructor(\n        address _fuseDirectory,\n        address _comptrollerImpl,\n        address _cERC20Impl,\n        address _divider,\n        address _oracleImpl\n    ) Trust(msg.sender) {\n        fuseDirectory = _fuseDirectory;\n        comptrollerImpl = _comptrollerImpl;\n        cERC20Impl = _cERC20Impl;\n        divider = _divider;\n        oracleImpl = _oracleImpl;\n\n        targetOracle = address(new TargetOracle());\n        ptOracle = address(new PTOracle());\n        lpOracle = address(new LPOracle());\n        underlyingOracle = address(new UnderlyingOracle());\n    }\n\n    function deployPool(\n        string calldata name,\n        uint256 closeFactor,\n        uint256 liqIncentive,\n        address fallbackOracle\n    ) external requiresTrust returns (uint256 _poolIndex, address _comptroller) {\n        masterOracle = Clones.cloneDeterministic(oracleImpl, Bytes32AddressLib.fillLast12Bytes(address(this)));\n        MasterOracleLike(masterOracle).initialize(\n            new address[](0),\n            new PriceOracle[](0),\n            PriceOracle(fallbackOracle), // default oracle used if asset prices can't be found otherwise\n            address(this), // admin\n            true // admin can override existing oracle routes\n        );\n\n        (_poolIndex, _comptroller) = FuseDirectoryLike(fuseDirectory).deployPool(\n            name,\n            comptrollerImpl,\n            false, // `whitelist` is always false\n            closeFactor,\n            liqIncentive,\n            masterOracle\n        );\n\n        uint256 err = ComptrollerLike(_comptroller)._acceptAdmin();\n        if (err != 0) revert Errors.FailedBecomeAdmin();\n        comptroller = _comptroller;\n\n        emit PoolDeployed(name, _comptroller, _poolIndex, closeFactor, liqIncentive);\n    }\n\n    function addTarget(address target, address adapter) external requiresTrust returns (address cTarget) {\n        if (comptroller == address(0)) revert Errors.PoolNotDeployed();\n        if (targetParams.irModel == address(0)) revert Errors.TargetParamsNotSet();\n\n        address underlying = Adapter(adapter).underlying();\n\n        address[] memory underlyings = new address[](2);\n        underlyings[0] = target;\n        underlyings[1] = underlying;\n\n        PriceOracle[] memory oracles = new PriceOracle[](2);\n        oracles[0] = PriceOracle(targetOracle);\n        oracles[1] = PriceOracle(underlyingOracle);\n\n        UnderlyingOracle(underlyingOracle).setUnderlying(underlying, adapter);\n        TargetOracle(targetOracle).setTarget(target, adapter);\n        MasterOracleLike(masterOracle).add(underlyings, oracles);\n\n        bytes memory constructorData = abi.encode(\n            target,\n            comptroller,\n            targetParams.irModel,\n            ERC20(target).name(),\n            ERC20(target).symbol(),\n            cERC20Impl,\n            hex\"\", // calldata sent to becomeImplementation (empty bytes b/c it's currently unused)\n            targetParams.reserveFactor,\n            0 // no admin fee\n        );\n\n        // Trying to deploy the same market twice will fail\n        uint256 err = ComptrollerLike(comptroller)._deployMarket(false, constructorData, targetParams.collateralFactor);\n        if (err != 0) revert Errors.FailedAddTargetMarket();\n\n        cTarget = ComptrollerLike(comptroller).cTokensByUnderlying(target);\n\n        emit TargetAdded(target, cTarget);\n    }\n\n    /// @notice queues a set of (Principal Tokens, LPShare) for a Fuse pool to be deployed once the TWAP is ready\n    /// @dev called by the Periphery, which will know which pool address to set for this Series\n    function queueSeries(\n        address adapter,\n        uint256 maturity,\n        address pool\n    ) external requiresTrust {\n        if (Divider(divider).pt(adapter, maturity) == address(0)) revert Errors.SeriesDoesNotExist();\n        if (sSeries[adapter][maturity].status != SeriesStatus.NONE) revert Errors.DuplicateSeries();\n\n        address cTarget = ComptrollerLike(comptroller).cTokensByUnderlying(Adapter(adapter).target());\n        if (cTarget == address(0)) revert Errors.TargetNotInFuse();\n\n        (bool isListed, ) = ComptrollerLike(comptroller).markets(cTarget);\n        if (!isListed) revert Errors.TargetNotInFuse();\n\n        sSeries[adapter][maturity] = Series({ status: SeriesStatus.QUEUED, pool: pool });\n\n        emit SeriesQueued(adapter, maturity, pool);\n    }\n\n    /// @notice open method to add queued Principal Tokens and LPShares to Fuse pool\n    /// @dev this can only be done once the yield space pool has filled its buffer and has a TWAP\n    function addSeries(address adapter, uint256 maturity) external returns (address cPT, address cLPToken) {\n        if (sSeries[adapter][maturity].status != SeriesStatus.QUEUED) revert Errors.SeriesNotQueued();\n        if (ptParams.irModel == address(0)) revert Errors.PTParamsNotSet();\n        if (lpTokenParams.irModel == address(0)) revert Errors.PoolParamsNotSet();\n\n        address pt = Divider(divider).pt(adapter, maturity);\n        address pool = sSeries[adapter][maturity].pool;\n\n        (, , , , , , uint256 sampleTs) = BalancerOracle(pool).getSample(1023);\n        // Prevent this market from being deployed on Fuse if we're able to read a TWAP\n        if (sampleTs == 0) revert Errors.OracleNotReady();\n\n        address[] memory underlyings = new address[](2);\n        underlyings[0] = pt;\n        underlyings[1] = pool;\n\n        PriceOracle[] memory oracles = new PriceOracle[](2);\n        oracles[0] = PriceOracle(ptOracle);\n        oracles[1] = PriceOracle(lpOracle);\n\n        PTOracle(ptOracle).setPrincipal(pt, pool);\n        MasterOracleLike(masterOracle).add(underlyings, oracles);\n\n        bytes memory constructorDataPrincipal = abi.encode(\n            pt,\n            comptroller,\n            ptParams.irModel,\n            ERC20(pt).name(),\n            ERC20(pt).symbol(),\n            cERC20Impl,\n            hex\"\",\n            ptParams.reserveFactor,\n            0 // no admin fee\n        );\n\n        uint256 errPrincipal = ComptrollerLike(comptroller)._deployMarket(\n            false,\n            constructorDataPrincipal,\n            ptParams.collateralFactor\n        );\n        if (errPrincipal != 0) revert Errors.FailedToAddPTMarket();\n\n        // LP Share pool token\n        bytes memory constructorDataLpToken = abi.encode(\n            pool,\n            comptroller,\n            lpTokenParams.irModel,\n            ERC20(pool).name(),\n            ERC20(pool).symbol(),\n            cERC20Impl,\n            hex\"\",\n            lpTokenParams.reserveFactor,\n            0 // no admin fee\n        );\n\n        uint256 errLpToken = ComptrollerLike(comptroller)._deployMarket(\n            false,\n            constructorDataLpToken,\n            lpTokenParams.collateralFactor\n        );\n        if (errLpToken != 0) revert Errors.FailedAddLpMarket();\n\n        cPT = ComptrollerLike(comptroller).cTokensByUnderlying(pt);\n        cLPToken = ComptrollerLike(comptroller).cTokensByUnderlying(pool);\n\n        ComptrollerLike(comptroller)._setBorrowPaused(cLPToken, true);\n\n        sSeries[adapter][maturity].status = SeriesStatus.ADDED;\n\n        emit SeriesAdded(pt, pool);\n    }\n\n    /* ========== ADMIN ========== */\n\n    function setParams(bytes32 what, AssetParams calldata data) external requiresTrust {\n        if (what == \"PT_PARAMS\") ptParams = data;\n        else if (what == \"LP_TOKEN_PARAMS\") lpTokenParams = data;\n        else if (what == \"TARGET_PARAMS\") targetParams = data;\n        else revert Errors.InvalidParam();\n        emit ParamsSet(what, data);\n    }\n\n    function execute(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) external requiresTrust returns (bool success) {\n        assembly {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    /* ========== LOGS ========== */\n\n    event ParamsSet(bytes32 indexed what, AssetParams data);\n    event PoolDeployed(string name, address comptroller, uint256 poolIndex, uint256 closeFactor, uint256 liqIncentive);\n    event TargetAdded(address indexed target, address indexed cTarget);\n    event SeriesQueued(address indexed adapter, uint256 indexed maturity, address indexed pool);\n    event SeriesAdded(address indexed pt, address indexed lpToken);\n}\n"
    },
    "@sense-finance/v1-utils/src/EmergencyStop.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// Internal references\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { Divider } from \"@sense-finance/v1-core/src/Divider.sol\";\n\n/// @notice Unsets multiple adapters on the divider\ncontract EmergencyStop is Trust {\n    address public immutable divider;\n\n    constructor(address _divider) Trust(msg.sender) {\n        divider = _divider;\n    }\n\n    function stop(address[] memory adapters) external virtual requiresTrust {\n        Divider(divider).setPermissionless(false);\n        for (uint256 i = 0; i < adapters.length; i++) {\n            Divider(divider).setAdapter(adapters[i], false);\n            emit Stopped(adapters[i]);\n        }\n    }\n\n    event Stopped(address indexed adapter);\n}\n"
    },
    "src/Versioning.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity  0.8.11;\n\ncontract Versioning {\n    string public version;\n    constructor(string memory _version){\n        version = _version;\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\nlibrary SafeTransferLib {\n    /*///////////////////////////////////////////////////////////////\n                            ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 100 because the calldata length is 4 + 32 * 3.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                success := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                success := 1\n            }\n            default {\n                // It returned some malformed input.\n                success := 0\n            }\n        }\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private reentrancyStatus = 1;\n\n    modifier nonReentrant() {\n        require(reentrancyStatus == 1, \"REENTRANCY\");\n\n        reentrancyStatus = 2;\n\n        _;\n\n        reentrancyStatus = 1;\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/external/DateTime.sol": {
      "content": "pragma solidity 0.8.11;\n\n/// @author Taken from: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\nlibrary DateTime {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 constant SECONDS_PER_MINUTE = 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function toDateString(uint256 _timestamp)\n        internal\n        pure\n        returns (\n            string memory d,\n            string memory m,\n            string memory y\n        )\n    {\n        (uint256 year, uint256 month, uint256 day) = timestampToDate(_timestamp);\n        d = uintToString(day);\n        m = uintToString(month);\n        y = uintToString(year);\n        // append a 0 to numbers < 10 so we should, e.g, 01 instead of just 1\n        if (day < 10) d = string(abi.encodePacked(\"0\", d));\n        if (month < 10) m = string(abi.encodePacked(\"0\", m));\n    }\n\n    function format(uint256 _timestamp) internal pure returns (string memory datestring) {\n        string[12] memory months = [\n            \"Jan\",\n            \"Feb\",\n            \"Mar\",\n            \"Apr\",\n            \"May\",\n            \"June\",\n            \"July\",\n            \"Aug\",\n            \"Sept\",\n            \"Oct\",\n            \"Nov\",\n            \"Dec\"\n        ];\n        (uint256 year, uint256 month, uint256 day) = timestampToDate(_timestamp);\n        uint256 last = day % 10;\n        string memory suffix = \"th\";\n        if (day < 11 || day > 20) {\n            if (last == 1) suffix = \"st\";\n            if (last == 2) suffix = \"nd\";\n            if (last == 3) suffix = \"rd\";\n        }\n        return string(abi.encodePacked(uintToString(day), suffix, \" \", months[month - 1], \" \", uintToString(year)));\n    }\n\n    function getDayOfWeek(uint256 timestamp) internal pure returns (uint256 dayOfWeek) {\n        uint256 _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = ((_days + 3) % 7) + 1;\n    }\n\n    /// Taken from https://stackoverflow.com/questions/47129173/how-to-convert-uint-to-string-in-solidity\n    function uintToString(uint256 _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) return \"0\";\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 _days) {\n        require(year >= 1970);\n        int256 _year = int256(year);\n        int256 _month = int256(month);\n        int256 _day = int256(day);\n\n        int256 __days = _day -\n            32075 +\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\n            4 +\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\n            12 -\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\n            4 -\n            OFFSET19700101;\n\n        _days = uint256(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/external/FixedMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n/// @title Fixed point arithmetic library\n/// @author Taken from https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol\nlibrary FixedMath {\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant RAY = 1e27;\n\n    function fmul(\n        uint256 x,\n        uint256 y,\n        uint256 baseUnit\n    ) internal pure returns (uint256) {\n        return mulDivDown(x, y, baseUnit); // Equivalent to (x * y) / baseUnit rounded down.\n    }\n\n    function fmul(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function fmulUp(\n        uint256 x,\n        uint256 y,\n        uint256 baseUnit\n    ) internal pure returns (uint256) {\n        return mulDivUp(x, y, baseUnit); // Equivalent to (x * y) / baseUnit rounded up.\n    }\n\n    function fmulUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function fdiv(\n        uint256 x,\n        uint256 y,\n        uint256 baseUnit\n    ) internal pure returns (uint256) {\n        return mulDivDown(x, baseUnit, y); // Equivalent to (x * baseUnit) / y rounded down.\n    }\n\n    function fdiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function fdivUp(\n        uint256 x,\n        uint256 y,\n        uint256 baseUnit\n    ) internal pure returns (uint256) {\n        return mulDivUp(x, baseUnit, y); // Equivalent to (x * baseUnit) / y rounded up.\n    }\n\n    function fdivUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n}\n"
    },
    "@sense-finance/v1-utils/src/libs/Errors.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.4;\n\nlibrary Errors {\n    // Auth\n    error CombineRestricted();\n    error IssuanceRestricted();\n    error NotAuthorized();\n    error OnlyYT();\n    error OnlyDivider();\n    error OnlyPeriphery();\n    error OnlyPermissionless();\n    error RedeemRestricted();\n    error Untrusted();\n\n    // Adapters\n    error TokenNotSupported();\n    error FlashCallbackFailed();\n    error InvalidMaturityOffsets();\n    error SenderNotEligible();\n    error TargetMismatch();\n    error TargetNotSupported();\n\n    // Divider\n    error AlreadySettled();\n    error CollectNotSettled();\n    error GuardCapReached();\n    error IssuanceFeeCapExceeded();\n    error IssueOnSettle();\n    error NotSettled();\n\n    // Input & validations\n    error AlreadyInitialized();\n    error DuplicateSeries();\n    error ExistingValue();\n    error InvalidAdapter();\n    error InvalidMaturity();\n    error InvalidParam();\n    error OutOfWindowBoundaries();\n    error SeriesDoesNotExist();\n    error SwapTooSmall();\n    error TargetParamsNotSet();\n    error PoolParamsNotSet();\n    error PTParamsNotSet();\n\n    // Periphery\n    error FactoryNotSupported();\n    error FlashBorrowFailed();\n    error FlashUntrustedBorrower();\n    error FlashUntrustedLoanInitiator();\n    error UnexpectedSwapAmount();\n\n    // Fuse\n    error AdapterNotSet();\n    error FailedBecomeAdmin();\n    error FailedAddTargetMarket();\n    error FailedToAddPTMarket();\n    error FailedAddLpMarket();\n    error OracleNotReady();\n    error PoolAlreadyDeployed();\n    error PoolNotDeployed();\n    error PoolNotSet();\n    error SeriesNotQueued();\n    error TargetExists();\n    error TargetNotInFuse();\n\n    // Tokens\n    error MintFailed();\n    error RedeemFailed();\n    error TransferFailed();\n}\n"
    },
    "@sense-finance/v1-utils/src/libs/Levels.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.0;\n\nlibrary Levels {\n    uint256 private constant _INIT_BIT = 0x1;\n    uint256 private constant _ISSUE_BIT = 0x2;\n    uint256 private constant _COMBINE_BIT = 0x4;\n    uint256 private constant _COLLECT_BIT = 0x8;\n    uint256 private constant _REDEEM_BIT = 0x10;\n    uint256 private constant _REDEEM_HOOK_BIT = 0x20;\n\n    function initRestricted(uint256 level) internal pure returns (bool) {\n        return level & _INIT_BIT != _INIT_BIT;\n    }\n\n    function issueRestricted(uint256 level) internal pure returns (bool) {\n        return level & _ISSUE_BIT != _ISSUE_BIT;\n    }\n\n    function combineRestricted(uint256 level) internal pure returns (bool) {\n        return level & _COMBINE_BIT != _COMBINE_BIT;\n    }\n\n    function collectDisabled(uint256 level) internal pure returns (bool) {\n        return level & _COLLECT_BIT != _COLLECT_BIT;\n    }\n\n    function redeemRestricted(uint256 level) internal pure returns (bool) {\n        return level & _REDEEM_BIT != _REDEEM_BIT;\n    }\n\n    function redeemHookDisabled(uint256 level) internal pure returns (bool) {\n        return level & _REDEEM_HOOK_BIT != _REDEEM_HOOK_BIT;\n    }\n}\n"
    },
    "@sense-finance/v1-utils/src/Trust.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.0;\n\n/// @notice Ultra minimal authorization logic for smart contracts.\n/// @author From https://github.com/Rari-Capital/solmate/blob/fab107565a51674f3a3b5bfdaacc67f6179b1a9b/src/auth/Trust.sol\nabstract contract Trust {\n    event UserTrustUpdated(address indexed user, bool trusted);\n\n    mapping(address => bool) public isTrusted;\n\n    constructor(address initialUser) {\n        isTrusted[initialUser] = true;\n\n        emit UserTrustUpdated(initialUser, true);\n    }\n\n    function setIsTrusted(address user, bool trusted) public virtual requiresTrust {\n        isTrusted[user] = trusted;\n\n        emit UserTrustUpdated(user, trusted);\n    }\n\n    modifier requiresTrust() {\n        require(isTrusted[msg.sender], \"UNTRUSTED\");\n\n        _;\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/tokens/YT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// Internal references\nimport { Divider } from \"../Divider.sol\";\nimport { Token } from \"./Token.sol\";\n\n/// @title Yield Token\n/// @notice Strips off excess before every transfer\ncontract YT is Token {\n    address public immutable adapter;\n    address public immutable divider;\n    uint256 public immutable maturity;\n\n    constructor(\n        address _adapter,\n        uint256 _maturity,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _divider\n    ) Token(_name, _symbol, _decimals, _divider) {\n        adapter = _adapter;\n        maturity = _maturity;\n        divider = _divider;\n    }\n\n    function collect() external returns (uint256 _collected) {\n        return Divider(divider).collect(msg.sender, adapter, maturity, 0, address(0));\n    }\n\n    function transfer(address to, uint256 value) public override returns (bool) {\n        Divider(divider).collect(msg.sender, adapter, maturity, value, to);\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public override returns (bool) {\n        if (value > 0) Divider(divider).collect(from, adapter, maturity, value, to);\n        return super.transferFrom(from, to, value);\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/tokens/Token.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\n// Internal references\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\n\n/// @title Base Token\ncontract Token is ERC20, Trust {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _trusted\n    ) ERC20(_name, _symbol, _decimals) Trust(_trusted) {}\n\n    /// @param usr The address to send the minted tokens\n    /// @param amount The amount to be minted\n    function mint(address usr, uint256 amount) public requiresTrust {\n        _mint(usr, amount);\n    }\n\n    /// @param usr The address from where to burn tokens from\n    /// @param amount The amount to be burned\n    function burn(address usr, uint256 amount) public requiresTrust {\n        _burn(usr, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/external/flashloan/IERC3156FlashLender.sol": {
      "content": "pragma solidity ^0.8.0;\nimport \"./IERC3156FlashBorrower.sol\";\n\ninterface IERC3156FlashLender {\n    /// @dev The amount of currency available to be lent.\n    /// @param token The loan currency.\n    /// @return The amount of `token` that can be borrowed.\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /// @dev The fee to be charged for a given loan.\n    /// @param token The loan currency.\n    /// @param amount The amount of tokens lent.\n    /// @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /// @dev Initiate a flash loan.\n    /// @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n    /// @param token The loan currency.\n    /// @param amount The amount of tokens lent.\n    /// @param data Arbitrary data structure, intended to contain user-defined parameters.\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "@sense-finance/v1-core/src/external/flashloan/IERC3156FlashBorrower.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface IERC3156FlashBorrower {\n    /// @dev Receive a flash loan.\n    /// @param initiator The initiator of the loan.\n    /// @param token The loan currency.\n    /// @param amount The amount of tokens lent.\n    /// @param fee The additional amount of tokens to repay.\n    /// @param data Arbitrary data structure, intended to contain user-defined parameters.\n    /// @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "@sense-finance/v1-core/src/external/balancer/Vault.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\ninterface IAsset {}\n\ninterface BalancerVault {\n    struct JoinPoolRequest {\n        IAsset[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n    struct ExitPoolRequest {\n        IAsset[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n    enum PoolSpecialization {\n        GENERAL,\n        MINIMAL_SWAP_INFO,\n        TWO_TOKEN\n    }\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            ERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 maxBlockNumber\n        );\n\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n}\n"
    },
    "@sense-finance/v1-core/src/external/balancer/Pool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport { BalancerVault } from \"./Vault.sol\";\n\ninterface BalancerPool {\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        returns (uint256[] memory results);\n\n    enum Variable {\n        PAIR_PRICE,\n        BPT_PRICE,\n        INVARIANT\n    }\n    struct OracleAverageQuery {\n        Variable variable;\n        uint256 secs;\n        uint256 ago;\n    }\n\n    function getSample(uint256 index)\n        external\n        view\n        returns (\n            int256 logPairPrice,\n            int256 accLogPairPrice,\n            int256 logBptPrice,\n            int256 accLogBptPrice,\n            int256 logInvariant,\n            int256 accLogInvariant,\n            uint256 timestamp\n        );\n\n    function getPoolId() external view returns (bytes32);\n\n    function getVault() external view returns (address);\n\n    function totalSupply() external view returns (uint256);\n\n    struct SwapRequest {\n        BalancerVault.SwapKind kind;\n        ERC20 tokenIn;\n        ERC20 tokenOut;\n        uint256 amount;\n        // Misc data\n        bytes32 poolId;\n        uint256 lastChangeBlock;\n        address from;\n        address to;\n        bytes userData;\n    }\n\n    function onSwap(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) external returns (uint256 amount);\n\n    function getIndices() external view returns (uint256 pti, uint256 targeti);\n}\n"
    },
    "@sense-finance/v1-core/src/adapters/BaseFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// Internal references\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { BaseAdapter } from \"./BaseAdapter.sol\";\nimport { Divider } from \"../Divider.sol\";\n\nabstract contract BaseFactory {\n    /* ========== CONSTANTS ========== */\n\n    /// @notice Sets level to `31` by default, which keeps all Divider lifecycle methods public\n    /// (`issue`, `combine`, `collect`, etc), but not the `onRedeem` hook.\n    uint256 public constant DEFAULT_LEVEL = 31;\n\n    /* ========== PUBLIC IMMUTABLES ========== */\n\n    /// @notice Sense core Divider address\n    address public immutable divider;\n\n    /// @notice Protocol's data contract address\n    address public immutable protocol;\n\n    /// @notice target -> adapter\n    mapping(address => address) public adapters;\n\n    /// @notice params for adapters deployed with this factory\n    FactoryParams public factoryParams;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct FactoryParams {\n        address oracle; // oracle address\n        uint256 ifee; // issuance fee\n        address stake; // token to stake at issuance\n        uint256 stakeSize; // amount to stake at issuance\n        uint256 minm; // min maturity (seconds after block.timstamp)\n        uint256 maxm; // max maturity (seconds after block.timstamp)\n        uint16 mode; // 0 for monthly, 1 for weekly\n        uint64 tilt; // tilt\n    }\n\n    constructor(\n        address _divider,\n        address _protocol,\n        FactoryParams memory _factoryParams\n    ) {\n        divider = _divider;\n        protocol = _protocol;\n        factoryParams = _factoryParams;\n    }\n\n    /* ========== REQUIRED DEPLOY ========== */\n\n    /// @notice Deploys both an adapter and a target wrapper for the given _target\n    /// @param _target Address of the Target token\n    function deployAdapter(address _target) external virtual returns (address adapter) {}\n\n    /* ========== REQUIRED INTERNAL GUARD ========== */\n\n    /// @notice Target validity check that must be overriden by child contracts\n    function exists(address _target) external virtual returns (bool);\n\n    /* ========== LOGS ========== */\n\n    /// @notice Logs the deployment of the adapter\n    event AdapterAdded(address addr, address indexed target);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "@sense-finance/v1-fuse/src/external/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\nimport { CToken } from \"./CToken.sol\";\n\n/// @title Price Oracle\n/// @author Compound\n/// @notice The minimum interface a contract must implement in order to work as an oracle for Fuse with Sense\n/// Original from: https://github.com/Rari-Capital/compound-protocol/blob/fuse-final/contracts/PriceOracle.sol\nabstract contract PriceOracle {\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\n    bool public constant isPriceOracle = true;\n\n    /// @notice Get the underlying price of a cToken asset\n    /// @param cToken The cToken to get the underlying price of\n    /// @return The underlying asset price mantissa (scaled by 1e18).\n    /// 0 means the price is unavailable.\n    function getUnderlyingPrice(CToken cToken) external view virtual returns (uint256);\n\n    /// @notice Get the price of an underlying asset.\n    /// @param underlying The underlying asset to get the price of.\n    /// @return The underlying asset price in ETH as a mantissa (scaled by 1e18).\n    /// 0 means the price is unavailable.\n    function price(address underlying) external view virtual returns (uint256);\n}\n"
    },
    "@sense-finance/v1-fuse/src/external/BalancerOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\ninterface BalancerOracle {\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        returns (uint256[] memory results);\n\n    enum Variable {\n        PAIR_PRICE,\n        BPT_PRICE,\n        INVARIANT\n    }\n    struct OracleAverageQuery {\n        Variable variable;\n        uint256 secs;\n        uint256 ago;\n    }\n\n    function getSample(uint256 index)\n        external\n        view\n        returns (\n            int256 logPairPrice,\n            int256 accLogPairPrice,\n            int256 logBptPrice,\n            int256 accLogBptPrice,\n            int256 logInvariant,\n            int256 accLogInvariant,\n            uint256 timestamp\n        );\n\n    function getPoolId() external view returns (bytes32);\n\n    function getVault() external view returns (address);\n\n    function getIndices() external view returns (uint256 _pti, uint256 _targeti);\n\n    function totalSupply() external view returns (uint256);\n}\n"
    },
    "@sense-finance/v1-fuse/src/oracles/Underlying.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { PriceOracle } from \"../external/PriceOracle.sol\";\nimport { CToken } from \"../external/CToken.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\n// Internal references\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { FixedMath } from \"@sense-finance/v1-core/src/external/FixedMath.sol\";\nimport { BaseAdapter as Adapter } from \"@sense-finance/v1-core/src/adapters/BaseAdapter.sol\";\n\ncontract UnderlyingOracle is PriceOracle, Trust {\n    using FixedMath for uint256;\n\n    /// @notice underlying address -> adapter address\n    mapping(address => address) public adapters;\n\n    constructor() Trust(msg.sender) {}\n\n    function setUnderlying(address underlying, address adapter) external requiresTrust {\n        adapters[underlying] = adapter;\n    }\n\n    function getUnderlyingPrice(CToken cToken) external view override returns (uint256) {\n        return _price(address(cToken.underlying()));\n    }\n\n    function price(address underlying) external view override returns (uint256) {\n        return _price(underlying);\n    }\n\n    function _price(address underlying) internal view returns (uint256) {\n        address adapter = adapters[address(underlying)];\n        if (adapter == address(0)) revert Errors.AdapterNotSet();\n\n        return Adapter(adapter).getUnderlyingPrice();\n    }\n}\n"
    },
    "@sense-finance/v1-fuse/src/oracles/Target.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { PriceOracle } from \"../external/PriceOracle.sol\";\nimport { CToken } from \"../external/CToken.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\n// Internal references\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { Token } from \"@sense-finance/v1-core/src/tokens/Token.sol\";\nimport { FixedMath } from \"@sense-finance/v1-core/src/external/FixedMath.sol\";\nimport { BaseAdapter as Adapter } from \"@sense-finance/v1-core/src/adapters/BaseAdapter.sol\";\n\ncontract TargetOracle is PriceOracle, Trust {\n    using FixedMath for uint256;\n\n    /// @notice target address -> adapter address\n    mapping(address => address) public adapters;\n\n    constructor() Trust(msg.sender) {}\n\n    function setTarget(address target, address adapter) external requiresTrust {\n        adapters[target] = adapter;\n    }\n\n    function getUnderlyingPrice(CToken cToken) external view override returns (uint256) {\n        // For the sense Fuse pool, the underlying will be the Target. The semantics here can be a little confusing\n        // as we now have two layers of underlying, cToken -> Target (cToken's underlying) -> Target's underlying\n        Token target = Token(cToken.underlying());\n        return _price(address(target));\n    }\n\n    function price(address target) external view override returns (uint256) {\n        return _price(target);\n    }\n\n    function _price(address target) internal view returns (uint256) {\n        address adapter = adapters[address(target)];\n        if (adapter == address(0)) revert Errors.AdapterNotSet();\n\n        // Use the cached scale for view function compatibility\n        uint256 scale = Adapter(adapter).scaleStored();\n\n        // `Target / Target's underlying` * `Target's underlying / ETH` = `Price of Target in ETH`\n        //\n        // `scale` and the value returned by `getUnderlyingPrice` are expected to be WADs\n        return scale.fmul(Adapter(adapter).getUnderlyingPrice());\n    }\n}\n"
    },
    "@sense-finance/v1-fuse/src/oracles/PT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport { PriceOracle } from \"../external/PriceOracle.sol\";\nimport { CToken } from \"../external/CToken.sol\";\nimport { BalancerOracle } from \"../external/BalancerOracle.sol\";\nimport { BalancerVault } from \"@sense-finance/v1-core/src/external/balancer/Vault.sol\";\n\n// Internal references\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { Token } from \"@sense-finance/v1-core/src/tokens/Token.sol\";\nimport { FixedMath } from \"@sense-finance/v1-core/src/external/FixedMath.sol\";\nimport { BaseAdapter as Adapter } from \"@sense-finance/v1-core/src/adapters/BaseAdapter.sol\";\n\ninterface SpaceLike {\n    function getImpliedRateFromPrice(uint256 pTPriceInTarget) external view returns (uint256);\n\n    function getPriceFromImpliedRate(uint256 impliedRate) external view returns (uint256);\n\n    function getTotalSamples() external pure returns (uint256);\n\n    function adapter() external view returns (address);\n}\n\ncontract PTOracle is PriceOracle, Trust {\n    using FixedMath for uint256;\n\n    /// @notice PT address -> pool address for oracle reads\n    mapping(address => address) public pools;\n    /// @notice Minimum implied rate this oracle will tolerate for PTs\n    uint256 public floorRate;\n    uint256 public twapPeriod;\n\n    constructor() Trust(msg.sender) {\n        floorRate = 3e18; // 300%\n        twapPeriod = 5.5 hours;\n    }\n\n    function setFloorRate(uint256 _floorRate) external requiresTrust {\n        floorRate = _floorRate;\n    }\n\n    function setTwapPeriod(uint256 _twapPeriod) external requiresTrust {\n        twapPeriod = _twapPeriod;\n    }\n\n    function setPrincipal(address pt, address pool) external requiresTrust {\n        pools[pt] = pool;\n    }\n\n    function getUnderlyingPrice(CToken cToken) external view override returns (uint256) {\n        // The underlying here will be a Principal Token\n        return _price(cToken.underlying());\n    }\n\n    function price(address pt) external view override returns (uint256) {\n        return _price(pt);\n    }\n\n    function _price(address pt) internal view returns (uint256) {\n        BalancerOracle pool = BalancerOracle(pools[address(pt)]);\n        if (pool == BalancerOracle(address(0))) revert Errors.PoolNotSet();\n\n        // if getSample(buffer_size) returns 0s, the oracle buffer is not full yet and a price can't be read\n        // https://dev.balancer.fi/references/contracts/apis/pools/weightedpool2tokens#api\n        (, , , , , , uint256 sampleTs) = pool.getSample(SpaceLike(address(pool)).getTotalSamples() - 1);\n        // Revert if the pool's oracle can't be used yet, preventing this market from being deployed\n        // on Fuse until we're able to read a TWAP\n        if (sampleTs == 0) revert Errors.OracleNotReady();\n\n        BalancerOracle.OracleAverageQuery[] memory queries = new BalancerOracle.OracleAverageQuery[](1);\n        // The BPT price slot in Space carries the implied rate TWAP\n        queries[0] = BalancerOracle.OracleAverageQuery({\n            variable: BalancerOracle.Variable.BPT_PRICE,\n            secs: twapPeriod,\n            ago: 1 hours // take the oracle from 1 hour ago plus twapPeriod ago to 1 hour ago\n        });\n\n        uint256[] memory results = pool.getTimeWeightedAverage(queries);\n        // note: impliedRate is pulled from the BPT price slot in BalancerOracle.OracleAverageQuery\n        uint256 impliedRate = results[0];\n\n        if (impliedRate > floorRate) {\n            impliedRate = floorRate;\n        }\n\n        address target = Adapter(SpaceLike(address(pool)).adapter()).target();\n\n        // `Principal Token / target` * `target / ETH` = `Price of Principal Token in ETH`\n        //\n        // Assumes the caller is the master oracle, which will have its own strategy for getting the underlying price\n        return\n            SpaceLike(address(pool)).getPriceFromImpliedRate(impliedRate).fmul(PriceOracle(msg.sender).price(target));\n    }\n}\n"
    },
    "@sense-finance/v1-fuse/src/oracles/LP.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport { PriceOracle } from \"../external/PriceOracle.sol\";\nimport { CToken } from \"../external/CToken.sol\";\nimport { BalancerVault } from \"@sense-finance/v1-core/src/external/balancer/Vault.sol\";\nimport { BalancerPool } from \"@sense-finance/v1-core/src/external/balancer/Pool.sol\";\n\n// Internal references\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { FixedMath } from \"@sense-finance/v1-core/src/external/FixedMath.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\nimport { BaseAdapter as Adapter } from \"@sense-finance/v1-core/src/adapters/BaseAdapter.sol\";\n\ninterface SpaceLike {\n    function getFairBPTPriceInTarget(uint256 ptTwapDuration) external view returns (uint256);\n\n    function adapter() external view returns (address);\n}\n\ncontract LPOracle is PriceOracle, Trust {\n    using FixedMath for uint256;\n\n    /// @notice PT address -> pool address for oracle reads\n    mapping(address => address) public pools;\n    uint256 public twapPeriod;\n\n    constructor() Trust(msg.sender) {\n        twapPeriod = 5.5 hours;\n    }\n\n    function setTwapPeriod(uint256 _twapPeriod) external requiresTrust {\n        twapPeriod = _twapPeriod;\n    }\n\n    function getUnderlyingPrice(CToken cToken) external view override returns (uint256) {\n        // The underlying here will be an LP Token\n        return _price(cToken.underlying());\n    }\n\n    function price(address pt) external view override returns (uint256) {\n        return _price(pt);\n    }\n\n    function _price(address _pool) internal view returns (uint256) {\n        SpaceLike pool = SpaceLike(_pool);\n        address target = Adapter(pool.adapter()).target();\n\n        // Price per BPT in ETH terms, where the PT side of the pool is valued using the TWAP oracle\n        return pool.getFairBPTPriceInTarget(twapPeriod).fmul(PriceOracle(msg.sender).price(target));\n    }\n}\n"
    },
    "@sense-finance/v1-fuse/src/external/CToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n/// @title Price Oracle\n/// @author Compound\ninterface CToken {\n    function underlying() external view returns (address);\n\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@sense-finance/v1-core/src/adapters/CropFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// Internal references\nimport { BaseFactory } from \"./BaseFactory.sol\";\n\nabstract contract CropFactory is BaseFactory {\n    address public immutable reward;\n\n    constructor(\n        address _divider,\n        address _protocol,\n        FactoryParams memory _factoryParams,\n        address _reward\n    ) BaseFactory(_divider, _protocol, _factoryParams) {\n        reward = _reward;\n    }\n}\n"
    },
    "@sense-finance/v1-core/src/adapters/CropAdapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.11;\n\n// External references\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n// Internal references\nimport { Divider } from \"../Divider.sol\";\nimport { BaseAdapter } from \"./BaseAdapter.sol\";\nimport { FixedMath } from \"../external/FixedMath.sol\";\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\nabstract contract CropAdapter is BaseAdapter {\n    using SafeTransferLib for ERC20;\n    using FixedMath for uint256;\n\n    /// @notice Program state\n    address public immutable reward;\n    uint256 public share; // accumulated reward token per collected target\n    uint256 public rewardBal; // last recorded balance of reward token\n    uint256 public totalTarget;\n    mapping(address => uint256) public tBalance;\n    mapping(address => uint256) public rewarded; // reward token per user\n\n    event Distributed(address indexed usr, address indexed token, uint256 amount);\n\n    constructor(\n        address _divider,\n        address _target,\n        address _underlyng,\n        address _oracle,\n        uint256 _ifee,\n        address _stake,\n        uint256 _stakeSize,\n        uint256 _minm,\n        uint256 _maxm,\n        uint16 _mode,\n        uint64 _tilt,\n        uint256 _level,\n        address _reward\n    )\n        BaseAdapter(\n            _divider,\n            _target,\n            _underlyng,\n            _oracle,\n            _ifee,\n            _stake,\n            _stakeSize,\n            _minm,\n            _maxm,\n            _mode,\n            _tilt,\n            _level\n        )\n    {\n        reward = _reward;\n    }\n\n    function notify(\n        address _usr,\n        uint256 amt,\n        bool join\n    ) public override onlyDivider {\n        _distribute(_usr);\n        if (amt > 0) {\n            if (join) {\n                totalTarget += amt;\n                tBalance[_usr] += amt;\n            } else {\n                // else `exit`\n                totalTarget -= amt;\n                tBalance[_usr] -= amt;\n            }\n        }\n\n        rewarded[_usr] = tBalance[_usr].fmulUp(share, FixedMath.RAY);\n    }\n\n    /// @notice Distributes rewarded tokens to users proportionally based on their `tBalance`\n    /// @param _usr User to distribute reward tokens to\n    function _distribute(address _usr) internal {\n        _claimReward();\n\n        uint256 crop = ERC20(reward).balanceOf(address(this)) - rewardBal;\n        if (totalTarget > 0) share += (crop.fdiv(totalTarget, FixedMath.RAY));\n\n        uint256 last = rewarded[_usr];\n        uint256 curr = tBalance[_usr].fmul(share, FixedMath.RAY);\n        if (curr > last) {\n            unchecked {\n                ERC20(reward).safeTransfer(_usr, curr - last);\n            }\n        }\n        rewardBal = ERC20(reward).balanceOf(address(this));\n        emit Distributed(_usr, reward, curr > last ? curr - last : 0);\n    }\n\n    /// @notice Some protocols don't airdrop reward tokens, instead users must claim them.\n    /// This method may be overriden by child contracts to claim a protocol's rewards\n    function _claimReward() internal virtual {\n        return;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyDivider() {\n        if (divider != msg.sender) revert Errors.OnlyDivider();\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/v1-space/src/Errors.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.0;\n\n// solhint-disable\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n */\nfunction _require(bool condition, uint256 errorCode) pure {\n    if (!condition) _revert(errorCode);\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n */\nfunction _revert(uint256 errorCode) pure {\n    // We're going to dynamically create a revert string based on the error code, with the following format:\n    // 'SNS#{errorCode}'\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n    //\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n    // number (8 to 16 bits) than the individual string characters.\n    //\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n    assembly {\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n        // the '0' character.\n\n        let units := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let tenths := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let hundreds := add(mod(errorCode, 10), 0x30)\n\n        // With the individual characters, we can now construct the full string. The \"SNS#\" part is a known constant\n        // (0x3f534e5323): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n        // characters to it, each shifted by a multiple of 8.\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n        // array).\n\n        let revertReason := shl(200, add(0x3f534e5323000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\n\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n        // message will have the following layout:\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n        // The string length is fixed: 7 characters.\n        mstore(0x24, 7)\n        // Finally, the string itself is stored.\n        mstore(0x44, revertReason)\n\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n        revert(0, 100)\n    }\n}\n\nlibrary Errors {\n    // Space (using error codes as Space uses ^0.7.0)\n    uint256 internal constant CALLER_NOT_VAULT = 100;\n    uint256 internal constant INVALID_G1 = 101;\n    uint256 internal constant INVALID_G2 = 102;\n    uint256 internal constant INVALID_POOL_ID = 103;\n    uint256 internal constant POOL_ALREADY_DEPLOYED = 104;\n    uint256 internal constant POOL_PAST_MATURITY = 105;\n    uint256 internal constant SWAP_TOO_SMALL = 106;\n    uint256 internal constant NEGATIVE_RATE = 107;\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 108;\n}\n"
    },
    "@sense-finance/v1-core/src/tests/test-helpers/DSTest.sol": {
      "content": "// Taken from: https://github.com/dapphub/ds-test\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n    event log(string);\n    event logs(bytes);\n\n    event log_address(address);\n    event log_bytes32(bytes32);\n    event log_int(int256);\n    event log_uint(uint256);\n    event log_bytes(bytes);\n    event log_string(string);\n\n    event log_named_address(string key, address val);\n    event log_named_bytes32(string key, bytes32 val);\n    event log_named_decimal_int(string key, int256 val, uint256 decimals);\n    event log_named_decimal_uint(string key, uint256 val, uint256 decimals);\n    event log_named_int(string key, int256 val);\n    event log_named_uint(string key, uint256 val);\n    event log_named_bytes(string key, bytes val);\n    event log_named_string(string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS = address(bytes20(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n\n    modifier mayRevert() {\n        _;\n    }\n    modifier testopts(string memory) {\n        _;\n    }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint256 startGas = gasleft();\n        _;\n        uint256 endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(\n        address a,\n        address b,\n        string memory err\n    ) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(\n        bytes32 a,\n        bytes32 b,\n        string memory err\n    ) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n\n    function assertEq32(\n        bytes32 a,\n        bytes32 b,\n        string memory err\n    ) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int256 a, int256 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(\n        int256 a,\n        int256 b,\n        string memory err\n    ) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(uint256 a, uint256 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(\n        uint256 a,\n        uint256 b,\n        string memory err\n    ) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(string memory a, uint256 b) internal {\n        string memory errCode = string(abi.encodePacked(\"SNS#\", toString(b)));\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(errCode))) {\n            emit log(\"Error: a == b not satisfied [string|uint]\");\n            emit log_named_string(\"  Expected\", errCode);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\n        bytes memory tempEmptyStringTest = bytes(source);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n\n    function assertEqDecimal(\n        int256 a,\n        int256 b,\n        uint256 decimals\n    ) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n\n    function assertEqDecimal(\n        int256 a,\n        int256 b,\n        uint256 decimals,\n        string memory err\n    ) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEqDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 decimals\n    ) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n\n    function assertEqDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 decimals,\n        string memory err\n    ) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint256 a, uint256 b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n\n    function assertGt(\n        uint256 a,\n        uint256 b,\n        string memory err\n    ) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n\n    function assertGt(int256 a, int256 b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n\n    function assertGt(\n        int256 a,\n        int256 b,\n        string memory err\n    ) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n\n    function assertGtDecimal(\n        int256 a,\n        int256 b,\n        uint256 decimals\n    ) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n\n    function assertGtDecimal(\n        int256 a,\n        int256 b,\n        uint256 decimals,\n        string memory err\n    ) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGtDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 decimals\n    ) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n\n    function assertGtDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 decimals,\n        string memory err\n    ) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint256 a, uint256 b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n\n    function assertGe(\n        uint256 a,\n        uint256 b,\n        string memory err\n    ) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n\n    function assertGe(int256 a, int256 b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n\n    function assertGe(\n        int256 a,\n        int256 b,\n        string memory err\n    ) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n\n    function assertGeDecimal(\n        int256 a,\n        int256 b,\n        uint256 decimals\n    ) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n\n    function assertGeDecimal(\n        int256 a,\n        int256 b,\n        uint256 decimals,\n        string memory err\n    ) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGeDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 decimals\n    ) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n\n    function assertGeDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 decimals,\n        string memory err\n    ) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint256 a, uint256 b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n\n    function assertLt(\n        uint256 a,\n        uint256 b,\n        string memory err\n    ) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n\n    function assertLt(int256 a, int256 b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n\n    function assertLt(\n        int256 a,\n        int256 b,\n        string memory err\n    ) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n\n    function assertLtDecimal(\n        int256 a,\n        int256 b,\n        uint256 decimals\n    ) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n\n    function assertLtDecimal(\n        int256 a,\n        int256 b,\n        uint256 decimals,\n        string memory err\n    ) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLtDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 decimals\n    ) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n\n    function assertLtDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 decimals,\n        string memory err\n    ) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint256 a, uint256 b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n\n    function assertLe(\n        uint256 a,\n        uint256 b,\n        string memory err\n    ) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n\n    function assertLe(int256 a, int256 b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n\n    function assertLe(\n        int256 a,\n        int256 b,\n        string memory err\n    ) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n\n    function assertLeDecimal(\n        int256 a,\n        int256 b,\n        uint256 decimals\n    ) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n\n    function assertLeDecimal(\n        int256 a,\n        int256 b,\n        uint256 decimals,\n        string memory err\n    ) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLeDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 decimals\n    ) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n\n    function assertLeDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 decimals,\n        string memory err\n    ) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", a);\n            emit log_named_string(\"  Value b\", b);\n            fail();\n        }\n    }\n\n    function assertEq(\n        string memory a,\n        string memory b,\n        string memory err\n    ) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint256 i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n\n    function assertEq0(\n        bytes memory a,\n        bytes memory b,\n        string memory err\n    ) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n\n    /// @dev Converts a `uint256` to its ASCII `string` decimal representation.\n    /// @notice Taken from OpenZeppelin\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1500
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}