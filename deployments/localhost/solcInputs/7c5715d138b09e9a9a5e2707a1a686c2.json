{
  "language": "Solidity",
  "sources": {
    "src/Divider.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n// External references\nimport { SafeERC20, ERC20 } from \"@rari-capital/solmate/src/erc20/SafeERC20.sol\";\nimport { Trust } from \"@rari-capital/solmate/src/auth/Trust.sol\";\nimport { DateTime } from \"./external/DateTime.sol\";\nimport { FixedMath } from \"./external/FixedMath.sol\";\n\n// Internal references\nimport { Errors } from \"./libs/errors.sol\";\nimport { Claim } from \"./tokens/Claim.sol\";\nimport { BaseFeed as Feed } from \"./feeds/BaseFeed.sol\";\nimport { Token as Zero } from \"./tokens/Token.sol\";\nimport { wTarget } from \"./wrappers/wTarget.sol\";\n\n/// @title Sense Divider: Divide Assets in Two\n/// @author fedealconada + jparklev\n/// @notice You can use this contract to issue, combine, and redeem Sense ERC20 Zeros and Claims\ncontract Divider is Trust {\n    using SafeERC20 for ERC20;\n    using FixedMath for uint256;\n    using Errors for   string;\n\n    /// @notice Configuration\n    uint256 public constant ISSUANCE_FEE = 0.01e18; // In percentage (1%) [WAD] // TODO: TBD\n    uint256 public constant INIT_STAKE = 1e18; // Series initialisation stablecoin stake [WAD] // TODO: TBD\n    uint256 public constant SPONSOR_WINDOW = 4 hours; // TODO: TBD\n    uint256 public constant SETTLEMENT_WINDOW = 2 hours; // TODO: TBD\n    uint256 public constant MIN_MATURITY = 2 weeks; // TODO: TBD\n    uint256 public constant MAX_MATURITY = 14 weeks; // TODO: TBD\n\n    string private constant ZERO_SYMBOL_PREFIX = \"z\";\n    string private constant ZERO_NAME_PREFIX = \"Zero\";\n    string private constant CLAIM_SYMBOL_PREFIX = \"c\";\n    string private constant CLAIM_NAME_PREFIX = \"Claim\";\n\n    /// @notice Mutable program state\n    address public stable;\n    address public    cup;\n    mapping(address => bool   ) public feeds;  // feed -> approved\n    mapping(address => uint256) public guards; // target -> max amount of Target allowed to be issued\n    mapping(address => address) public wtargets;  // target -> target wrapper\n    mapping(address => mapping(uint256 => Series)) public series; // feed -> maturity -> series\n    mapping(address => mapping(uint256 => mapping(address => uint256))) public lscales; // feed -> maturity -> account -> lscale\n    struct Series {\n        address zero; // Zero address for this Series (deployed on Series initialization)\n        address claim; // Claim address for this Series (deployed on Series initialization)\n        address sponsor; // Series initializer/sponsor\n        uint256 issuance; // Issuance date for this Series (needed for Zero redemption)\n        uint256 reward; // Tracks the fees due to the settler on Settlement\n        uint256 iscale; // Scale value at issuance\n        uint256 mscale; // Scale value at maturity\n    }\n\n    constructor(address _stable, address _cup) Trust(msg.sender) {\n        stable = _stable;\n        cup    = _cup;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /// @notice Initializes a new Series\n    /// @dev Deploys two ERC20 contracts, one for each Zero type\n    /// @dev Transfers some fixed amount of stable asset to this contract\n    /// @param feed Feed to associate with the Series\n    /// @param maturity Maturity date for the new Series, in units of unix time\n    function initSeries(address feed, uint256 maturity) external returns (address zero, address claim) {\n        require(feeds[feed], Errors.InvalidFeed);\n        require(!_exists(feed, maturity), Errors.DuplicateSeries);\n        require(_isValid(maturity), Errors.InvalidMaturity);\n\n        // Transfer stable asset stake from caller to this contract\n        ERC20(stable).safeTransferFrom(msg.sender, address(this), INIT_STAKE);\n\n        // Deploy Zeros and Claims for this new Series\n        (zero, claim) = _split(feed, maturity);\n\n        // Initialize the new Series struct\n        Series memory newSeries = Series({\n            zero : zero,\n            claim : claim,\n            sponsor : msg.sender,\n            issuance : block.timestamp,\n            reward : 0,\n            iscale : Feed(feed).scale(),\n            mscale : 0\n        });\n        series[feed][maturity] = newSeries;\n\n        emit SeriesInitialized(feed, maturity, zero, claim, msg.sender);\n    }\n\n    /// @notice Settles a Series and transfer the settlement reward to the caller\n    /// @dev The Series' sponsor has a buffer where only they can settle the Series\n    /// @dev After the buffer, the reward becomes MEV\n    /// @param feed Feed to associate with the Series\n    /// @param maturity Maturity date for the new Series\n    function settleSeries(address feed, uint256 maturity) external {\n        require(feeds[feed], Errors.InvalidFeed);\n        require(_exists(feed, maturity), Errors.SeriesDoesntExists);\n        require(_canBeSettled(feed, maturity), Errors.OutOfWindowBoundaries);\n\n        // The maturity scale value is all a Series needs for us to consider it \"settled\"\n        series[feed][maturity].mscale = Feed(feed).scale();\n\n        // Reward the caller for doing the work of settling the Series at around the correct time\n        ERC20 target = ERC20(Feed(feed).target());\n        target.safeTransferFrom(wtargets[address(target)], msg.sender, series[feed][maturity].reward);\n        ERC20(stable).safeTransfer(msg.sender, INIT_STAKE);\n\n        emit SeriesSettled(feed, maturity, msg.sender);\n    }\n\n    /// @notice Mint Zeros and Claims of a specific Series\n    /// @param feed Feed address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param tBal Balance of Target to deposit\n    /// the amount of Zeros/Claims minted will be the equivelent value in units of underlying (less fees)\n    function issue(address feed, uint256 maturity, uint256 tBal) external {\n        require(feeds[feed], Errors.InvalidFeed);\n        require(_exists(feed, maturity), Errors.SeriesDoesntExists);\n        require(!_settled(feed, maturity), Errors.IssueOnSettled);\n\n        ERC20 target = ERC20(Feed(feed).target());\n        uint256 tDecimals = target.decimals();\n        uint256 tBase = 10 ** tDecimals;\n        uint256 fee;\n\n        // Ensure the caller won't hit the issuance cap with this action\n        require(target.balanceOf(address(this)) + tBal <= guards[address(target)], Errors.GuardCapReached);\n        target.safeTransferFrom(msg.sender, wtargets[address(target)], tBal);\n\n        // Take the issuance fee out of the deposited Target, and put it towards the settlement\n        if (tDecimals != 18) {\n            fee = (tDecimals < 18 ? ISSUANCE_FEE / (10**(18 - tDecimals)) : ISSUANCE_FEE * 10**(tDecimals - 18)).fmul(tBal, tBase);\n        } else {\n            fee = ISSUANCE_FEE.fmul(tBal, tBase);\n        }\n\n        series[feed][maturity].reward += fee;\n        uint256 tBalSubFee = tBal - fee;\n\n        // If the caller has collected on Claims before, use the scale value from that collection to determine how many Zeros/Claims to mint\n        // so that the Claims they mint here will have the same amount of yield stored up as their existing holdings\n        uint256 scale = lscales[feed][maturity][msg.sender];\n\n        // If the caller has not collected on Claims before, use the current scale value to determine how many Zeros/Claims to mint\n        // so that the Claims they mint here are \"clean,\" in that they have no yet-to-be-collected yield\n        if (scale == 0) {\n            scale = Feed(feed).scale();\n            lscales[feed][maturity][msg.sender] = scale;\n        }\n\n        // Determine the amount of Underlying equal to the Target being sent in (the principal)\n        uint256 uBal = tBalSubFee.fmul(scale, Zero(series[feed][maturity].zero).BASE_UNIT());\n\n        // Mint equal amounts of Zeros and Claims\n        Zero(series[feed][maturity].zero  ).mint(msg.sender, uBal);\n        Claim(series[feed][maturity].claim).mint(msg.sender, uBal);\n\n        emit Issued(feed, maturity, uBal, msg.sender);\n    }\n\n    /// @notice Reconstitute Target by burning Zeros and Claims\n    /// @dev Explicitly burns claims before maturity, and implicitly does it at/after maturity through collect()\n    /// @param feed Feed address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal Balance of Zeros and Claims to burn\n    function combine(address feed, uint256 maturity, uint256 uBal) external {\n        require(feeds[feed], Errors.InvalidFeed);\n        require(_exists(feed, maturity), Errors.SeriesDoesntExists);\n\n        Zero(series[feed][maturity].zero).burn(msg.sender, uBal);\n        _collect(msg.sender, feed, maturity, uBal, address(0));\n        if (block.timestamp < maturity) Claim(series[feed][maturity].claim).burn(msg.sender, uBal);\n\n        // We use lscale since the current scale was already stored there by the _collect() call\n        uint256 cscale = _settled(feed, maturity) ? series[feed][maturity].mscale : lscales[feed][maturity][msg.sender];\n\n        // Convert from units of Underlying to units of Target\n        uint256 tBal = uBal.fdiv(cscale, 10**ERC20(Feed(feed).target()).decimals());\n        ERC20 target = ERC20(Feed(feed).target());\n        target.safeTransferFrom(wtargets[address(target)], msg.sender, tBal);\n\n        emit Combined(feed, maturity, tBal, msg.sender);\n    }\n\n    /// @notice Burn Zeros of a Series once its been settled\n    /// @dev The balance of redeemable Target is a function of the change in Scale\n    /// @param feed Feed address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal Amount of Zeros to burn, which should be equivelent to the amount of Underlying owed to the caller\n    function redeemZero(address feed, uint256 maturity, uint256 uBal) external {\n        require(feeds[feed], Errors.InvalidFeed);\n        // If a Series is settled, we know that it must have existed as well, so that check is unnecessary\n        require(_settled(feed, maturity), Errors.NotSettled);\n        // Burn the caller's Zeros\n        Zero(series[feed][maturity].zero).burn(msg.sender, uBal);\n\n        // Calculate the amount of Target the caller is owed (amount of Target that's\n        // equivelent to their principal in Underlying), then send it them\n        uint256 tBal = uBal.fdiv(series[feed][maturity].mscale, 10**ERC20(Feed(feed).target()).decimals()); // Sensitive to precision loss\n        ERC20 target = ERC20(Feed(feed).target());\n        target.safeTransferFrom(wtargets[address(target)], msg.sender, tBal);\n\n        emit Redeemed(feed, maturity, tBal);\n    }\n\n    /// @notice Collect Claim excess before, at, or after maturity\n    /// @dev Burns the claim tokens if it's currently at or after maturity as this will be the last possible collect\n    /// @dev If `to` is set, we copy the lscale value from usr to this address\n    /// @param usr User who's collecting for their Claims\n    /// @param feed Feed address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param to address to set the lscale value from usr\n    function collect(\n        address usr,\n        address feed,\n        uint256 maturity,\n        address to\n    ) external onlyClaim(feed, maturity) returns (uint256 collected) {\n        return _collect(usr,\n            feed,\n            maturity,\n            Claim(msg.sender).balanceOf(usr),\n            to\n        );\n    }\n\n    function _collect(\n        address usr,\n        address feed,\n        uint256 maturity,\n        uint256 uBal,\n        address to\n    ) internal returns (uint256 collected) {\n        require(feeds[feed], Errors.InvalidFeed);\n        require(_exists(feed, maturity), Errors.SeriesDoesntExists);\n\n        // Get the scale value from the last time this holder collected\n        uint256 cscale = series[feed][maturity].mscale;\n        uint256 lscale = lscales[feed][maturity][usr];\n        Claim claim = Claim(series[feed][maturity].claim);\n        ERC20 target = ERC20(Feed(feed).target());\n\n        // If this is the Claim holder's first time collecting and nobody sent these Claims to them,\n        // set the \"last scale\" value to the scale at issuance for this series\n        if (lscale == 0) lscale = series[feed][maturity].iscale;\n\n        // If we're past maturity, this Series must be settled before collect can be called\n        if (_settled(feed, maturity)) {\n            claim.burn(usr, uBal);\n        } else {\n            // If we're not settled and we're past maturity + the sponsor window,\n            // anyone can settle this Series so revert until someone does\n            if (block.timestamp > maturity + SPONSOR_WINDOW) {\n                revert(Errors.CollectNotSettled);\n            } else {\n                cscale = Feed(feed).scale();\n                lscales[feed][maturity][usr] = cscale;\n            }\n        }\n\n        // Determine how much yield has accrued since the last time this user collected, in units of Target.\n        // (Or take the last time as issuance if they haven't yet.)\n        // Reminder that `Underlying / Scale` = `Target`, so this equation is saying, for some amount of Underlying `u`:\n        // \"Target balance that equaled `u` at last collection _minus_ Target balance that equals `u` now\".\n        // Because scale must be increasing, the Target balance needed to equal `u` decreases, and that \"excess\"\n        // is what Claim holders are collecting\n        collected = uBal.fdiv(lscale, claim.BASE_UNIT()) - uBal.fdiv(cscale, claim.BASE_UNIT());\n        target.safeTransferFrom(wtargets[address(target)], usr, collected);\n\n        wTarget(wtargets[address(target)]).distribute(feed, maturity, usr, collected); // distribute airdrop tokens\n\n        // If this collect is a part of a token transfer to another address, set the receiver's\n        // last collection to this scale (as all yield is being stripped off before the Claims are sent)\n        if (to != address(0)) {\n            lscales[feed][maturity][to] = cscale;\n        }\n\n        emit Collected(feed, maturity, collected);\n    }\n\n    /* ========== ADMIN FUNCTIONS ========== */\n\n    /// @notice Enable or disable a feed\n    /// @param feed Feed's address\n    /// @param isOn Flag setting this feed to enabled or disabled\n    function setFeed(address feed, bool isOn) external requiresTrust {\n        require(feeds[feed] != isOn, Errors.ExistingValue);\n        feeds[feed] = isOn;\n        emit FeedChanged(feed, isOn);\n    }\n\n    /// @notice Set target's guard\n    /// @param target Target address\n    /// @param cap The max target that can be deposited on the Divider\n    function setGuard(address target, uint256 cap) external requiresTrust {\n        guards[target] = cap;\n        emit GuardChanged(target, cap);\n    }\n\n    /// @notice Adds wrapped target to wtargets mapping\n    /// @param wtarget Wrapped Target address\n    function setWrapper(address wtarget) external requiresTrust {\n        address target = wTarget(wtarget).target();\n        require(wtargets[target] == address(0), Errors.ExistingValue);\n        wtargets[target] = wtarget;\n        emit WTargetAdded(wtarget);\n    }\n\n    struct Backfill {\n        address usr;   // Address of the user who's getting their lscale backfilled\n        uint256 lscale; // Scale value to backfill for usr's lscale\n    }\n\n    /// @notice Backfill a Series' Scale value at maturity if keepers failed to settle it\n    /// @param feed Feed's address\n    /// @param maturity Maturity date for the Series\n    /// @param mscale Value to set as the Series' Scale value at maturity\n    /// @param backfills Values to set on lscales mapping\n    function backfillScale(\n        address feed,\n        uint256 maturity,\n        uint256 mscale,\n        Backfill[] memory backfills\n    ) external requiresTrust {\n        require(_exists(feed, maturity), Errors.SeriesDoesntExists);\n        require(mscale > series[feed][maturity].iscale, Errors.InvalidScaleValue);\n\n        uint256 cutoff = maturity + SPONSOR_WINDOW + SETTLEMENT_WINDOW;\n        // If the feed is disabled, it will allow the admin to backfill no matter the maturity\n        require(!feeds[feed] || block.timestamp > cutoff, Errors.OutOfWindowBoundaries);\n\n        // Set the maturity scale for the Series (needed for `redeem` methods)\n        series[feed][maturity].mscale = mscale;\n        // Set user's last scale values the Series (needed for the `collect` method)\n        for (uint i = 0; i < backfills.length; i++) {\n            lscales[feed][maturity][backfills[i].usr] = backfills[i].lscale;\n        }\n\n        // Determine where the rewards should go depending on where we are relative to the maturity date\n        address rewardee = block.timestamp <= maturity + SPONSOR_WINDOW ? series[feed][maturity].sponsor : cup;\n        ERC20 target = ERC20(Feed(feed).target());\n        target.safeTransferFrom(wtargets[address(target)], cup, series[feed][maturity].reward);\n        ERC20(stable).safeTransfer(rewardee, INIT_STAKE);\n\n        emit Backfilled(feed, maturity, mscale, backfills);\n    }\n\n    /* ========== INTERNAL VIEWS ========== */\n\n    function _exists(address feed, uint256 maturity) internal view returns (bool exists) {\n        return address(series[feed][maturity].zero) != address(0);\n    }\n\n    function _settled(address feed, uint256 maturity) internal view returns (bool settled) {\n        return series[feed][maturity].mscale > 0;\n    }\n\n    function _canBeSettled(address feed, uint256 maturity) internal view returns (bool canBeSettled) {\n        require(!_settled(feed, maturity), Errors.AlreadySettled);\n        uint256 cutoff = maturity + SPONSOR_WINDOW + SETTLEMENT_WINDOW;\n        // If the sender is the sponsor for the Series\n        if (msg.sender == series[feed][maturity].sponsor) {\n            return maturity - SPONSOR_WINDOW <= block.timestamp && cutoff >= block.timestamp;\n        } else {\n            return maturity + SPONSOR_WINDOW < block.timestamp && cutoff >= block.timestamp;\n        }\n    }\n\n    function _isValid(uint256 maturity) internal view returns (bool valid) {\n        if (maturity < block.timestamp + MIN_MATURITY || maturity > block.timestamp + MAX_MATURITY) return false;\n\n        (, , uint256 day, uint256 hour, uint256 minute, uint256 second) = DateTime.timestampToDateTime(maturity);\n        if (day != 1 || hour != 0 || minute != 0 || second != 0) return false;\n        return true;\n    }\n\n    /* ========== INTERNAL HELPERS ========== */\n\n    function _split(address feed, uint256 maturity) internal returns (address zero, address claim) {\n        ERC20 target = ERC20(Feed(feed).target());\n        uint8 decimals = target.decimals();\n        (, string memory m, string memory y) = DateTime.toDateString(maturity);\n        string memory datestring = string(abi.encodePacked(m, \"-\", y));\n\n        string memory zname = string(abi.encodePacked(target.name(), \" \", datestring, \" \", ZERO_NAME_PREFIX, \" \", \"by Sense\"));\n        string memory zsymbol = string(abi.encodePacked(ZERO_SYMBOL_PREFIX, target.symbol(), \":\", datestring));\n        zero = address(new Zero(zname, zsymbol, decimals));\n\n        string memory cname = string(abi.encodePacked(target.name(), \" \", datestring, \" \", CLAIM_NAME_PREFIX, \" \", \"by Sense\"));\n        string memory csymbol = string(abi.encodePacked(CLAIM_SYMBOL_PREFIX, target.symbol(), \":\", datestring));\n        claim = address(new Claim(maturity, address(this), feed, cname, csymbol, decimals));\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyClaim(address feed, uint256 maturity) {\n        require(series[feed][maturity].claim == msg.sender, \"Can only be invoked by the Claim contract\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event Backfilled(address indexed feed, uint256 indexed maturity, uint256 mscale, Backfill[] backfills);\n    event Collected(address indexed feed, uint256 indexed maturity, uint256 collected);\n    event Combined(address indexed feed, uint256 indexed maturity, uint256 balance, address indexed sender);\n    event GuardChanged(address indexed target, uint256 indexed cap);\n    event FeedChanged(address indexed feed, bool isOn);\n    event Issued(address indexed feed, uint256 indexed maturity, uint256 balance, address indexed sender);\n    event Redeemed(address indexed feed, uint256 indexed maturity, uint256 redeemed);\n    event SeriesInitialized(address indexed feed, uint256 indexed maturity, address zero, address claim, address indexed sponsor);\n    event SeriesSettled(address indexed feed, uint256 indexed maturity, address indexed settler);\n    event WTargetAdded(address indexed wtarget);\n}\n"
    },
    "@rari-capital/solmate/src/erc20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\n/// @notice Safe ERC20 and ETH transfer library that safely handles missing return values.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\nlibrary SafeERC20 {\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(ERC20.transferFrom.selector, from, to, value)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(ERC20.transfer.selector, to, value)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(ERC20.approve.selector, to, value)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "@rari-capital/solmate/src/auth/Trust.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.0;\n\n/// @notice Ultra minimal authorization logic for smart contracts.\n/// @author Inspired by Dappsys V2 (https://github.com/dapp-org/dappsys-v2/blob/main/src/auth.sol)\nabstract contract Trust {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserTrustUpdated(address indexed user, bool trusted);\n\n    /*///////////////////////////////////////////////////////////////\n                              TRUST STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bool) public isTrusted;\n\n    constructor(address user) {\n        isTrusted[user] = true;\n\n        emit UserTrustUpdated(user, true);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         TRUST MODIFIER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function setIsTrusted(address user, bool trusted) public requiresTrust {\n        isTrusted[user] = trusted;\n\n        emit UserTrustUpdated(user, trusted);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              TRUST LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    modifier requiresTrust() {\n        require(isTrusted[msg.sender], \"UNTRUSTED\");\n\n        _;\n    }\n}\n"
    },
    "src/external/DateTime.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n// ----------------------------------------------------------------------------\n// DateTime Library v2.0\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary DateTime {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 constant SECONDS_PER_MINUTE = 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    function timestampToDate(uint256 timestamp) internal pure returns (uint256 year, uint256 month, uint256 day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function timestampToDateTime(uint256 timestamp) internal pure returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function toDateString(uint256 _timestamp) internal pure returns (string memory d, string memory m, string memory y) {\n        (uint256 year, uint256 month, uint256 day) = timestampToDate(_timestamp);\n        d = uintToString(day);\n        m = uintToString(month);\n        y = uintToString(year);\n    }\n\n    /// Taken from https://stackoverflow.com/questions/47129173/how-to-convert-uint-to-string-in-solidity\n    function uintToString(uint _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) return \"0\";\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint256 year, uint256 month, uint256 day) internal pure returns (uint256 _days) {\n        require(year >= 1970);\n        int256 _year = int256(year);\n        int256 _month = int256(month);\n        int256 _day = int256(day);\n\n        int256 __days =\n        _day -\n        32075 +\n        (1461 * (_year + 4800 + (_month - 14) / 12)) /\n        4 +\n        (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\n        12 -\n        (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\n        4 -\n        OFFSET19700101;\n\n        _days = uint256(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days) internal pure returns (uint256 year, uint256 month, uint256 day) {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n}\n"
    },
    "src/external/FixedMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.6;\n\n/// @title Fixed point arithmetic library\n/// @author Taken from https://github.com/yieldprotocol/yield-utils-v2/blob/main/contracts/math/WDiv.sol & https://github.com/yieldprotocol/yield-utils-v2/blob/main/contracts/math/WMul.sol\nlibrary FixedMath {\n\n    /// Taken from https://github.com/usmfum/USM/blob/master/contracts/FixedMath.sol\n    /// @dev Multiply an amount by a fixed point factor with 18 decimals, rounds down\n    function fmul(uint256 x, uint256 y, uint256 baseUnit) internal pure returns (uint256 z) {\n        z = x * y;\n    unchecked { z /= baseUnit; }\n    }\n\n    /// Taken from https://github.com/usmfum/USM/blob/master/contracts/FixedMath.sol\n    /// @dev Divide an amount by a fixed point factor with 18 decimals, rounds down\n    function fdiv(uint256 x, uint256 y, uint256 baseUnit) internal pure returns (uint256 z) {\n        z = (x * baseUnit) / y;\n    }\n\n}\n"
    },
    "src/libs/errors.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n/// @notice Program error types\nlibrary Errors {\n    string constant AlreadySettled = \"Series has already been settled\";\n    string constant CollectNotSettled = \"Cannot collect if Series is at or after maturity and it has not been settled\";\n    string constant DuplicateSeries = \"Series with given maturity already exists\";\n    string constant ExistingValue = \"New value must be different than previous\";\n    string constant FeedAlreadyExists = \"Feed already exists\";\n    string constant GuardCapReached = \"Issuance cap reached\";\n    string constant IssueOnSettled = \"Cannot issue if Series is settled\";\n    string constant InvalidFeed = \"Invalid feed address or feed is not enabled\";\n    string constant InvalidMaturity = \"Maturity date is not valid\";\n    string constant InvalidScaleValue = \"Scale value is invalid\";\n    string constant NotAuthorized = \"UNTRUSTED\"; // We copy the error message used by solmate's `Trust` auth lib\n    string constant NotEnoughClaims = \"Not enough claims to collect given target balance\";\n    string constant SeriesDoesntExists = \"Series does not exist\";\n    string constant NotSettled = \"Series must be settled\";\n    string constant NotSupported = \"Target is not supported\";\n    string constant OutOfWindowBoundaries = \"Can not settle Series outside the time window boundaries\";\n    string constant TransferFromFailed = \"TRANSFER_FROM_FAILED\";\n    string constant ZeroBalance = \"Balance must be greater than 0\";\n}\n"
    },
    "src/tokens/Claim.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n// Internal references\nimport { Divider } from \"../Divider.sol\";\nimport { Token } from \"./Token.sol\";\n\n/// @title Claim token contract that allows excess collection pre-maturity\ncontract Claim is Token {\n    uint256 public maturity;\n    address public divider;\n    address public feed;\n\n    constructor(\n        uint256 _maturity,\n        address _divider,\n        address _feed,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) Token(_name, _symbol, _decimals) {\n        maturity = _maturity;\n        divider = _divider;\n        feed = _feed;\n    }\n\n    function collect() external returns (uint256 _collected) {\n        return Divider(divider).collect(msg.sender, feed, maturity, address(0));\n    }\n\n    function transfer(address to, uint256 value) public override returns (bool) {\n        Divider(divider).collect(msg.sender, feed, maturity, to);\n        super.transfer(to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public override returns (bool) {\n        Divider(divider).collect(from, feed, maturity, to);\n        super.transferFrom(from, to, value);\n        return true;\n    }\n}\n"
    },
    "src/feeds/BaseFeed.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n// External references\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { ERC20 } from \"@rari-capital/solmate/src/erc20/ERC20.sol\";\nimport { FixedMath } from \"../external/FixedMath.sol\";\n\n// Internal references\nimport { Divider } from \"../Divider.sol\";\nimport { Errors } from \"../libs/errors.sol\";\n\n/// @title Assign time-based value to target assets\n/// @dev In most cases, the only function that will be unique to each feed type is `scale`\nabstract contract BaseFeed is Initializable {\n    using FixedMath for uint256;\n\n    address public target;\n    address public divider; // TODO: must be hardcoded!\n    uint256 public delta;\n    string public name;\n    string public symbol;\n    LScale public lscale;\n\n    struct LScale {\n        uint256 timestamp; // timestamp of the last scale value\n        uint256 value; // last scale value\n    }\n\n    function initialize(\n        address _target,\n        address _divider,\n        uint256 _delta\n    ) external virtual initializer {\n        // TODO: only factory?\n        // TODO: add input validation?\n        divider = _divider;\n        delta = _delta;\n        target = _target;\n        name = string(abi.encodePacked(ERC20(target).name(), \" Yield\"));\n        symbol = string(abi.encodePacked(ERC20(target).symbol(), \"-yield\"));\n        emit Initialized();\n    }\n\n    /// @notice Calculate and return this feed's Scale value for the current timestamp\n    /// @dev For some Targets, such as cTokens, this is simply the exchange rate,\n    /// or `supply cToken / supply underlying`\n    /// @dev For other Targets, such as AMM LP shares, specialized logic will be required\n    /// @return _value WAD Scale value\n    function scale() external virtual returns (uint256 _value) {\n        _value = _scale();\n        uint256 lvalue = lscale.value;\n        require(_value >= lvalue, Errors.InvalidScaleValue);\n        uint256 timeDiff = block.timestamp - lscale.timestamp;\n        if (timeDiff > 0 && lvalue != 0) {\n            uint256 growthPerSec = (_value - lvalue).fdiv(lvalue * timeDiff, 10**ERC20(target).decimals());\n            if (growthPerSec > delta) revert(Errors.InvalidScaleValue);\n        }\n        if (_value != lscale.value) {\n            // update value only if different than previous\n            lscale.value = _value;\n            lscale.timestamp = block.timestamp;\n        }\n    }\n\n    /// @notice Actual scale value check that must be overriden by child contracts\n    function _scale() internal virtual returns (uint256 _value);\n\n    event Initialized();\n}\n"
    },
    "src/tokens/Token.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n// External references\nimport { ERC20 } from \"@rari-capital/solmate/src/erc20/ERC20.sol\";\nimport { Trust } from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\ncontract Token is ERC20, Trust {\n    uint256 public immutable BASE_UNIT;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) Trust(msg.sender) {\n        BASE_UNIT = 10**_decimals;\n    }\n\n    /// @param usr The address to send the minted tokens\n    /// @param amount The amount to be minted\n    function mint(address usr, uint256 amount) public requiresTrust {\n        _mint(usr, amount);\n        emit Mint(usr, amount);\n    }\n\n    /// @param usr The address from where to burn tokens from\n    /// @param amount The amount to be burned\n    function burn(address usr, uint256 amount) public requiresTrust {\n        _burn(usr, amount);\n        emit Burn(usr, amount);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event Mint(address indexed usr, uint256 amount);\n    event Burn(address indexed usr, uint256 amount);\n}\n"
    },
    "src/wrappers/wTarget.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n// External references\nimport { ERC20, SafeERC20 } from \"@rari-capital/solmate/src/erc20/SafeERC20.sol\";\nimport { Trust } from \"@rari-capital/solmate/src/auth/Trust.sol\";\nimport { FixedMath } from \"../external/FixedMath.sol\";\n\n// Internal\nimport { Divider } from \"../Divider.sol\";\nimport { BaseFeed as Feed } from \"../feeds/BaseFeed.sol\";\n\n/// @notice\ncontract wTarget is Trust {\n    using SafeERC20 for ERC20;\n    using FixedMath for uint256;\n\n    /// @notice Configuration\n    uint256 MAX_INT = 2**256 - 1;\n\n    /// @notice Mutable program state\n    address public target;\n    address public airdropToken;\n    address public divider;\n    mapping(address => uint256) public tBalances; // usr -> amount of airdrop tokens distributed\n    mapping(address => uint256) public distributed; // usr -> amount of airdrop tokens distributed\n\n    constructor(\n        address _target,\n        address _divider,\n        address _airdropToken\n    ) Trust(msg.sender) {\n        target = _target;\n        airdropToken = _airdropToken;\n        divider = _divider;\n        ERC20(target).approve(divider, MAX_INT);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /// @notice Distributes airdropped tokens to Claim holders proportionally based on Claim balance\n    /// @param _feed Feed to associate with the Series\n    /// @param _maturity Maturity date\n    /// @param _usr User to distribute airdrop tokens to\n    function distribute(\n        address _feed,\n        uint256 _maturity,\n        address _usr,\n        uint256 collected\n    ) external {\n        (, address claim, , , , , ) = Divider(divider).series(_feed, _maturity);\n        // uint256 scale = Divider(msg.sender).lscales(_feed, _maturity, _usr);\n        // uint256 tBal = ERC20(_zero).balanceOf(_usr).fdiv(scale, 10**ERC20(target).decimals());\n        // uint amount = (tBal / ERC20(target).balanceOf(address(this))) *\n        // ERC20(airdropToken).balanceOf(address(this)) - distributed[_usr];\n        uint256 amount = ERC20(claim).totalSupply() == 0\n            ? 0\n            : (ERC20(claim).balanceOf(_usr) / ERC20(claim).totalSupply()) *\n                (ERC20(airdropToken).balanceOf(address(this)) - distributed[_usr]);\n        // uint amount = ERC20(claim).totalSupply() == 0\n        // ? 0\n        // : (ERC20(claim).balanceOf(_usr) / ERC20(claim).totalSupply()) *\n        // ERC20(airdropToken).balanceOf(address(this)) - distributed[_usr];\n        emit Hi(ERC20(claim).totalSupply());\n        emit Hi(ERC20(claim).balanceOf(_usr));\n        emit Hi((ERC20(claim).balanceOf(_usr) / ERC20(claim).totalSupply()));\n        emit Hi(ERC20(airdropToken).balanceOf(address(this)));\n        emit Hi(amount);\n\n        distributed[_usr] += amount;\n        ERC20(airdropToken).transfer(_usr, amount);\n        emit Distributed(_usr, airdropToken, amount);\n    }\n\n    /* ========== EVENTS ========== */\n    event Distributed(address indexed usr, address indexed token, uint256 indexed amount);\n    event Hi(uint256 h);\n}\n"
    },
    "@rari-capital/solmate/src/erc20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                         PERMIT/EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    bytes32 public immutable DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        allowance[msg.sender][spender] = value;\n\n        emit Approval(msg.sender, spender, value);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        balanceOf[msg.sender] -= value;\n\n        // This is safe because the sum of all user\n        // balances can't exceed type(uint256).max!\n        unchecked {\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(msg.sender, to, value);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public virtual returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] -= value;\n        }\n\n        balanceOf[from] -= value;\n\n        // This is safe because the sum of all user\n        // balances can't exceed type(uint256).max!\n        unchecked {\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          PERMIT/EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_PERMIT_SIGNATURE\");\n\n        allowance[recoveredAddress][spender] = value;\n\n        emit Approval(owner, spender, value);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          INTERNAL UTILS\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply += value;\n\n        // This is safe because the sum of all user\n        // balances can't exceed type(uint256).max!\n        unchecked {\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] -= value;\n\n        // This is safe because a user won't ever\n        // have a balance larger than totalSupply!\n        unchecked {\n            totalSupply -= value;\n        }\n\n        emit Transfer(from, address(0), value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "src/tests/test-helpers/Factory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.6;\n\n// Internal references\nimport { Divider } from \"../../Divider.sol\";\n\ncontract Factory {\n    event Deployed(address addr, uint salt);\n\n    // 1. Get bytecode of contract to be deployed\n    // NOTE: _owner and _foo are arguments of the TestContract's constructor\n    function getBytecode(address _owner, uint _foo) public pure returns (bytes memory) {\n        bytes memory bytecode = type(Divider).creationCode;\n\n        return abi.encodePacked(bytecode, abi.encode(_owner, _foo));\n    }\n\n    // 2. Compute the address of the contract to be deployed\n    // NOTE: _salt is a random number used to create an address\n    function getAddress(bytes memory bytecode, uint _salt)\n    public\n    view\n    returns (address)\n    {\n        bytes32 hash = keccak256(\n            abi.encodePacked(bytes1(0xff), address(this), _salt, keccak256(bytecode))\n        );\n\n        // NOTE: cast last 20 bytes of hash to address\n        return address(uint160(uint(hash)));\n    }\n\n    // 3. Deploy the contract\n    // NOTE:\n    // Check the event log Deployed which contains the address of the deployed TestContract.\n    // The address in the log should equal the address computed from above.\n    function deploy(bytes memory bytecode, uint _salt) public payable {\n        address addr;\n\n        /*\n        NOTE: How to call create2\n\n        create2(v, p, n, s)\n        create new contract with code at memory p to p + n\n        and send v wei\n        and return the new address\n        where new address = first 20 bytes of keccak256(0xff + address(this) + s + keccak256(mem[p(p+n)))\n              s = big-endian 256-bit value\n        */\n        assembly {\n            addr := create2(\n            callvalue(), // wei sent with current call\n            // Actual code starts after skipping the first 32 bytes\n            add(bytecode, 0x20),\n            mload(bytecode), // Load the size of code contained in the first 32 bytes\n            _salt // Salt from function arguments\n            )\n\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n\n        emit Deployed(addr, _salt);\n    }\n}\n"
    },
    "src/tests/Feed.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\nimport { ERC20 } from \"@rari-capital/solmate/src/erc20/ERC20.sol\";\nimport { FixedMath } from \"../external/FixedMath.sol\";\n\nimport { Errors } from \"../libs/errors.sol\";\nimport { BaseFeed } from \"../feeds/BaseFeed.sol\";\nimport { Divider } from \"../Divider.sol\";\n\nimport { MockFeed } from \"./test-helpers/MockFeed.sol\";\nimport { MockToken } from \"./test-helpers/MockToken.sol\";\nimport { TestHelper } from \"./test-helpers/TestHelper.sol\";\n\ncontract FakeFeed is BaseFeed {\n    function _scale() internal virtual override returns (uint256 _value) {\n        _value = 100e18;\n    }\n\n    function doSetFeed(Divider d, address _feed) public {\n        d.setFeed(_feed, true);\n    }\n}\n\ncontract Feeds is TestHelper {\n    using FixedMath for uint256;\n\n    function testFeedHasParams() public {\n        MockToken target = new MockToken(\"Compound Dai\", \"cDAI\", 18);\n        MockFeed feed = new MockFeed();\n        feed.initialize(address(target), address(divider), DELTA);\n\n        assertEq(feed.target(), address(target));\n        assertEq(feed.divider(), address(divider));\n        assertEq(feed.delta(), DELTA);\n        assertEq(feed.name(), \"Compound Dai Yield\");\n        assertEq(feed.symbol(), \"cDAI-yield\");\n    }\n\n    function testScale() public {\n        assertEq(feed.scale(), feed.INITIAL_VALUE());\n    }\n\n    function testScaleMultipleTimes() public {\n        assertEq(feed.scale(), feed.INITIAL_VALUE());\n        assertEq(feed.scale(), feed.INITIAL_VALUE());\n        assertEq(feed.scale(), feed.INITIAL_VALUE());\n    }\n\n    function testScaleIfEqualDelta() public {\n        uint256[] memory startingScales = new uint256[](4);\n        startingScales[0] = 2e20; // 200 WAD\n        startingScales[1] = 1e18; // 1 WAD\n        startingScales[2] = 1e17; // 0.1 WAD\n        startingScales[3] = 4e15; // 0.004 WAD\n        for (uint256 i = 0; i < startingScales.length; i++) {\n            MockFeed localFeed = new MockFeed();\n            localFeed.initialize(address(target), address(divider), DELTA);\n            uint256 startingScale = startingScales[i];\n\n            hevm.warp(0);\n            localFeed.setScale(startingScale);\n            // Set starting scale and store it as lscale\n            localFeed.scale();\n            (uint256 ltimestamp, uint256 lvalue) = localFeed.lscale();\n            assertEq(lvalue, startingScale);\n\n            hevm.warp(1 days);\n\n            // 86400 (1 day)\n            uint256 timeDiff = block.timestamp - ltimestamp;\n            // Find the scale value would bring us right up to the acceptable growth per second (delta)?\n            // Equation rationale:\n            //      *  DELTA is the max tolerable percent growth in the scale value per second.\n            //      *  So, we multiply that by the number of seconds that have passed.\n            //      *  And multiply that result by the previous scale value to\n            //         get the max amount of scale that we say can have grown.\n            //         We are functionally doing `maxPercentIncrease * value`, which gets\n            //         us the max *amount* that the value could have increased by.\n            //      *  Then add that max increase to the original value to get the maximum possible.\n            uint256 maxScale = (DELTA * timeDiff).fmul(lvalue, 10**ERC20(localFeed.target()).decimals()) + lvalue;\n\n            // Set max scale and ensure calling `scale` with it doesn't revert\n            localFeed.setScale(maxScale);\n            localFeed.scale();\n\n            // add 1 more day\n            hevm.warp(2 days);\n            (ltimestamp, lvalue) = localFeed.lscale();\n            timeDiff = block.timestamp - ltimestamp;\n            maxScale = (DELTA * timeDiff).fmul(lvalue, 10**ERC20(localFeed.target()).decimals()) + lvalue;\n            localFeed.setScale(maxScale);\n            localFeed.scale();\n        }\n    }\n\n    function testCantScaleIfMoreThanDelta() public {\n        uint256[] memory startingScales = new uint256[](4);\n        startingScales[0] = 2e20; // 200 WAD\n        startingScales[1] = 1e18; // 1 WAD\n        startingScales[2] = 1e17; // 0.1 WAD\n        startingScales[3] = 4e15; // 0.004 WAD\n        for (uint256 i = 0; i < startingScales.length; i++) {\n            MockFeed localFeed = new MockFeed();\n            localFeed.initialize(address(target), address(divider), DELTA);\n            uint256 startingScale = startingScales[i];\n\n            hevm.warp(0);\n            localFeed.setScale(startingScale);\n            // Set starting scale and store it as lscale\n            localFeed.scale();\n            (uint256 ltimestamp, uint256 lvalue) = localFeed.lscale();\n            assertEq(lvalue, startingScale);\n\n            hevm.warp(1 days);\n\n            // 86400 (1 day)\n            uint256 timeDiff = block.timestamp - ltimestamp;\n            // find the scale value would bring us right up to the acceptable growth per second (delta)?\n            uint256 maxScale = (DELTA * timeDiff).fmul(lvalue, 10**ERC20(localFeed.target()).decimals()) + lvalue;\n\n            // `maxScale * 1.000001` (adding small numbers wasn't enough to trigger the delta check as they got rounded\n            // away in wdivs)\n            localFeed.setScale(maxScale.fmul(1000001e12, 10**ERC20(localFeed.target()).decimals()));\n\n            try localFeed.scale() {\n                fail();\n            } catch Error(string memory error) {\n                assertEq(error, Errors.InvalidScaleValue);\n            }\n        }\n    }\n\n    function testCantScaleIfBelowPrevious() public {\n        assertEq(feed.scale(), feed.INITIAL_VALUE());\n        feed.setScale(feed.INITIAL_VALUE() - 1);\n        hevm.warp(block.timestamp + 1 days);\n        try feed.scale() {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidScaleValue);\n        }\n    }\n\n    function testCantAddCustomFeedToDivider() public {\n        MockToken newTarget = new MockToken(\"Compound USDC\", \"cUSDC\", 18);\n        FakeFeed fakeFeed = new FakeFeed();\n        fakeFeed.initialize(address(newTarget), address(divider), 0);\n        try fakeFeed.doSetFeed(divider, address(fakeFeed)) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.NotAuthorized);\n        }\n    }\n}\n"
    },
    "src/tests/test-helpers/MockFeed.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\nimport { ERC20 } from \"@rari-capital/solmate/src/erc20/ERC20.sol\";\nimport { BaseFeed } from \"../../feeds/BaseFeed.sol\";\nimport { FixedMath } from \"../../external/FixedMath.sol\";\n\ncontract MockFeed is BaseFeed {\n    using FixedMath for uint256;\n\n    uint256 internal value;\n    uint256 public INITIAL_VALUE;\n\n    function _scale() internal override virtual returns (uint256 _value) {\n        uint8 tDecimals = ERC20(target).decimals();\n        if (INITIAL_VALUE == 0)  {\n            if (tDecimals != 18) {\n                INITIAL_VALUE = tDecimals < 18 ? 0.1e18 / (10**(18 - tDecimals)) : 0.1e18 * (10**(tDecimals - 18));\n            } else {\n                INITIAL_VALUE = 0.1e18;\n            }\n        }\n        uint256 gps = delta.fmul(99 * (10 ** (tDecimals - 2)), 10**tDecimals); // delta - 1%;\n        uint256 timeDiff = block.timestamp - lscale.timestamp;\n        if (value > 0) return value;\n        _value = lscale.value > 0 ? (gps * timeDiff).fmul(lscale.value, 10**tDecimals) + lscale.value : INITIAL_VALUE;\n    }\n\n    function setScale(uint256 _value) external {\n        value = _value;\n    }\n\n}\n"
    },
    "src/tests/test-helpers/MockToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n// External references\nimport { ERC20 } from \"@rari-capital/solmate/src/erc20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal\n    ) ERC20(_name, _symbol, _decimal) {}\n\n    function mint(address account, uint256 amount) external virtual {\n        _mint(account, amount);\n    }\n}\n"
    },
    "src/tests/test-helpers/TestHelper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n// Internal references\nimport { GClaim } from \"../../modules/GClaim.sol\";\nimport { Divider } from \"../../Divider.sol\";\nimport { wTarget } from \"../../wrappers/wTarget.sol\";\nimport { MockToken } from \"./MockToken.sol\";\nimport { MockFeed } from \"./MockFeed.sol\";\nimport { MockFactory } from \"./MockFactory.sol\";\n\nimport { DSTest } from \"./DSTest.sol\";\nimport { Hevm } from \"./Hevm.sol\";\nimport { DateTimeFull } from \"./DateTimeFull.sol\";\nimport { User } from \"./User.sol\";\n\ncontract TestHelper is DSTest {\n    MockFeed feed;\n    MockToken stable;\n    MockToken target;\n    MockToken airdrop;\n    MockFactory factory;\n\n    Divider internal divider;\n    GClaim internal gclaim;\n    wTarget internal wtarget;\n    User internal alice;\n    User internal bob;\n    Hevm internal constant hevm = Hevm(HEVM_ADDRESS);\n\n    uint256 internal GROWTH_PER_SECOND = 792744799594; // 25% APY\n    uint256 internal DELTA = 800672247590; // GROWTH_PER_SECOND + 1% = 25.25% APY\n\n    uint256 public constant ISSUANCE_FEE = 0.01e18; // In percentage (1%). Hardcoded value at least for v1.\n    uint256 public constant INIT_STAKE = 1e18; // Hardcoded value at least for v1.\n    uint public constant SPONSOR_WINDOW = 4 hours; // Hardcoded value at least for v1.\n    uint public constant SETTLEMENT_WINDOW = 2 hours; // Hardcoded value at least for v1.\n    uint public constant MIN_MATURITY = 2 weeks; // Hardcoded value at least for v1.\n    uint public constant MAX_MATURITY = 14 weeks; // Hardcoded value at least for v1.\n\n    struct Series {\n        address zero; // Zero address for this Series (deployed on Series initialization)\n        address claim; // Claim address for this Series (deployed on Series initialization)\n        address sponsor; // Series initializer/sponsor\n        uint256 issuance; // Issuance date for this Series (needed for Zero redemption)\n        uint256 reward; // Tracks the fees due to the settler on Settlement\n        uint256 iscale; // Scale value at issuance\n        uint256 mscale; // Scale value at maturity\n        uint256 stake; // Balance staked at initialisation TODO: do we want to keep this?\n        address stable; // Address of the stable stake token TODO: do we want to keep this?\n    }\n\n    function setUp() public {\n        hevm.warp(1630454400);\n        // 01-09-21 00:00 UTC\n        uint8 tDecimals = 18;\n        stable = new MockToken(\"Stable Token\", \"ST\", tDecimals);\n        uint256 convertBase = 1;\n        if (tDecimals != 18) {\n            convertBase = tDecimals > 18 ? 10 ** (tDecimals - 18) : 10 ** (18 - tDecimals);\n        }\n        target = new MockToken(\"Compound Dai\", \"cDAI\", tDecimals);\n        airdrop = new MockToken(\"Airdrop Token\", \"ADROP\", tDecimals);\n        GROWTH_PER_SECOND = tDecimals > 18 ? GROWTH_PER_SECOND * convertBase : GROWTH_PER_SECOND / convertBase;\n        DELTA = tDecimals > 18 ? DELTA * convertBase : DELTA / convertBase;\n\n        // divider\n        divider = new Divider(address(stable), address(this));\n        divider.setGuard(address(target), 2**96);\n\n        // feed & factory\n        MockFeed implementation = new MockFeed(); // feed implementation\n        factory = new MockFactory(address(implementation), address(divider), DELTA, address(airdrop)); // deploy feed factory\n        factory.addTarget(address(target), true); // add support to target\n        divider.setIsTrusted(address(factory), true); // add factory as a ward\n        (address f, address wt) = factory.deployFeed(address(target));\n        feed = MockFeed(f);\n        wtarget = wTarget(wt);\n\n        // modules\n        gclaim = new GClaim(address(divider));\n\n        // users\n        alice = createUser(2**96, 2**96);\n        bob = createUser(2**96, 2**96);\n    }\n\n    function createUser(uint256 tBal, uint256 sBal) public returns (User user) {\n        user = new User();\n        user.setFactory(factory);\n        user.setStable(stable);\n        user.setTarget(target);\n        user.setDivider(divider);\n        user.setGclaim(gclaim);\n        user.doApprove(address(stable), address(divider));\n        uint256 sBase = 10 ** stable.decimals();\n        user.doMint(address(stable), sBal);\n        user.doApprove(address(target), address(divider));\n        user.doMint(address(target), tBal);\n    }\n\n    function createFactory(address _target, address _airdrop) public returns (MockFactory someFactory) {\n        MockFeed implementation = new MockFeed();\n        someFactory = new MockFactory(address(implementation), address(divider), DELTA, address(_airdrop));\n        someFactory.addTarget(_target, true);\n        divider.setIsTrusted(address(someFactory), true);\n    }\n\n    function getValidMaturity(uint256 year, uint256 month) public view returns (uint256 maturity) {\n        maturity = DateTimeFull.timestampFromDateTime(year, month, 1, 0, 0, 0);\n        require(maturity >= block.timestamp + 2 weeks, \"Maturity must be 2 weeks from current timestamp\");\n    }\n\n    function initSampleSeries(address sponsor, uint256 maturity) public returns (address zero, address claim) {\n        (zero, claim) = User(sponsor).doInitSeries(address(feed), maturity);\n    }\n\n    function assertClose(uint256 actual, uint256 expected) public {\n        if (actual == expected) return DSTest.assertEq(actual, expected);\n        uint256 variance = 100;\n        if (expected < variance) variance = 10;\n        if (expected < variance) variance = 1;\n        DSTest.assertTrue(actual >= (expected - variance));\n        DSTest.assertTrue(actual <= (expected + variance));\n    }\n\n}\n"
    },
    "src/modules/GClaim.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n// External references\nimport { SafeERC20, ERC20 } from \"@rari-capital/solmate/src/erc20/SafeERC20.sol\";\nimport { FixedMath } from \"../external/FixedMath.sol\";\n\n// Internal references\nimport { Divider } from \"../Divider.sol\";\nimport { Errors } from \"../libs/errors.sol\";\nimport { Claim } from \"../tokens/Claim.sol\";\nimport { Token } from \"../tokens/Token.sol\";\nimport { BaseFeed as Feed } from \"../feeds/BaseFeed.sol\";\n\n/// @title Gravity Claims (gClaims)\n/// @notice The GClaim contract turns Collect Claims into Drag Claims\ncontract GClaim {\n    using SafeERC20 for ERC20;\n    using FixedMath for uint256;\n\n    /// @notice \"Issuance\" scale value all claims of the same Series must backfill to separated by Claim address.\n    mapping(address => uint256) public inits;\n    /// @notice Total amount of interest collected separated by Claim address.\n    mapping(address => uint256) public totals;\n    mapping(address => Token) public gclaims;\n    Divider public divider;\n\n    constructor(address _divider) {\n        divider = Divider(_divider);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function join(\n        address feed,\n        uint256 maturity,\n        uint256 balance\n    ) external {\n        require(maturity > block.timestamp, Errors.InvalidMaturity);\n\n        (, address claim, , , , , ) = divider.series(feed, maturity);\n        require(claim != address(0), Errors.SeriesDoesntExists);\n\n        if (address(gclaims[claim]) == address(0)) {\n            // If this is the first Claim from this Series:\n            // * Set the current scale value as the floor\n            // * Deploy a new gClaim contract\n\n            // NOTE: Because we're transferring Claims in this same TX, we could technically\n            // get the scale value from the divider, but that's a little opaque as it relies on side-effects,\n            // so i've gone with the clearest solution for now and we can optimize later\n            inits[claim] = Feed(feed).scale();\n            string memory name = string(abi.encodePacked(\"G-\", ERC20(claim).name(), \"-G\"));\n            string memory symbol = string(abi.encodePacked(\"G-\", ERC20(claim).symbol(), \"-G\"));\n            // NOTE: Consider the benefits of using Create2 here\n            gclaims[claim] = new Token(name, symbol, ERC20(Feed(feed).target()).decimals());\n        } else {\n            uint256 initScale = inits[claim];\n            uint256 currScale = Feed(feed).scale();\n            // Calculate the amount of excess that has accrued since\n            // the first Claim from this Series was deposited\n            if (currScale - initScale > 0) {\n                uint256 gap = (balance * currScale) / (currScale - initScale) / 10**18;\n\n                // Pull the amount of Target needed to backfill the excess\n                ERC20(Feed(feed).target()).safeTransferFrom(msg.sender, address(this), gap);\n                totals[claim] += gap;\n            }\n        }\n        // NOTE: Is there any way to drag inits up for everyone after a certain about of time has passed?\n\n        // Pull Collect Claims to this contract\n        ERC20(claim).safeTransferFrom(msg.sender, address(this), balance);\n        // Mint the user Drag Claims\n        gclaims[claim].mint(msg.sender, balance);\n\n        emit Join(feed, maturity, msg.sender, balance);\n    }\n\n    function exit(\n        address feed,\n        uint256 maturity,\n        uint256 balance\n    ) external {\n        (, address claim, , , , , ) = divider.series(feed, maturity);\n\n        require(claim != address(0), Errors.SeriesDoesntExists);\n\n        // Collect excess for all Claims from this Series in this contract holds\n        uint256 collected = Claim(claim).collect();\n        // Track the total Target collected manually so that that we don't get\n        // mixed up when multiple Series have the same Target\n        uint256 total = totals[claim] + collected;\n\n        // Determine the percent of the excess this caller has a right to\n        uint256 rights = (\n            balance.fdiv(gclaims[claim].totalSupply(), Token(claim).BASE_UNIT()).fmul(total, Token(claim).BASE_UNIT())\n        );\n        total -= rights;\n        totals[claim] = total;\n\n        // Send the excess Target back to the user\n        ERC20(Feed(feed).target()).safeTransfer(msg.sender, rights);\n        // Transfer Collect Claims back to the user\n        ERC20(claim).safeTransfer(msg.sender, balance);\n        // Burn the user's gclaims\n        gclaims[claim].burn(msg.sender, balance);\n\n        emit Exit(feed, maturity, msg.sender, balance);\n    }\n\n    // NOTE: Admin pull up issuance?\n    // NOTE: Admin approved claims?\n\n    /* ========== EVENTS ========== */\n\n    event Join(address indexed feed, uint256 maturity, address indexed guy, uint256 balance);\n    event Exit(address indexed feed, uint256 maturity, address indexed guy, uint256 balance);\n}\n"
    },
    "src/tests/test-helpers/MockFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n// Internal references\nimport { BaseFactory } from \"../../feeds/BaseFactory.sol\";\n\ncontract MockFactory is BaseFactory {\n    mapping(address => bool) public targets;\n\n    constructor(\n        address _implementation,\n        address _divider,\n        uint256 _delta,\n        address _airdropToken\n    ) BaseFactory(address(0), _implementation, _divider, _delta, _airdropToken) {}\n\n    function _exists(address _target) internal override virtual returns (bool) {\n        return targets[_target];\n    }\n\n    function addTarget(address _target, bool status) external {\n        targets[_target] = status;\n    }\n\n}\n"
    },
    "src/tests/test-helpers/DSTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n// Taken from: https://github.com/dapphub/ds-test\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", a);\n            emit log_named_string(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "src/tests/test-helpers/Hevm.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\nabstract contract Hevm {\n    // Sets the block timestamp to x\n    function warp(uint x) public virtual;\n    // Sets the block number to x\n    function roll(uint x) public virtual;\n    // Sets the slot loc of contract c to val\n    function store(address c, bytes32 loc, bytes32 val) public virtual;\n    function ffi(string[] calldata) external virtual returns (bytes memory);\n}"
    },
    "src/tests/test-helpers/DateTimeFull.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n// ----------------------------------------------------------------------------\n// DateTime Library v2.0\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary DateTimeFull {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 constant SECONDS_PER_MINUTE = 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    uint256 constant DOW_MON = 1;\n    uint256 constant DOW_TUE = 2;\n    uint256 constant DOW_WED = 3;\n    uint256 constant DOW_THU = 4;\n    uint256 constant DOW_FRI = 5;\n    uint256 constant DOW_SAT = 6;\n    uint256 constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 _days) {\n        require(year >= 1970);\n        int256 _year = int256(year);\n        int256 _month = int256(month);\n        int256 _day = int256(day);\n\n        int256 __days =\n        _day -\n        32075 +\n        (1461 * (_year + 4800 + (_month - 14) / 12)) /\n        4 +\n        (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\n        12 -\n        (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\n        4 -\n        OFFSET19700101;\n\n        _days = uint256(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days)\n    internal\n    pure\n    returns (\n        uint256 year,\n        uint256 month,\n        uint256 day\n    )\n    {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n\n    function timestampFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n\n    function timestampFromDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 timestamp) {\n        timestamp =\n        _daysFromDate(year, month, day) *\n        SECONDS_PER_DAY +\n        hour *\n        SECONDS_PER_HOUR +\n        minute *\n        SECONDS_PER_MINUTE +\n        second;\n    }\n\n    function timestampToDate(uint256 timestamp)\n    internal\n    pure\n    returns (\n        uint256 year,\n        uint256 month,\n        uint256 day\n    )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function timestampToDateTime(uint256 timestamp)\n    internal\n    pure\n    returns (\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n\n    function _getDaysInMonth(uint256 year, uint256 month)\n    internal\n    pure\n    returns (uint256 daysInMonth)\n    {\n        if (\n            month == 1 ||\n            month == 3 ||\n            month == 5 ||\n            month == 7 ||\n            month == 8 ||\n            month == 10 ||\n            month == 12\n        ) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function addMonths(uint256 timestamp, uint256 _months)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) =\n        _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = ((month - 1) % 12) + 1;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n        _daysFromDate(year, month, day) *\n        SECONDS_PER_DAY +\n        (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp >= timestamp);\n    }\n\n    function addSeconds(uint256 timestamp, uint256 _seconds)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subSeconds(uint256 timestamp, uint256 _seconds)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n}\n"
    },
    "src/tests/test-helpers/User.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\nimport { Hevm } from \"./Hevm.sol\";\nimport { MockToken } from \"./MockToken.sol\";\nimport { Divider } from \"../../Divider.sol\";\nimport { GClaim } from \"../../modules/GClaim.sol\";\nimport { Claim } from \"../../tokens/Claim.sol\";\nimport { BaseFactory } from \"../../feeds/BaseFactory.sol\";\n\ncontract User {\n    address constant HEVM_ADDRESS = address(bytes20(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    MockToken stable;\n    MockToken target;\n    Divider divider;\n    GClaim gclaim;\n    BaseFactory factory;\n    Hevm internal constant hevm = Hevm(HEVM_ADDRESS);\n\n    struct Backfill {\n        address usr; // address of the backfilled user\n        uint256 scale; // scale value to backfill for usr\n    }\n\n    function setFactory(BaseFactory _factory) public {\n        factory = _factory;\n    }\n\n    function setStable(MockToken _token) public {\n        stable = _token;\n    }\n\n    function setTarget(MockToken _token) public {\n        target = _token;\n    }\n\n    function setDivider(Divider _divider) public {\n        divider = _divider;\n    }\n\n    function setGclaim(GClaim _gclaim) public {\n        gclaim = _gclaim;\n    }\n\n    function doDeployFeed (address _target) public returns (address clone, address wtarget){\n        return factory.deployFeed(_target);\n    }\n\n    function doTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        return MockToken(token).transferFrom(from, to, amount);\n    }\n\n    function doTransfer(address token, address to, uint256 amount) public returns (bool) {\n        return MockToken(token).transfer(to, amount);\n    }\n\n    function doApprove(address token, address recipient, uint256 amount) public returns (bool) {\n        return MockToken(token).approve(recipient, amount);\n    }\n\n    function doApprove(address token, address guy) public returns (bool) {\n        return MockToken(token).approve(guy, type(uint256).max);\n    }\n\n    function doAllowance(address token, address owner, address spender) public view returns (uint256) {\n        return MockToken(token).allowance(owner, spender);\n    }\n\n    function doBalanceOf(address token, address who) public view returns (uint256) {\n        return MockToken(token).balanceOf(who);\n    }\n\n    function doMint(address token, uint256 wad) public {\n        MockToken(token).mint(address(this), wad);\n    }\n\n    function doMint(address token, address guy, uint256 wad) public {\n        MockToken(token).mint(guy, wad);\n    }\n\n    function doSetFeed(address feed, bool isOn) public {\n        divider.setFeed(feed, isOn);\n    }\n\n    function doInitSeries(address feed, uint256 maturity) public returns (address zero, address claim) {\n        (zero, claim) = divider.initSeries(feed, maturity);\n    }\n\n    function doSettleSeries(address feed, uint256 maturity) public {\n        divider.settleSeries(feed, maturity);\n    }\n\n    function doIssue(address feed, uint256 maturity, uint256 balance) public {\n        divider.issue(feed, maturity, balance);\n    }\n\n    function doCombine(address feed, uint256 maturity, uint256 balance) public {\n        divider.combine(feed, maturity, balance);\n    }\n\n    function doBackfillScale(address feed, uint256 maturity, uint256 scale, Divider.Backfill[] memory backfills) public {\n        divider.backfillScale(feed, maturity, scale, backfills);\n    }\n\n    function doRedeemZero(address feed, uint256 maturity, uint256 balance) public {\n        return divider.redeemZero(feed, maturity, balance);\n    }\n\n    function doCollect(address claim) public returns (uint256 collected) {\n        collected = Claim(claim).collect();\n    }\n\n    function doJoin(address feed, uint256 maturity, uint256 balance) public {\n        gclaim.join(feed, maturity, balance);\n    }\n\n    function doExit(address feed, uint256 maturity, uint256 balance) public {\n        gclaim.exit(feed, maturity, balance);\n    }\n\n}"
    },
    "src/feeds/BaseFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n// External references\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { Trust } from \"@rari-capital/solmate/src/auth/Trust.sol\";\nimport { ERC20 } from \"@rari-capital/solmate/src/erc20/SafeERC20.sol\";\n\n// Internal references\nimport { Errors } from \"../libs/errors.sol\";\nimport { BaseFeed } from \"./BaseFeed.sol\";\nimport { Divider } from \"../Divider.sol\";\nimport { wTarget } from \"../wrappers/wTarget.sol\";\n\nabstract contract BaseFactory is Trust {\n    using Clones for address;\n\n    uint256 MAX_INT = 2**256 - 1;\n\n    mapping(address => address) public feeds; // target -> feed (to check if a feed for a given target is deployed)\n    address public protocol; // protocol's data contract address\n    address public implementation;\n    address public divider;\n    uint256 public delta;\n    address public airdropToken;\n\n    constructor(\n        address _protocol,\n        address _implementation,\n        address _divider,\n        uint256 _delta,\n        address _airdropToken\n    ) Trust(msg.sender) {\n        protocol = _protocol;\n        implementation = _implementation;\n        divider = _divider;\n        delta = _delta;\n        airdropToken = _airdropToken;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /// @notice Deploys a feed for the given _target\n    /// @param _target Address of the target token\n    function deployFeed(address _target) external returns (address clone, address wtarget) {\n        require(_exists(_target), Errors.NotSupported);\n        require(feeds[_target] == address(0), Errors.FeedAlreadyExists);\n\n        clone = implementation.clone();\n        BaseFeed(clone).initialize(_target, divider, delta);\n        Divider(divider).setFeed(clone, true);\n        wTarget wt = new wTarget(_target, divider, airdropToken); // deploy Target Wrapper\n        Divider(divider).setWrapper(address(wt));\n        feeds[_target] = clone;\n        emit FeedDeployed(clone);\n        return (clone, address(wt));\n    }\n\n    /* ========== ADMIN FUNCTIONS ========== */\n\n    function setDivider(address _divider) external requiresTrust {\n        divider = _divider;\n        emit DividerChanged(_divider);\n    }\n\n    function setDelta(uint256 _delta) external requiresTrust {\n        delta = _delta;\n        emit DeltaChanged(_delta);\n    }\n\n    function setImplementation(address _implementation) external requiresTrust {\n        implementation = _implementation;\n        emit ImplementationChanged(_implementation);\n    }\n\n    function setProtocol(address _protocol) external requiresTrust {\n        protocol = _protocol;\n        emit ProtocolChanged(_protocol);\n    }\n\n    /* ========== INTERNAL & HELPER FUNCTIONS ========== */\n\n    /// @notice Target validity check that must be overriden by child contracts\n    function _exists(address _target) internal virtual returns (bool);\n\n    /* ========== EVENTS ========== */\n\n    event FeedDeployed(address addr);\n    event DividerChanged(address divider);\n    event DeltaChanged(uint256 delta);\n    event ImplementationChanged(address implementation);\n    event ProtocolChanged(address protocol);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "src/tests/GClaim.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\nimport { ERC20 } from \"@rari-capital/solmate/src/erc20/ERC20.sol\";\n\nimport { Errors } from \"../libs/errors.sol\";\nimport { Claim } from \"../tokens/Claim.sol\";\nimport { GClaim } from \"../modules/GClaim.sol\";\n\nimport { Hevm } from \"./test-helpers/Hevm.sol\";\nimport { TestHelper } from \"./test-helpers/TestHelper.sol\";\n\ncontract DividerMock {}\n\ncontract GClaims is TestHelper {\n    /* ========== join() tests ========== */\n\n    function testCantJoinIfInvalidMaturity() public {\n        uint256 maturity = block.timestamp - 1 days;\n        uint256 balance = 1e18;\n        try alice.doJoin(address(feed), maturity, balance) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidMaturity);\n        }\n    }\n\n    function testCantJoinIfSeriesDoesntExists() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        uint256 balance = 10e18;\n        try alice.doJoin(address(feed), maturity, balance) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.SeriesDoesntExists);\n        }\n    }\n\n    function testCantJoinIfNotEnoughClaim() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = 10**Claim(claim).decimals();\n        uint256 balance = 10 * claimBaseUnit;\n        hevm.warp(block.timestamp + 1 days);\n        bob.doApprove(address(claim), address(gclaim));\n        try bob.doJoin(address(feed), maturity, balance) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.TransferFromFailed);\n        }\n    }\n\n    function testCantJoinIfNotEnoughClaimAllowance() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = 10**Claim(claim).decimals();\n        uint256 balance = 10 * claimBaseUnit;\n        hevm.warp(block.timestamp + 1 days);\n        bob.doIssue(address(feed), maturity, balance);\n        uint256 claimBalance = Claim(claim).balanceOf(address(bob));\n        try bob.doJoin(address(feed), maturity, claimBalance) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.TransferFromFailed);\n        }\n    }\n\n    function testCantJoinAfterFirstGClaimNotEnoughTargetBalance() public {\n        uint256 tBase = 10**target.decimals();\n        divider.setGuard(address(target), 10000000000000000000000 * tBase);\n\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = 10**Claim(claim).decimals();\n        hevm.warp(block.timestamp + 1 days);\n\n        // bob issues and joins\n        uint256 bbalance = target.balanceOf(address(bob));\n        bob.doIssue(address(feed), maturity, bbalance);\n        bob.doApprove(address(claim), address(gclaim));\n        hevm.warp(block.timestamp + 1 days);\n        uint256 bobClaimBalance = Claim(claim).balanceOf(address(bob));\n        bob.doJoin(address(feed), maturity, bobClaimBalance);\n        uint256 bobGclaimBalance = ERC20(gclaim.gclaims(address(claim))).balanceOf(address(bob));\n        assertEq(bobGclaimBalance, bobClaimBalance);\n\n        // alice issues and joins\n        uint256 abalance = target.balanceOf(address(alice));\n        hevm.warp(block.timestamp + 1 days);\n        alice.doIssue(address(feed), maturity, abalance);\n        alice.doApprove(address(claim), address(gclaim));\n        alice.doApprove(address(target), address(gclaim));\n        hevm.warp(block.timestamp + 20 days);\n        uint256 aliceClaimBalance = Claim(claim).balanceOf(address(alice));\n        uint256 aliceTargetBalBefore = target.balanceOf(address(alice));\n        alice.doCollect(address(claim));\n        alice.doTransfer(address(target), address(bob), target.balanceOf(address(alice)));\n\n        try alice.doJoin(address(feed), maturity, aliceClaimBalance) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.TransferFromFailed);\n        }\n    }\n\n    function testJoinFirstGClaim() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = 10**Claim(claim).decimals();\n        uint256 balance = 10 * claimBaseUnit;\n        hevm.warp(block.timestamp + 1 days);\n        bob.doIssue(address(feed), maturity, balance);\n        bob.doApprove(address(claim), address(gclaim));\n        hevm.warp(block.timestamp + 1 days);\n        uint256 claimBalance = Claim(claim).balanceOf(address(bob));\n        bob.doJoin(address(feed), maturity, claimBalance);\n        uint256 gclaimBalance = ERC20(gclaim.gclaims(address(claim))).balanceOf(address(bob));\n        assertEq(gclaimBalance, claimBalance);\n    }\n\n    function testJoinAfterFirstGClaim() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = 10**Claim(claim).decimals();\n\n        // bob issues and joins\n        uint256 balance = 10 * claimBaseUnit;\n        bob.doIssue(address(feed), maturity, balance);\n        bob.doApprove(address(claim), address(gclaim));\n        uint256 bobClaimBalance = Claim(claim).balanceOf(address(bob));\n        bob.doJoin(address(feed), maturity, bobClaimBalance);\n        uint256 bobGclaimBalance = ERC20(gclaim.gclaims(address(claim))).balanceOf(address(bob));\n        assertEq(bobGclaimBalance, bobClaimBalance);\n\n        // alice issues and joins\n        alice.doIssue(address(feed), maturity, balance);\n        alice.doApprove(address(claim), address(gclaim));\n        alice.doApprove(address(target), address(gclaim));\n        uint256 aliceClaimBalance = Claim(claim).balanceOf(address(alice));\n        uint256 aliceTargetBalBefore = target.balanceOf(address(alice));\n        alice.doJoin(address(feed), maturity, aliceClaimBalance);\n        uint256 aliceTargetBalAfter = target.balanceOf(address(alice));\n        uint256 aliceGclaimBalance = ERC20(gclaim.gclaims(address(claim))).balanceOf(address(alice));\n        assertEq(aliceGclaimBalance, aliceClaimBalance);\n        assertEq(aliceTargetBalAfter, aliceTargetBalBefore);\n    }\n\n    function testJoinAfterFirstGClaimWithdrawsGap() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = 10**Claim(claim).decimals();\n        hevm.warp(block.timestamp + 1 days);\n\n        // bob issues and joins\n        uint256 balance = 10 * claimBaseUnit;\n        bob.doIssue(address(feed), maturity, balance);\n        bob.doApprove(address(claim), address(gclaim));\n        hevm.warp(block.timestamp + 1 days);\n        uint256 bobClaimBalance = Claim(claim).balanceOf(address(bob));\n        bob.doJoin(address(feed), maturity, bobClaimBalance);\n        uint256 bobGclaimBalance = ERC20(gclaim.gclaims(address(claim))).balanceOf(address(bob));\n        assertEq(bobGclaimBalance, bobClaimBalance);\n\n        // alice issues and joins\n        hevm.warp(block.timestamp + 1 days);\n        alice.doIssue(address(feed), maturity, balance);\n        alice.doApprove(address(claim), address(gclaim));\n        alice.doApprove(address(target), address(gclaim));\n        uint256 aliceClaimBalance = Claim(claim).balanceOf(address(alice));\n        uint256 aliceTargetBalBefore = target.balanceOf(address(alice));\n        alice.doJoin(address(feed), maturity, aliceClaimBalance);\n        (, uint256 currScale) = feed.lscale();\n        uint256 initScale = gclaim.inits(address(claim));\n        uint256 gap = (aliceClaimBalance * currScale) / (currScale - initScale) / 10**18;\n        uint256 aliceTargetBalAfter = target.balanceOf(address(alice));\n        uint256 aliceGclaimBalance = ERC20(gclaim.gclaims(address(claim))).balanceOf(address(alice));\n        assertEq(aliceGclaimBalance, aliceClaimBalance);\n        assertEq(aliceTargetBalAfter + gap, aliceTargetBalBefore);\n    }\n\n    /* ========== exit() tests ========== */\n\n    function testCantExitIfSeriesDoesntExists() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        uint256 balance = 1e18;\n        try alice.doExit(address(feed), maturity, balance) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.SeriesDoesntExists);\n        }\n    }\n\n    function testExitFirstGClaim() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = 10**Claim(claim).decimals();\n        uint256 balance = 10 * claimBaseUnit;\n        hevm.warp(block.timestamp + 1 days);\n        bob.doIssue(address(feed), maturity, balance);\n        bob.doApprove(address(claim), address(gclaim));\n        hevm.warp(block.timestamp + 1 days);\n        uint256 claimBalanceBefore = Claim(claim).balanceOf(address(bob));\n        bob.doJoin(address(feed), maturity, claimBalanceBefore);\n        uint256 tBalanceBefore = target.balanceOf(address(bob));\n        uint256 gclaimBalanceBefore = ERC20(gclaim.gclaims(address(claim))).balanceOf(address(bob));\n        bob.doExit(address(feed), maturity, gclaimBalanceBefore);\n        uint256 gclaimBalanceAfter = ERC20(gclaim.gclaims(address(claim))).balanceOf(address(bob));\n        uint256 claimBalanceAfter = Claim(claim).balanceOf(address(bob));\n        uint256 tBalanceAfter = target.balanceOf(address(bob));\n        assertEq(gclaimBalanceAfter, 0);\n        assertEq(claimBalanceAfter, claimBalanceBefore);\n        assertEq(tBalanceBefore, tBalanceAfter);\n    }\n\n    function testExitGClaimWithCollected() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = 10**Claim(claim).decimals();\n        uint256 balance = 10 * claimBaseUnit;\n        hevm.warp(block.timestamp + 1 days);\n        bob.doIssue(address(feed), maturity, balance);\n        bob.doApprove(address(claim), address(gclaim));\n        hevm.warp(block.timestamp + 1 days);\n        uint256 tBalanceBefore = target.balanceOf(address(bob));\n        uint256 claimBalanceBefore = Claim(claim).balanceOf(address(bob));\n        bob.doJoin(address(feed), maturity, claimBalanceBefore);\n        hevm.warp(block.timestamp + 3 days);\n        uint256 gclaimBalanceBefore = ERC20(gclaim.gclaims(address(claim))).balanceOf(address(bob));\n        bob.doExit(address(feed), maturity, gclaimBalanceBefore);\n        uint256 gclaimBalanceAfter = ERC20(gclaim.gclaims(address(claim))).balanceOf(address(bob));\n        uint256 claimBalanceAfter = Claim(claim).balanceOf(address(bob));\n        uint256 tBalanceAfter = target.balanceOf(address(bob));\n        assertEq(gclaimBalanceAfter, 0);\n        assertEq(claimBalanceAfter, claimBalanceBefore);\n        assertTrue(tBalanceAfter > tBalanceBefore); // TODO: assert exact collected value\n    }\n\n    function testExitAfterFirstGClaim() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = 10**Claim(claim).decimals();\n        hevm.warp(block.timestamp + 1 days);\n\n        // bob issues and joins\n        uint256 balance = 10 * claimBaseUnit;\n        bob.doIssue(address(feed), maturity, balance);\n        bob.doApprove(address(claim), address(gclaim));\n        hevm.warp(block.timestamp + 1 days);\n        uint256 bobClaimBalance = Claim(claim).balanceOf(address(bob));\n        bob.doJoin(address(feed), maturity, bobClaimBalance);\n        uint256 bobGclaimBalance = ERC20(gclaim.gclaims(address(claim))).balanceOf(address(bob));\n        assertEq(bobGclaimBalance, bobClaimBalance);\n\n        // alice issues and joins\n        hevm.warp(block.timestamp + 1 days);\n        alice.doIssue(address(feed), maturity, balance);\n        alice.doApprove(address(claim), address(gclaim));\n        alice.doApprove(address(target), address(gclaim));\n        hevm.warp(block.timestamp + 1 days);\n        uint256 aliceClaimBalance = Claim(claim).balanceOf(address(alice));\n        alice.doJoin(address(feed), maturity, aliceClaimBalance);\n        uint256 aliceGclaimBalance = ERC20(gclaim.gclaims(address(claim))).balanceOf(address(alice));\n        assertEq(aliceGclaimBalance, aliceClaimBalance);\n\n        // alice exits\n        hevm.warp(block.timestamp + 3 days);\n        uint256 tBalanceBefore = target.balanceOf(address(alice));\n        alice.doExit(address(feed), maturity, aliceGclaimBalance);\n        uint256 gclaimBalanceAfter = ERC20(gclaim.gclaims(address(claim))).balanceOf(address(alice));\n        uint256 claimBalanceAfter = Claim(claim).balanceOf(address(alice));\n        uint256 tBalanceAfter = target.balanceOf(address(alice));\n        assertEq(gclaimBalanceAfter, 0);\n        assertEq(claimBalanceAfter, aliceClaimBalance);\n        assertTrue(tBalanceAfter > tBalanceBefore);\n    }\n}\n"
    },
    "src/tests/CFeed.tm.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\nimport { FixedMath } from \"../external/FixedMath.sol\";\n\n// Internal references\nimport { Divider } from \"../Divider.sol\";\nimport { CFeed, CTokenInterface } from \"../feeds/compound/CFeed.sol\";\n\nimport { DSTest } from \"./test-helpers/DSTest.sol\";\nimport { MockFactory } from \"./test-helpers/MockFactory.sol\";\nimport { Hevm } from \"./test-helpers/Hevm.sol\";\nimport { DateTimeFull } from \"./test-helpers/DateTimeFull.sol\";\nimport { User } from \"./test-helpers/User.sol\";\n\ncontract CFeedTestHelper is DSTest {\n    CFeed feed;\n    MockFactory internal factory;\n    Divider internal divider;\n\n    uint256 public constant DELTA = 150;\n    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public constant cDAI = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n\n    function setUp() public {\n        divider = new Divider(DAI, address(this));\n        CFeed implementation = new CFeed(); // compound feed implementation\n        // deploy compound feed factory\n        factory = new MockFactory(address(implementation), address(divider), DELTA, DAI); // TODO replace for a real one\n        factory.addTarget(cDAI, true);\n        divider.setIsTrusted(address(factory), true); // add factory as a ward\n        (address f, ) = factory.deployFeed(cDAI);\n        feed = CFeed(f); // deploy a cDAI feed\n    }\n}\n\ncontract CFeeds is CFeedTestHelper {\n    using FixedMath for uint256;\n\n    function testCFeedScale() public {\n        CTokenInterface underlying = CTokenInterface(DAI);\n        CTokenInterface ctoken = CTokenInterface(cDAI);\n\n        uint256 decimals = 1 * 10**(18 - 8 + underlying.decimals());\n        uint256 scale = ctoken.exchangeRateCurrent().fdiv(decimals, 10**ctoken.decimals());\n        assertEq(feed.scale(), scale);\n    }\n}\n"
    },
    "src/feeds/compound/CFeed.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n// External references\nimport { FixedMath } from \"../../external/FixedMath.sol\";\n\n// Internal references\nimport { BaseFeed } from \"../BaseFeed.sol\";\n\ninterface CTokenInterface {\n    // @notice cToken is convertible into an ever increasing quantity of the underlying asset, as interest accrues in\n    // the market. This function returns the exchange rate between a cToken and the underlying asset.\n    // @dev: returns the current exchange rate as an uint, scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\n    function exchangeRateCurrent() external returns (uint256);\n\n    function decimals() external returns (uint256);\n\n    function underlying() external returns (address);\n}\n\n// @title feed contract for cTokens\ncontract CFeed is BaseFeed {\n    using FixedMath for uint256;\n\n    function _scale() internal virtual override returns (uint256 _value) {\n        CTokenInterface t = CTokenInterface(target);\n        uint256 decimals = 10 + CTokenInterface(t.underlying()).decimals();\n        _value = t.exchangeRateCurrent() / (1 * 10**decimals);\n    }\n}\n"
    },
    "src/tests/CFactory.tm.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n\n// Internal references\nimport { CFeed } from \"../feeds/compound/CFeed.sol\";\nimport { CFactory } from \"../feeds/compound/CFactory.sol\";\nimport { Divider } from \"../Divider.sol\";\n\nimport { DSTest } from \"./test-helpers/DSTest.sol\";\nimport { Hevm } from \"./test-helpers/Hevm.sol\";\nimport { DateTimeFull } from \"./test-helpers/DateTimeFull.sol\";\nimport { User } from \"./test-helpers/User.sol\";\n\ncontract CFeedTestHelper is DSTest {\n    CFactory internal factory;\n    Divider internal divider;\n\n    uint256 public constant DELTA = 150;\n    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public constant cDAI = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n\n    function setUp() public {\n        divider = new Divider(DAI, address(this));\n        CFeed implementation = new CFeed(); // compound feed implementation\n        // deploy compound feed factory\n        factory = new CFactory(address(implementation), address(divider), DELTA, DAI);\n        divider.setIsTrusted(address(factory), true); // add factory as a ward\n    }\n}\n\ncontract CFactories is CFeedTestHelper {\n    function testDeployFactory() public {\n        CFeed implementation = new CFeed();\n        CFactory otherCFactory = new CFactory(address(implementation), address(divider), DELTA, DAI);\n        // TODO: replace for a real one\n        assertTrue(address(otherCFactory) != address(0));\n        assertEq(CFactory(otherCFactory).implementation(), address(implementation));\n        assertEq(CFactory(otherCFactory).divider(), address(divider));\n        assertEq(CFactory(otherCFactory).delta(), DELTA);\n    }\n\n    function testDeployFeed() public {\n        (address f, ) = factory.deployFeed(cDAI);\n        CFeed feed = CFeed(f);\n        assertTrue(address(feed) != address(0));\n        assertEq(CFeed(feed).target(), address(cDAI));\n        assertEq(CFeed(feed).divider(), address(divider));\n        assertEq(CFeed(feed).delta(), DELTA);\n        assertEq(CFeed(feed).name(), \"Compound Dai Yield\");\n        assertEq(CFeed(feed).symbol(), \"cDAI-yield\");\n\n        uint256 scale = CFeed(feed).scale();\n        assertTrue(scale > 0);\n    }\n}\n"
    },
    "src/feeds/compound/CFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n// internal references\nimport { BaseFactory } from \"../BaseFactory.sol\";\n\ninterface Comptroller {\n    function markets(address target) external returns (bool isListed, uint collateralFactorMantissa, bool isComped);\n}\n\ncontract CFactory is BaseFactory {\n    constructor(\n        address _implementation,\n        address _divider,\n        uint256 _delta,\n        address _airdropToken\n    ) BaseFactory(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B, _implementation, _divider, _delta, _airdropToken) {}\n\n    function _exists(address _target) internal override virtual returns (bool) {\n        (bool isListed, , ) = Comptroller(protocol).markets(_target);\n        return isListed;\n    }\n}\n"
    },
    "src/tests/Divider.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\nimport { ERC20 } from \"@rari-capital/solmate/src/erc20/ERC20.sol\";\nimport { FixedMath } from \"../external/FixedMath.sol\";\nimport { DateTimeFull } from \"./test-helpers/DateTimeFull.sol\";\n\nimport { TestHelper } from \"./test-helpers/TestHelper.sol\";\nimport { Errors } from \"../libs/errors.sol\";\nimport { Divider } from \"../Divider.sol\";\nimport { Token } from \"../tokens/Token.sol\";\n\ncontract Dividers is TestHelper {\n    using FixedMath for uint256;\n    using Errors for string;\n\n    Divider.Backfill[] backfills;\n\n    /* ========== initSeries() tests ========== */\n\n    function testCantInitSeriesNotEnoughStakeBalance() public {\n        uint256 balance = stable.balanceOf(address(alice));\n        alice.doTransfer(address(stable), address(bob), balance - INIT_STAKE / 2);\n        uint256 maturity = getValidMaturity(2021, 10);\n        try alice.doInitSeries(address(feed), maturity) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.TransferFromFailed);\n        }\n    }\n\n    function testCantInitSeriesNotEnoughStakeAllowance() public {\n        alice.doApprove(address(stable), address(divider), 0);\n        uint256 maturity = getValidMaturity(2021, 10);\n        try alice.doInitSeries(address(feed), maturity) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.TransferFromFailed);\n        }\n    }\n\n    function testCantInitSeriesFeedNotEnabled() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        divider.setFeed(address(feed), false);\n        try alice.doInitSeries(address(feed), maturity) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidFeed);\n        }\n    }\n\n    function testCantInitSeriesIfAlreadyExists() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        try alice.doInitSeries(address(feed), maturity) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.DuplicateSeries);\n        }\n    }\n\n    function testCantInitSeriesActiveSeriesReached() public {\n        uint256 SERIES_TO_INIT = 3;\n        for (uint256 i = 1; i <= SERIES_TO_INIT; i++) {\n            uint256 nextMonthDate = DateTimeFull.addMonths(block.timestamp, i);\n            nextMonthDate = getValidMaturity(DateTimeFull.getYear(nextMonthDate), DateTimeFull.getMonth(nextMonthDate));\n            (address zero, address claim) = initSampleSeries(address(alice), nextMonthDate);\n            hevm.warp(block.timestamp + 1 days);\n            assertTrue(address(zero) != address(0));\n            assertTrue(address(claim) != address(0));\n        }\n        uint256 lastDate = DateTimeFull.addMonths(block.timestamp, SERIES_TO_INIT + 1);\n        lastDate = getValidMaturity(DateTimeFull.getYear(lastDate), DateTimeFull.getMonth(lastDate));\n        try alice.doInitSeries(address(feed), lastDate) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidMaturity);\n        }\n    }\n\n    function testCantInitSeriesWithMaturityBeforeTimestamp() public {\n        uint256 maturity = DateTimeFull.timestampFromDateTime(2021, 8, 1, 0, 0, 0);\n        try alice.doInitSeries(address(feed), maturity) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidMaturity);\n        }\n    }\n\n    function testCantInitSeriesLessThanMinMaturity() public {\n        hevm.warp(1631923200);\n        // 18-09-21 00:00 UTC\n        uint256 maturity = DateTimeFull.timestampFromDateTime(2021, 10, 1, 0, 0, 0);\n        try alice.doInitSeries(address(feed), maturity) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidMaturity);\n        }\n    }\n\n    function testCantInitSeriesMoreThanMaxMaturity() public {\n        hevm.warp(1631664000);\n        // 15-09-21 00:00 UTC\n        uint256 maturity = DateTimeFull.timestampFromDateTime(2022, 1, 1, 0, 0, 0);\n        try alice.doInitSeries(address(feed), maturity) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidMaturity);\n        }\n    }\n\n    function testInitSeries() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (address zero, address claim) = initSampleSeries(address(alice), maturity);\n        assertTrue(zero != address(0));\n        assertTrue(claim != address(0));\n        assertEq(ERC20(zero).name(), \"Compound Dai 10-2021 Zero by Sense\");\n        assertEq(ERC20(zero).symbol(), \"zcDAI:10-2021\");\n        assertEq(ERC20(claim).name(), \"Compound Dai 10-2021 Claim by Sense\");\n        assertEq(ERC20(claim).symbol(), \"ccDAI:10-2021\");\n    }\n\n    function testInitSeriesWithdrawStake() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        uint256 beforeBalance = stable.balanceOf(address(alice));\n        (address zero, address claim) = initSampleSeries(address(alice), maturity);\n        assertTrue(address(zero) != address(0));\n        assertTrue(address(claim) != address(0));\n        uint256 afterBalance = stable.balanceOf(address(alice));\n        assertEq(afterBalance, beforeBalance - INIT_STAKE);\n    }\n\n    function testInitThreeSeries() public {\n        uint256 SERIES_TO_INIT = 3;\n        for (uint256 i = 1; i <= SERIES_TO_INIT; i++) {\n            uint256 nextMonthDate = DateTimeFull.addMonths(block.timestamp, i);\n            nextMonthDate = getValidMaturity(DateTimeFull.getYear(nextMonthDate), DateTimeFull.getMonth(nextMonthDate));\n            (address zero, address claim) = initSampleSeries(address(alice), nextMonthDate);\n            hevm.warp(block.timestamp + 1 days);\n            assertTrue(address(zero) != address(0));\n            assertTrue(address(claim) != address(0));\n        }\n    }\n\n    function testInitSeriesOnMinMaturity() public {\n        hevm.warp(1631664000);\n        // 15-09-21 00:00 UTC\n        uint256 maturity = DateTimeFull.timestampFromDateTime(2021, 10, 1, 0, 0, 0);\n        initSampleSeries(address(alice), maturity);\n    }\n\n    function testInitSeriesOnMaxMaturity() public {\n        hevm.warp(1631664000);\n        // 15-09-21 00:00 UTC\n        uint256 maturity = DateTimeFull.timestampFromDateTime(2021, 12, 1, 0, 0, 0);\n        initSampleSeries(address(alice), maturity);\n    }\n\n    /* ========== settleSeries() tests ========== */\n\n    function testCantSettleSeriesIfDisabledFeed() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        divider.setFeed(address(feed), false);\n        try alice.doSettleSeries(address(feed), maturity) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidFeed);\n        }\n    }\n\n    function testCantSettleSeriesAlreadySettled() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(maturity);\n        alice.doSettleSeries(address(feed), maturity);\n        try alice.doSettleSeries(address(feed), maturity) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.AlreadySettled);\n        }\n    }\n\n    function testCantSettleSeriesIfNotSponsorAndSponsorWindow() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(maturity);\n        try bob.doSettleSeries(address(feed), maturity) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.OutOfWindowBoundaries);\n        }\n    }\n\n    function testCantSettleSeriesIfNotSponsorCutoffTime() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(DateTimeFull.addSeconds(maturity, SPONSOR_WINDOW + SETTLEMENT_WINDOW + 1 seconds));\n        try bob.doSettleSeries(address(feed), maturity) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.OutOfWindowBoundaries);\n        }\n    }\n\n    function testCantSettleSeriesIfSponsorAndCutoffTime() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(DateTimeFull.addSeconds(maturity, SPONSOR_WINDOW + SETTLEMENT_WINDOW + 1 seconds));\n        try alice.doSettleSeries(address(feed), maturity) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.OutOfWindowBoundaries);\n        }\n    }\n\n    function testCantSettleSeriesIfNotSponsorAndSponsorTime() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(DateTimeFull.addSeconds(maturity, SPONSOR_WINDOW - 1 minutes));\n        try bob.doSettleSeries(address(feed), maturity) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.OutOfWindowBoundaries);\n        }\n    }\n\n    function testSettleSeries() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(maturity);\n        alice.doSettleSeries(address(feed), maturity);\n    }\n\n    function testSettleSeriesIfSponsorAndSponsorWindow() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(maturity);\n        alice.doSettleSeries(address(feed), maturity);\n    }\n\n    function testSettleSeriesIfSponsorAndOnSponsorWindowMinLimit() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(DateTimeFull.subSeconds(maturity, SPONSOR_WINDOW));\n        alice.doSettleSeries(address(feed), maturity);\n    }\n\n    function testSettleSeriesIfSponsorAndOnSponsorWindowMaxLimit() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(DateTimeFull.addSeconds(maturity, SPONSOR_WINDOW));\n        alice.doSettleSeries(address(feed), maturity);\n    }\n\n    function testSettleSeriesIfSponsorAndSettlementWindow() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(DateTimeFull.addSeconds(maturity, SPONSOR_WINDOW + SETTLEMENT_WINDOW));\n        alice.doSettleSeries(address(feed), maturity);\n    }\n\n    function testSettleSeriesIfNotSponsorAndSettlementWindow() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(DateTimeFull.addSeconds(maturity, SPONSOR_WINDOW + SETTLEMENT_WINDOW));\n        bob.doSettleSeries(address(feed), maturity);\n    }\n\n    function testSettleSeriesStakeIsTransferredIfSponsor() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        uint256 beforeBalance = stable.balanceOf(address(alice));\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(maturity);\n        alice.doSettleSeries(address(feed), maturity);\n        uint256 afterBalance = stable.balanceOf(address(alice));\n        assertEq(beforeBalance, afterBalance);\n    }\n\n    function testSettleSeriesStakeIsTransferredIfNotSponsor() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        uint256 beforeBalance = stable.balanceOf(address(bob));\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(DateTimeFull.addSeconds(maturity, SPONSOR_WINDOW + 1 seconds));\n        bob.doSettleSeries(address(feed), maturity);\n        uint256 afterBalance = stable.balanceOf(address(bob));\n        assertEq(afterBalance, beforeBalance + INIT_STAKE);\n    }\n\n    //    function testSettleSeriesFeesAreTransferredIfSponsor() public {\n    //        revert(\"IMPLEMENT\");\n    //    }\n    //\n    //    function testSettleSeriesFeesAreTransferredIfNotSponsor() public {\n    //        revert(\"IMPLEMENT\");\n    //    }\n\n    /* ========== issue() tests ========== */\n\n    function testCantIssueFeedDisabled() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        uint256 tBase = 10**target.decimals();\n        uint256 tBal = 100 * tBase;\n        divider.setFeed(address(feed), false);\n        try alice.doIssue(address(feed), maturity, tBal) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidFeed);\n        }\n    }\n\n    function testCantIssueSeriesDoesntExists() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        uint256 tBase = 10**target.decimals();\n        uint256 tBal = 100 * tBase;\n        try alice.doIssue(address(feed), maturity, tBal) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.SeriesDoesntExists);\n        }\n    }\n\n    function testCantIssueNotEnoughBalance() public {\n        uint256 aliceBalance = target.balanceOf(address(alice));\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        divider.setGuard(address(target), aliceBalance * 2);\n        try alice.doIssue(address(feed), maturity, aliceBalance + 1) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.TransferFromFailed);\n        }\n    }\n\n    function testCantIssueNotEnoughAllowance() public {\n        uint256 aliceBalance = target.balanceOf(address(alice));\n        alice.doApprove(address(target), address(divider), 0);\n        divider.setGuard(address(target), aliceBalance);\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        try alice.doIssue(address(feed), maturity, aliceBalance) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.TransferFromFailed);\n        }\n    }\n\n    function testCantIssueIfSeriesSettled() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(maturity);\n        alice.doSettleSeries(address(feed), maturity);\n        uint256 amount = target.balanceOf(address(alice));\n        try alice.doIssue(address(feed), maturity, amount) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.IssueOnSettled);\n        }\n    }\n\n    function testCantIssueIfFeedValueLowerThanPrevious() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        (, uint256 lvalue) = feed.lscale();\n        feed.setScale(lvalue - 1);\n        hevm.warp(block.timestamp + 1 days);\n        try feed.scale() {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidScaleValue);\n        }\n        uint256 tBase = 10**target.decimals();\n        uint256 tBal = 100 * tBase;\n        try alice.doIssue(address(feed), maturity, tBal) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidScaleValue);\n        }\n    }\n\n    function testCantIssueIfMoreThanCap() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        uint256 amount = divider.guards(address(target)) + 1;\n        try alice.doIssue(address(feed), maturity, amount) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.GuardCapReached);\n        }\n    }\n\n    function testIssue(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (address zero, address claim) = initSampleSeries(address(alice), maturity);\n        hevm.warp(block.timestamp + 1 days);\n        uint256 convertBase = 1;\n        uint256 tDecimals = target.decimals();\n        if (tDecimals != 18) {\n            convertBase = tDecimals < 18 ? 10**(18 - tDecimals) : 10**(tDecimals - 18);\n        }\n        uint256 tBase = 10**target.decimals();\n        uint256 fee = (ISSUANCE_FEE / convertBase).fmul(tBal, tBase); // 1 target\n        uint256 tBalanceBefore = target.balanceOf(address(alice));\n        alice.doIssue(address(feed), maturity, tBal);\n        // Formula = newBalance.fmul(scale)\n        (, uint256 lscale) = feed.lscale();\n        uint256 mintedAmount = (tBal - fee).fmul(lscale, Token(zero).BASE_UNIT());\n        assertEq(ERC20(zero).balanceOf(address(alice)), mintedAmount);\n        assertEq(ERC20(claim).balanceOf(address(alice)), mintedAmount);\n        assertEq(target.balanceOf(address(alice)), tBalanceBefore - tBal);\n    }\n\n    //    function testIssueTwoTimes() public {\n    //        revert(\"IMPLEMENT\");\n    //    }\n\n    /* ========== combine() tests ========== */\n\n    function testCantCombineFeedDisabled() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        uint256 tBase = 10**target.decimals();\n        uint256 tBal = 100 * tBase;\n        divider.setFeed(address(feed), false);\n        try alice.doCombine(address(feed), maturity, tBal) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidFeed);\n        }\n    }\n\n    function testCantCombineSeriesDoesntExists() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        uint256 tBase = 10**target.decimals();\n        uint256 tBal = 100 * tBase;\n        try alice.doCombine(address(feed), maturity, tBal) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.SeriesDoesntExists);\n        }\n    }\n\n    function testCantCombineIfFeedValueLowerThanPrevious() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (address zero, ) = initSampleSeries(address(alice), maturity);\n        hevm.warp(block.timestamp + 1 days);\n        uint256 tBase = 10**target.decimals();\n        uint256 tBal = 100 * tBase;\n        alice.doIssue(address(feed), maturity, tBal);\n        uint256 zBal = ERC20(zero).balanceOf(address(alice));\n        (, uint256 lvalue) = feed.lscale();\n        feed.setScale(lvalue - 1);\n        hevm.warp(block.timestamp + 1 days);\n        try alice.doCombine(address(feed), maturity, zBal) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidScaleValue);\n        }\n    }\n\n    //    function testCantCombineNotEnoughBalance() public {\n    //        revert(\"IMPLEMENT\");\n    //    }\n    //\n    //    function testCantCombineNotEnoughAllowance() public {\n    //        revert(\"IMPLEMENT\");\n    //    }\n\n    function testCombine(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (address zero, address claim) = initSampleSeries(address(alice), maturity);\n        hevm.warp(block.timestamp + 1 days);\n        uint256 tBase = 10**target.decimals();\n        bob.doIssue(address(feed), maturity, tBal);\n        hevm.warp(block.timestamp + 1 days);\n        uint256 tBalanceBefore = target.balanceOf(address(bob));\n        uint256 zBalanceBefore = ERC20(zero).balanceOf(address(bob));\n        uint256 lscale = divider.lscales(address(feed), maturity, address(bob));\n        bob.doCombine(address(feed), maturity, zBalanceBefore);\n        uint256 tBalanceAfter = target.balanceOf(address(bob));\n        uint256 zBalanceAfter = ERC20(zero).balanceOf(address(bob));\n        uint256 cBalanceAfter = ERC20(claim).balanceOf(address(bob));\n        require(zBalanceAfter == 0);\n        require(cBalanceAfter == 0);\n        assertClose((tBalanceAfter - tBalanceBefore).fmul(lscale, Token(zero).BASE_UNIT()), zBalanceBefore);\n        // Amount of Zeros before combining == underlying balance\n        // uint256 collected = ??\n        // assertEq(tBalanceAfter - tBalanceBefore, collected); // TODO: assert collected value\n    }\n\n    function testCombineAtMaturity(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (address zero, address claim) = initSampleSeries(address(alice), maturity);\n        hevm.warp(block.timestamp + 1 days);\n        uint256 tBase = 10**target.decimals();\n        bob.doIssue(address(feed), maturity, tBal);\n        uint256 tBalanceBefore = target.balanceOf(address(bob));\n        uint256 zBalanceBefore = ERC20(zero).balanceOf(address(bob));\n\n        hevm.warp(maturity);\n        alice.doSettleSeries(address(feed), maturity);\n\n        uint256 lscale = divider.lscales(address(feed), maturity, address(bob));\n        bob.doCombine(address(feed), maturity, zBalanceBefore);\n        uint256 tBalanceAfter = target.balanceOf(address(bob));\n        uint256 zBalanceAfter = ERC20(zero).balanceOf(address(bob));\n        uint256 cBalanceAfter = ERC20(claim).balanceOf(address(bob));\n\n        require(zBalanceAfter == 0);\n        require(cBalanceAfter == 0);\n        //        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        assertClose((tBalanceAfter - tBalanceBefore).fmul(lscale, Token(zero).BASE_UNIT()), zBalanceBefore);\n        // TODO: check if this is correct!! Should it be .fmul(mscale));\n        // Amount of Zeros before combining == underlying balance\n        // uint256 collected = ??\n        // assertEq(tBalanceAfter - tBalanceBefore, collected); // TODO: assert collected value\n    }\n\n    /* ========== redeemZero() tests ========== */\n    function testCantRedeemZeroDisabledFeed() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (address zero, ) = initSampleSeries(address(alice), maturity);\n        hevm.warp(block.timestamp + 1 days);\n        divider.setFeed(address(feed), false);\n        uint256 balance = ERC20(zero).balanceOf(address(alice));\n        try alice.doRedeemZero(address(feed), maturity, balance) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidFeed);\n        }\n    }\n\n    function testCantRedeemZeroSeriesDoesntExists() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        uint256 balance = 1e18;\n        try alice.doRedeemZero(address(feed), maturity, balance) {\n            fail();\n        } catch Error(string memory error) {\n            // The settled check will fail if the Series does not exist\n            assertEq(error, Errors.NotSettled);\n        }\n    }\n\n    function testCantRedeemZeroSeriesNotSettled() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (address zero, ) = initSampleSeries(address(alice), maturity);\n        hevm.warp(block.timestamp + 1 days);\n        uint256 tBase = 10**target.decimals();\n        uint256 tBal = 100 * tBase;\n        bob.doIssue(address(feed), maturity, tBal);\n        hevm.warp(block.timestamp + 1 days);\n        uint256 balance = ERC20(zero).balanceOf(address(bob));\n        try bob.doRedeemZero(address(feed), maturity, balance) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.NotSettled);\n        }\n    }\n\n    function testCantRedeemZeroMoreThanBalance() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (address zero, ) = initSampleSeries(address(alice), maturity);\n        hevm.warp(maturity);\n        alice.doSettleSeries(address(feed), maturity);\n        uint256 balance = ERC20(zero).balanceOf(address(alice)) + 1e18;\n        try alice.doRedeemZero(address(feed), maturity, balance) {\n            fail();\n        } catch (bytes memory error) {\n            // Does not return any error message\n        }\n    }\n\n    function testRedeemZero(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (address zero, ) = initSampleSeries(address(alice), maturity);\n        hevm.warp(block.timestamp + 1 days);\n        bob.doIssue(address(feed), maturity, tBal);\n        hevm.warp(maturity);\n        alice.doSettleSeries(address(feed), maturity);\n        hevm.warp(block.timestamp + 1 days);\n        uint256 zBalanceBefore = ERC20(zero).balanceOf(address(bob));\n        uint256 balanceToRedeem = zBalanceBefore;\n        bob.doRedeemZero(address(feed), maturity, balanceToRedeem);\n        uint256 zBalanceAfter = ERC20(zero).balanceOf(address(bob));\n\n        // Formula: tBal = balance / mscale\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        uint256 redeemed = balanceToRedeem.fdiv(mscale, Token(zero).BASE_UNIT());\n        // Amount of Zeros burned == underlying amount\n        assertClose(redeemed.fmul(mscale, Token(zero).BASE_UNIT()), zBalanceBefore);\n        assertEq(zBalanceBefore, zBalanceAfter + balanceToRedeem);\n    }\n\n    function testRedeemZeroBalanceIsZero() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(maturity);\n        alice.doSettleSeries(address(feed), maturity);\n        uint256 tBalanceBefore = target.balanceOf(address(alice));\n        uint256 balance = 0;\n        alice.doRedeemZero(address(feed), maturity, balance);\n        uint256 tBalanceAfter = target.balanceOf(address(alice));\n        assertEq(tBalanceAfter, tBalanceBefore);\n    }\n\n    //    function testCanRedeemZeroBeforeMaturityIfSettled() public {\n    //        revert(\"IMPLEMENT\");\n    //    }\n\n    /* ========== collect() tests ========== */\n\n    function testCantCollectDisabledFeed() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        divider.setFeed(address(feed), false);\n        try alice.doCollect(claim) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidFeed);\n        }\n    }\n\n    function testCantCollectIfMaturityAndNotSettled(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        hevm.warp(block.timestamp + 1 days);\n        bob.doIssue(address(feed), maturity, tBal);\n        hevm.warp(maturity + divider.SPONSOR_WINDOW() + 1);\n        try bob.doCollect(claim) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.CollectNotSettled);\n        }\n    }\n\n    //    function testCantCollectIfNotClaimContract() public {\n    //        revert(\"IMPLEMENT\");\n    //    }\n\n    function testCollect(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = Token(claim).BASE_UNIT();\n        hevm.warp(block.timestamp + 1 days);\n        bob.doIssue(address(feed), maturity, tBal);\n        hevm.warp(block.timestamp + 1 days);\n        uint256 lscale = divider.lscales(address(feed), maturity, address(bob));\n        uint256 cBalanceBefore = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceBefore = target.balanceOf(address(bob));\n        uint256 collected = bob.doCollect(claim);\n        uint256 cBalanceAfter = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceAfter = target.balanceOf(address(bob));\n\n        // Formula: collect = tBal / lscale - tBal / cscale\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        (, uint256 lvalue) = feed.lscale();\n        uint256 cscale = block.timestamp >= maturity ? mscale : lvalue;\n        uint256 collect = cBalanceBefore.fdiv(lscale, claimBaseUnit);\n        collect -= cBalanceBefore.fdiv(cscale, claimBaseUnit);\n        assertEq(cBalanceBefore, cBalanceAfter);\n        assertEq(collected, collect);\n        assertEq(tBalanceAfter, tBalanceBefore + collected); // TODO: double check!\n    }\n\n    function testCollectAirdrop() public {\n        uint256 tBal = 1e18;\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = Token(claim).BASE_UNIT();\n        hevm.warp(block.timestamp + 1 days);\n        bob.doIssue(address(feed), maturity, tBal);\n        uint256 airdropAmount = 1e18;\n        airdrop.mint(address(wtarget), airdropAmount);\n        hevm.warp(block.timestamp + 1 days);\n        uint256 lscale = divider.lscales(address(feed), maturity, address(bob));\n        uint256 cBalanceBefore = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceBefore = target.balanceOf(address(bob));\n        uint256 airBalanceBefore = airdrop.balanceOf(address(bob));\n        uint256 collected = bob.doCollect(claim);\n        uint256 cBalanceAfter = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceAfter = target.balanceOf(address(bob));\n        uint256 airBalanceAfter = airdrop.balanceOf(address(bob));\n\n        // Formula: collect = tBal / lscale - tBal / cscale\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        (, uint256 lvalue) = feed.lscale();\n        uint256 cscale = block.timestamp >= maturity ? mscale : lvalue;\n        uint256 collect = cBalanceBefore.fdiv(lscale, claimBaseUnit);\n        collect -= cBalanceBefore.fdiv(cscale, claimBaseUnit);\n        assertEq(cBalanceBefore, cBalanceAfter);\n        assertEq(collected, collect);\n        assertEq(tBalanceAfter, tBalanceBefore + collected);\n        assertEq(airBalanceAfter, airdropAmount);\n    }\n\n    function testCollectAtMaturityBurnClaimsAndDoesNotCallBurnTwice(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = Token(claim).BASE_UNIT();\n        hevm.warp(block.timestamp + 1 days);\n        bob.doIssue(address(feed), maturity, tBal);\n        hevm.warp(maturity);\n        uint256 lscale = divider.lscales(address(feed), maturity, address(bob));\n        uint256 cBalanceBefore = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceBefore = target.balanceOf(address(bob));\n        alice.doSettleSeries(address(feed), maturity);\n        hevm.warp(block.timestamp + 1 days);\n        uint256 collected = bob.doCollect(claim);\n        uint256 cBalanceAfter = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceAfter = target.balanceOf(address(bob));\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        (, uint256 lvalue) = feed.lscale();\n        uint256 cscale = block.timestamp >= maturity ? mscale : lvalue;\n        // Formula: collect = tBal / lscale - tBal / cscale\n        uint256 collect = cBalanceBefore.fdiv(lscale, claimBaseUnit);\n        collect -= cBalanceBefore.fdiv(cscale, claimBaseUnit);\n        assertEq(collected, collect);\n        assertEq(cBalanceAfter, 0);\n        assertEq(tBalanceAfter, tBalanceBefore + collected); // TODO: double check!\n    }\n\n    function testCollectBeforeMaturityAfterEmergencyDoesNotReplaceBackfilled(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        hevm.warp(block.timestamp + 1 days);\n        bob.doIssue(address(feed), maturity, tBal);\n        divider.setFeed(address(feed), false); // emergency stop\n        uint256 newScale = 20e17;\n        divider.backfillScale(address(feed), maturity, newScale, backfills); // fix invalid scale value\n        divider.setFeed(address(feed), true); // re-enable feed after emergency\n        bob.doCollect(claim);\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        assertEq(mscale, newScale);\n        // TODO: check .scale() is not called (like to add the lscale). We can't?\n    }\n\n    function testCollectBeforeMaturityAndSettled(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = Token(claim).BASE_UNIT();\n        hevm.warp(block.timestamp + 1 days);\n        bob.doIssue(address(feed), maturity, tBal);\n        hevm.warp(maturity - SPONSOR_WINDOW);\n        uint256 lscale = divider.lscales(address(feed), maturity, address(bob));\n        uint256 cBalanceBefore = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceBefore = target.balanceOf(address(bob));\n        alice.doSettleSeries(address(feed), maturity);\n        hevm.warp(block.timestamp + 1 days);\n        uint256 collected = bob.doCollect(claim);\n        uint256 cBalanceAfter = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceAfter = target.balanceOf(address(bob));\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        (, uint256 lvalue) = feed.lscale();\n        uint256 cscale = block.timestamp >= maturity ? mscale : lvalue;\n        // Formula: collect = tBal / lscale - tBal / cscale\n        uint256 collect = cBalanceBefore.fdiv(lscale, claimBaseUnit);\n        collect -= cBalanceBefore.fdiv(cscale, claimBaseUnit);\n        assertEq(collected, collect);\n        assertEq(cBalanceAfter, 0);\n        assertEq(tBalanceAfter, tBalanceBefore + collected); // TODO: double check!\n    }\n\n    function testCollectTransferAndCollect(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = Token(claim).BASE_UNIT();\n        hevm.warp(block.timestamp + 1 days);\n        bob.doIssue(address(feed), maturity, tBal);\n        hevm.warp(block.timestamp + 15 days);\n        uint256 lscale = divider.lscales(address(feed), maturity, address(bob));\n        uint256 bcBalanceBefore = ERC20(claim).balanceOf(address(bob));\n        uint256 btBalanceBefore = target.balanceOf(address(bob));\n        bob.doTransfer(address(claim), address(alice), bcBalanceBefore); // collects and transfer\n        uint256 btBalanceAfter = target.balanceOf(address(bob));\n        uint256 bcollected = btBalanceAfter - btBalanceBefore;\n        uint256 acollected = alice.doCollect(claim); // try to collect\n\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        (, uint256 lvalue) = feed.lscale();\n        uint256 cscale = block.timestamp >= maturity ? mscale : lvalue;\n        // Formula: collect = tBal / lscale - tBal / cscale\n        uint256 collect = bcBalanceBefore.fdiv(lscale, claimBaseUnit);\n        collect -= bcBalanceBefore.fdiv(cscale, claimBaseUnit);\n        assertEq(bcollected, collect);\n        assertEq(ERC20(claim).balanceOf(address(alice)), bcBalanceBefore);\n        assertEq(ERC20(claim).balanceOf(address(bob)), 0);\n        assertEq(btBalanceAfter, btBalanceBefore + bcollected);\n        assertEq(acollected, 0);\n    }\n\n    function testCollectTransferToMyselfAndCollect(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = Token(claim).BASE_UNIT();\n        hevm.warp(block.timestamp + 1 days);\n        uint256 tBase = 10**target.decimals();\n        bob.doIssue(address(feed), maturity, tBal);\n        hevm.warp(block.timestamp + 15 days);\n        uint256 lscale = divider.lscales(address(feed), maturity, address(bob));\n        uint256 cBalanceBefore = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceBefore = target.balanceOf(address(bob));\n        bob.doTransfer(address(claim), address(bob), cBalanceBefore); // collects and transfer\n        uint256 cBalanceAfter = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceAfter = target.balanceOf(address(bob));\n        uint256 collected = tBalanceAfter - tBalanceBefore;\n        uint256 collectedAfterTransfer = alice.doCollect(claim); // try to collect\n\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        (, uint256 lvalue) = feed.lscale();\n        uint256 cscale = block.timestamp >= maturity ? mscale : lvalue;\n        // Formula: collect = tBal / lscale - tBal / cscale\n        uint256 collect = cBalanceBefore.fdiv(lscale, claimBaseUnit);\n        collect -= cBalanceBefore.fdiv(cscale, claimBaseUnit);\n        assertEq(collected, collect);\n        assertEq(cBalanceAfter, cBalanceBefore);\n        assertEq(tBalanceAfter, tBalanceBefore + collected);\n        assertEq(collectedAfterTransfer, 0);\n    }\n\n    /* ========== backfillScale() tests ========== */\n    function testCantBackfillScaleSeriesDoesntExists() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        uint256 tBase = 10**target.decimals();\n        uint256 tBal = 100 * tBase;\n        try divider.backfillScale(address(feed), maturity, tBal, backfills) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.SeriesDoesntExists);\n        }\n    }\n\n    function testCantBackfillScaleBeforeCutoffAndFeedEnabled() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        uint256 tBase = 10**target.decimals();\n        uint256 tBal = 100 * tBase;\n        try divider.backfillScale(address(feed), maturity, tBal, backfills) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.OutOfWindowBoundaries);\n        }\n    }\n\n    function testCantBackfillScaleSeriesNotGov() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(DateTimeFull.addSeconds(maturity, SPONSOR_WINDOW + SETTLEMENT_WINDOW + 1 seconds));\n        uint256 tBase = 10**target.decimals();\n        uint256 tBal = 100 * tBase;\n        try alice.doBackfillScale(address(feed), maturity, tBal, backfills) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.NotAuthorized);\n        }\n    }\n\n    function testCantBackfillScaleInvalidValue() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(DateTimeFull.addSeconds(maturity, SPONSOR_WINDOW + SETTLEMENT_WINDOW + 1 seconds));\n        uint256 amount = 1 * (10**(target.decimals() - 2));\n        try divider.backfillScale(address(feed), maturity, amount, backfills) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.InvalidScaleValue);\n        }\n    }\n\n    function testBackfillScale() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(DateTimeFull.addSeconds(maturity, SPONSOR_WINDOW + SETTLEMENT_WINDOW + 1 seconds));\n        uint256 newScale = 1e18;\n        Divider.Backfill memory aliceBackfill = Divider.Backfill(address(alice), 5e17);\n        Divider.Backfill memory bobBackfill = Divider.Backfill(address(bob), 4e17);\n        backfills.push(aliceBackfill);\n        backfills.push(bobBackfill);\n        divider.backfillScale(address(feed), maturity, newScale, backfills);\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        assertEq(mscale, newScale);\n        uint256 lscale = divider.lscales(address(feed), maturity, address(alice));\n        assertEq(lscale, aliceBackfill.lscale);\n        lscale = divider.lscales(address(feed), maturity, address(bob));\n        assertEq(lscale, bobBackfill.lscale);\n    }\n\n    function testBackfillScaleBeforeCutoffAndFeedDisabled() public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(maturity);\n        divider.setFeed(address(feed), false);\n        uint256 newScale = 1e18;\n        divider.backfillScale(address(feed), maturity, newScale, backfills);\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        assertEq(mscale, newScale);\n    }\n\n    // @notice if backfill happens before the maturity and sponsor window, stablecoin stake is transferred to the\n    // sponsor and issuance fees are returned to Sense's cup multisig address\n    function testBackfillScaleBeforeSponsorWindowTransfersStablecoinStakeAndFees(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        uint256 cupTargetBalanceBefore = target.balanceOf(address(this));\n        uint256 cupStableBalanceBefore = stable.balanceOf(address(this));\n        uint256 sponsorTargetBalanceBefore = target.balanceOf(address(alice));\n        uint256 sponsorStableBalanceBefore = stable.balanceOf(address(alice));\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(block.timestamp + 1 days);\n\n        uint256 convertBase = 1;\n        uint256 tDecimals = target.decimals();\n        if (target.decimals() != 18) {\n            convertBase = tDecimals < 18 ? 10**(18 - tDecimals) : 10**(tDecimals - 18);\n        }\n        uint256 tBase = 10**tDecimals;\n        uint256 fee = (ISSUANCE_FEE / convertBase).fmul(tBal, tBase); // 1 target\n        bob.doIssue(address(feed), maturity, tBal);\n\n        hevm.warp(maturity - SPONSOR_WINDOW);\n        divider.setFeed(address(feed), false);\n        uint256 newScale = 1 * tBase;\n        divider.backfillScale(address(feed), maturity, newScale, backfills);\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        assertEq(mscale, newScale);\n        assertEq(target.balanceOf(address(alice)), sponsorTargetBalanceBefore);\n        assertEq(stable.balanceOf(address(alice)), sponsorStableBalanceBefore);\n        assertEq(target.balanceOf(address(this)), cupTargetBalanceBefore + fee);\n        assertEq(stable.balanceOf(address(this)), cupStableBalanceBefore);\n    }\n\n    // @notice if backfill happens after issuance fees are returned to Sense's cup multisig address, both issuance fees\n    // and the stablecoin stake will go to Sense's cup multisig address\n    function testBackfillScaleAfterSponsorBeforeSettlementWindowsTransfersStablecoinStakeAndFees(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        uint256 sponsorTargetBalanceBefore = target.balanceOf(address(alice));\n        uint256 sponsorStableBalanceBefore = stable.balanceOf(address(alice));\n        uint256 cupTargetBalanceBefore = target.balanceOf(address(this));\n        uint256 cupStableBalanceBefore = stable.balanceOf(address(this));\n        initSampleSeries(address(alice), maturity);\n        hevm.warp(block.timestamp + 1 days);\n\n        uint256 convertBase = 1;\n        uint256 tDecimals = target.decimals();\n        if (tDecimals != 18) {\n            convertBase = tDecimals < 18 ? 10**(18 - tDecimals) : 10**(tDecimals - 18);\n        }\n        uint256 tBase = 10**tDecimals;\n        uint256 fee = (ISSUANCE_FEE / convertBase).fmul(tBal, tBase); // 1 target\n        bob.doIssue(address(feed), maturity, tBal);\n\n        hevm.warp(maturity + SPONSOR_WINDOW + 1 seconds);\n        divider.setFeed(address(feed), false);\n        uint256 newScale = 1 * tBase;\n        divider.backfillScale(address(feed), maturity, newScale, backfills);\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        assertEq(mscale, newScale);\n        uint256 sponsorTargetBalanceAfter = target.balanceOf(address(alice));\n        uint256 sponsorStableBalanceAfter = stable.balanceOf(address(alice));\n        assertEq(sponsorTargetBalanceAfter, sponsorTargetBalanceBefore);\n        assertEq(sponsorStableBalanceAfter, sponsorStableBalanceBefore - INIT_STAKE);\n        uint256 cupTargetBalanceAfter = target.balanceOf(address(this));\n        uint256 cupStableBalanceAfter = stable.balanceOf(address(this));\n        assertEq(cupTargetBalanceAfter, cupTargetBalanceBefore + fee);\n        assertEq(cupStableBalanceAfter, cupStableBalanceBefore + INIT_STAKE);\n    }\n\n    /* ========== misc tests ========== */\n\n    //    function testFeedIsDisabledIfScaleValueLowerThanPrevious() public {\n    //    }\n\n    //    function testFeedIsDisabledIfScaleValueCallReverts() public {\n    //        revert(\"IMPLEMENT\");\n    //    }\n\n    //    function testFeedIsDisabledIfScaleValueHigherThanThanPreviousPlusDelta() public {\n    //        revert(\"IMPLEMENT\");\n    //    }\n}\n"
    },
    "src/tests/Claim.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\nimport { Token } from \"../tokens/Token.sol\";\nimport { ERC20 } from \"@rari-capital/solmate/src/erc20/ERC20.sol\";\nimport { TestHelper } from \"./test-helpers/TestHelper.sol\";\nimport { FixedMath } from \"../external/FixedMath.sol\";\n\ncontract Claims is TestHelper {\n    using FixedMath for uint256;\n\n    function testCollect(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = Token(claim).BASE_UNIT();\n        hevm.warp(block.timestamp + 1 days);\n        uint256 tBase = 10**target.decimals();\n        bob.doIssue(address(feed), maturity, tBal);\n        hevm.warp(block.timestamp + 1 days);\n        uint256 lscale = divider.lscales(address(feed), maturity, address(bob));\n        uint256 cBalanceBefore = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceBefore = target.balanceOf(address(bob));\n        uint256 collected = bob.doCollect(claim);\n        uint256 cBalanceAfter = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceAfter = target.balanceOf(address(bob));\n\n        // Formula: collect = tBal / lscale - tBal / cscale\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        (, uint256 lvalue) = feed.lscale();\n        uint256 cscale = block.timestamp >= maturity ? mscale : lvalue;\n        uint256 collect = cBalanceBefore.fdiv(lscale, claimBaseUnit);\n        collect -= cBalanceBefore.fdiv(cscale, claimBaseUnit);\n        assertEq(cBalanceBefore, cBalanceAfter);\n        assertEq(collected, collect);\n        assertEq(tBalanceAfter, tBalanceBefore + collected); // TODO: double check!\n    }\n\n    function testCollectOnTransfer(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = Token(claim).BASE_UNIT();\n        hevm.warp(block.timestamp + 1 days);\n        uint256 tBase = 10**target.decimals();\n        bob.doIssue(address(feed), maturity, tBal);\n        hevm.warp(block.timestamp + 1 days);\n\n        uint256 lscale = divider.lscales(address(feed), maturity, address(bob));\n        uint256 acBalanceBefore = ERC20(claim).balanceOf(address(alice));\n        uint256 bcBalanceBefore = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceBefore = target.balanceOf(address(bob));\n        bob.doTransfer(address(claim), address(alice), bcBalanceBefore);\n        uint256 acBalanceAfter = ERC20(claim).balanceOf(address(alice));\n        uint256 bcBalanceAfter = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceAfter = target.balanceOf(address(bob));\n\n        // Formula: collect = tBal / lscale - tBal / cscale\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        (, uint256 lvalue) = feed.lscale();\n        uint256 cscale = block.timestamp >= maturity ? mscale : lvalue;\n        uint256 collect = bcBalanceBefore.fdiv(lscale, claimBaseUnit);\n        collect -= bcBalanceBefore.fdiv(cscale, claimBaseUnit);\n        assertEq(acBalanceBefore + bcBalanceBefore, acBalanceAfter);\n        assertEq(bcBalanceAfter, 0);\n        uint256 collected = tBalanceAfter - tBalanceBefore;\n        assertEq(collected, collect);\n        assertEq(tBalanceAfter, tBalanceBefore + collected);\n    }\n\n    function testCollectOnTransferFrom(uint96 tBal) public {\n        uint256 maturity = getValidMaturity(2021, 10);\n        (, address claim) = initSampleSeries(address(alice), maturity);\n        uint256 claimBaseUnit = Token(claim).BASE_UNIT();\n        hevm.warp(block.timestamp + 1 days);\n        uint256 tBase = 10**target.decimals();\n        bob.doIssue(address(feed), maturity, tBal);\n        hevm.warp(block.timestamp + 1 days);\n\n        uint256 lscale = divider.lscales(address(feed), maturity, address(bob));\n        uint256 acBalanceBefore = ERC20(claim).balanceOf(address(alice));\n        uint256 bcBalanceBefore = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceBefore = target.balanceOf(address(bob));\n        bob.doApprove(address(claim), address(alice));\n        alice.doTransferFrom(address(claim), address(bob), address(alice), bcBalanceBefore);\n        uint256 acBalanceAfter = ERC20(claim).balanceOf(address(alice));\n        uint256 bcBalanceAfter = ERC20(claim).balanceOf(address(bob));\n        uint256 tBalanceAfter = target.balanceOf(address(bob));\n\n        // Formula: collect = tBal / lscale - tBal / cscale\n        (, , , , , , uint256 mscale) = divider.series(address(feed), maturity);\n        (, uint256 lvalue) = feed.lscale();\n        uint256 cscale = block.timestamp >= maturity ? mscale : lvalue;\n        uint256 collect = bcBalanceBefore.fdiv(lscale, claimBaseUnit);\n        collect -= bcBalanceBefore.fdiv(cscale, claimBaseUnit);\n        assertEq(acBalanceBefore + bcBalanceBefore, acBalanceAfter);\n        assertEq(bcBalanceAfter, 0);\n        uint256 collected = tBalanceAfter - tBalanceBefore;\n        assertEq(collected, collect);\n        assertEq(tBalanceAfter, tBalanceBefore + collected);\n    }\n}\n"
    },
    "src/modules/Recycler.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n// External references\nimport { SafeERC20, ERC20 } from \"@rari-capital/solmate/src/erc20/SafeERC20.sol\";\nimport { Trust } from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\n// Internal references\nimport { Token } from \"../tokens/Token.sol\";\nimport { Divider } from \"../Divider.sol\";\nimport { Claim } from \"../tokens/Claim.sol\";\nimport { BaseFeed as Feed } from \"../feeds/BaseFeed.sol\";\n\n/// @title Claim Recycler\n/// @notice You can use this contract to amplify the FY component of your Claims\n/// @dev The majority of the business logic in this contract deals with the auction\ncontract Recycler is Trust {\n    using SafeERC20 for ERC20;\n\n    uint256 public constant AUCTION_SPEED = 0.001e18; // Zero lot size decreases by 0.001 each second\n\n    mapping(address => uint256) private totalDeposits;\n    mapping(address => uint256) private tick;\n    mapping(address => mapping(address => uint256)) private deposits;\n    mapping(address => mapping(address => uint256)) private marks;\n    mapping(address => Auction) private auctions;\n    mapping(address => uint256) private ids;\n    mapping(address => uint256) private multipliers;\n    mapping(address => RClaim) private rclaims;\n    Divider public divider;\n    struct Config {\n        uint256 dustLimit;\n        uint256 discountThreshold;\n        uint256 cadence;\n    }\n    struct RClaim {\n        uint256 collected;\n        uint256 lastKick;\n        Config config;\n        Token token;\n    }\n    struct Auction {\n        uint256 lot;\n        uint256 rho;\n        uint256 discount;\n    }\n\n    constructor(address _divider) Trust(msg.sender) {\n        divider = Divider(_divider);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /// @notice Transfer Claims from the caller\n    /// @dev Determines Claim type by calling Sense Core with the token address\n    /// @dev Track the timestamp of the deposit\n    /// @param feed Address of feed for Claim token that msg.sender is depositing\n    /// @param maturity Maturity date (timestamp) for Claim tokens that msg.sender is depositing\n    /// @param balance Amount of Claims to transfer from the caller\n    function join(\n        address feed,\n        uint256 maturity,\n        uint256 balance\n    ) public {\n        (, address claim, , , , , ) = divider.series(feed, maturity);\n        require(claim != address(0), \"Series must exist\");\n        require(!_auctionActive(claim), \"Auction active for this Claim\");\n\n        ERC20(claim).safeTransferFrom(msg.sender, address(this), balance);\n        rclaims[claim].token.mint(msg.sender, balance);\n\n        deposits[msg.sender][claim] += balance * multipliers[claim];\n        totalDeposits[claim] += balance;\n    }\n\n    /// @notice Transfer Claims and associated PY to the caller\n    /// @param feed Address of feed for Claim token that msg.sender is withdrawing\n    /// @param maturity Maturity date (timestamp) for Claim tokens that msg.sender is withdrawing\n    /// @param balance Amount of Claims to transfer to the caller\n    function exit(\n        address feed,\n        uint256 maturity,\n        uint256 balance\n    ) public {\n        (, address claim, , , , , ) = divider.series(feed, maturity);\n        require(claim != address(0), \"Series must exist\");\n\n        ERC20(claim).safeTransfer(msg.sender, balance);\n        rclaims[claim].token.burn(msg.sender, balance);\n\n        // Can't be on auction\n        require(!_auctionActive(claim), \"Auction active for this Claim\");\n\n        deposits[msg.sender][claim] -= balance;\n        totalDeposits[claim] -= balance;\n    }\n\n    /// @notice Update configuration parameter\n    /// @param feed Address of feed that Recycle Claim params are being changed for\n    /// @param maturity Maturity date (timestamp) for the Claim\n    /// @param params new value for the parameter\n    function file(\n        address feed,\n        uint256 maturity,\n        Config calldata params\n    ) public requiresTrust {\n        (, address claim, , , , , ) = divider.series(feed, maturity);\n        require(rclaims[claim].token != ERC20(address(0)), \"rClaim hasn't yet been initialized\");\n        rclaims[claim].config = params;\n    }\n\n    /// @notice Initialize a new Claim\n    /// @param feed Address of feed for Claim token user is initializing\n    /// @param maturity maturity Maturity date (timestamp) for the Claim\n    /// @param params Configuration struct to set all of the initial variables needed for a Claim type\n    function init(\n        address feed,\n        uint256 maturity,\n        Config calldata params\n    ) public requiresTrust {\n        (, address claim, , , , , ) = divider.series(feed, maturity);\n        require(claim != address(0), \"Series must exist\");\n        require(rclaims[claim].token == ERC20(address(0)), \"rClaim type has already been initialized\");\n\n        // Only applies to future auctions\n        string memory name = string(abi.encodePacked(\"R-\", ERC20(claim).name(), \"-R\"));\n        string memory symbol = string(abi.encodePacked(\"R-\", ERC20(claim).symbol(), \"-R\"));\n        rclaims[claim].token = new Token(name, symbol, ERC20(Feed(feed).target()).decimals());\n        // NOTE: Default to mainnet chainId for now.\n        rclaims[claim].config = params;\n        rclaims[claim].lastKick = block.timestamp;\n\n        multipliers[claim] = 1 ether;\n    }\n\n    /// @notice Start an auction for a specific Series\n    function kick(address feed, uint256 maturity) public {\n        (, address claim, , , , , ) = divider.series(feed, maturity);\n        require(claim != address(0), \"Series must exist\");\n        require(!_auctionActive(claim), \"Auction already active for this Claim\");\n\n        require(\n            block.timestamp - rclaims[claim].lastKick > rclaims[claim].config.cadence,\n            \"Not enough time has passed since last auction\"\n        );\n\n        // Amount of target collected\n        uint256 collected = Claim(claim).collect();\n        require(collected > rclaims[claim].config.discountThreshold, \"Not enough yield to collect for an auction\");\n\n        auctions[claim].discount = collected;\n        // Kick off the auction looking for\n        auctions[claim].lot = 100 ether * collected; // starting price: 100/101 -> 0.99\n    }\n\n    /// @notice Takes some amount of the lot of Zeros currently on auction for the given Claim token\n    /// @param feed Address of feed for Claim token user is initializing\n    /// @param maturity Claim type identifier\n    /// @param balance Balance of Zeros caller is buying\n    function take(\n        address feed,\n        uint256 maturity,\n        uint256 balance\n    ) public {\n        (address zero, address claim, , , , , ) = divider.series(feed, maturity);\n        require(claim != address(0), \"Series must exist\");\n\n        uint256 lot = _getLotSize(claim);\n        require(balance <= lot, \"Must take less than or equal to lot size\");\n\n        // Take the users Target\n        uint256 discount = auctions[claim].discount;\n        ERC20(Feed(feed).target()).safeTransferFrom(msg.sender, address(this), balance - discount);\n\n        // Use it plus the Target collected for this auction to issue new Zeros and Claims\n        divider.issue(feed, maturity, balance);\n        // Send all the Zeros back to the sender\n        ERC20(zero).safeTransfer(msg.sender, balance);\n\n        // TODO: double check this equation\n        multipliers[claim] = ERC20(claim).balanceOf(address(this)) / totalDeposits[claim];\n\n        // Decrement lot size appropriately\n        auctions[claim].lot -= (auctions[claim].lot / lot) * balance;\n        require(\n            auctions[claim].lot - discount >= rclaims[claim].config.dustLimit,\n            \"Must leave more than the dust limit\"\n        );\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    function _getLotSize(address claim) public view returns (uint256 lot) {\n        lot = auctions[claim].lot * ((block.timestamp - auctions[claim].rho) * AUCTION_SPEED);\n    }\n\n    function _auctionActive(address claim) internal view returns (bool active) {\n        active = auctions[claim].lot - auctions[claim].discount >= rclaims[claim].config.dustLimit;\n    }\n}\n"
    },
    "src/tests/EmergencyStop.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\nimport { Errors } from \"../libs/errors.sol\";\nimport { EmergencyStop } from \"../feeds/EmergencyStop.sol\";\n\nimport { TestHelper } from \"./test-helpers/TestHelper.sol\";\nimport { MockToken } from \"./test-helpers/MockToken.sol\";\n\ncontract Emergency is TestHelper {\n    function testAllFeedsAreStopped() public {\n        address[] memory feeds = new address[](11);\n        address[] memory targets = new address[](11);\n        targets[0] = address(target);\n        feeds[0] = address(feed);\n        for (uint256 i = 1; i <= 10; i++) {\n            MockToken target = new MockToken(\"Test Target\", \"TT\", 18);\n            factory.addTarget(address(target), true);\n            (address feed, ) = factory.deployFeed(address(target));\n            targets[i] = address(target);\n            feeds[i] = address(feed);\n        }\n        EmergencyStop e = new EmergencyStop(address(divider));\n        divider.setIsTrusted(address(e), true);\n        e.stop(feeds);\n\n        for (uint256 i = 0; i < feeds.length; i++) {\n            assert(divider.feeds(feeds[i]) == false);\n        }\n    }\n\n    function testCantStopFeedsIfNotAuthorized() public {\n        address[] memory feeds = new address[](11);\n        address[] memory targets = new address[](11);\n        targets[0] = address(target);\n        feeds[0] = address(feed);\n        for (uint256 i = 1; i <= 10; i++) {\n            MockToken target = new MockToken(\"Test Target\", \"TT\", 18);\n            factory.addTarget(address(target), true);\n            (address feed, ) = factory.deployFeed(address(target));\n            targets[i] = address(target);\n            feeds[i] = address(feed);\n        }\n        EmergencyStop e = new EmergencyStop(address(divider));\n        try e.stop(feeds) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.NotAuthorized);\n        }\n    }\n}\n"
    },
    "src/feeds/EmergencyStop.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n// External references\nimport { Trust } from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\n// Internal references\nimport { Divider } from \"../Divider.sol\";\n\n/// @title Stops all feeds from the divider\ncontract EmergencyStop is Trust {\n    address public divider;\n\n    constructor(address _divider) Trust(msg.sender) {\n        divider = _divider;\n    }\n\n    function stop(address[] memory feeds) external virtual requiresTrust {\n        for (uint256 i = 0; i < feeds.length; i++) {\n            Divider(divider).setFeed(feeds[i], false);\n            emit Stopped(feeds[i]);\n        }\n    }\n\n    event Stopped(address indexed feed);\n}\n"
    },
    "src/tests/BaseFactory.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\nimport { TestHelper } from \"./test-helpers/TestHelper.sol\";\nimport { MockFeed } from \"./test-helpers/MockFeed.sol\";\nimport { MockFactory } from \"./test-helpers/MockFactory.sol\";\nimport { MockToken } from \"./test-helpers/MockToken.sol\";\nimport { IFeed } from \"./test-helpers/interfaces/IFeed.sol\";\nimport { DateTimeFull } from \"./test-helpers/DateTimeFull.sol\";\nimport { Errors } from \"../libs/errors.sol\";\n\ncontract Factories is TestHelper {\n    function testDeployFactory() public {\n        MockFeed implementation = new MockFeed();\n        MockFactory someFactory = new MockFactory(address(implementation), address(divider), DELTA, address(1));\n        assertTrue(address(someFactory) != address(0));\n        assertEq(MockFactory(someFactory).implementation(), address(implementation));\n        assertEq(MockFactory(someFactory).divider(), address(divider));\n        assertEq(MockFactory(someFactory).delta(), DELTA);\n        assertEq(MockFactory(someFactory).airdropToken(), address(1));\n    }\n\n    function testDeployFeed() public {\n        MockToken someAirdrop = new MockToken(\"Some Airdrop\", \"SA\", 18);\n        MockToken someTarget = new MockToken(\"Some Target\", \"ST\", 18);\n        MockFactory someFactory = createFactory(address(someTarget), address(someAirdrop));\n        (address feed, address wTarget) = someFactory.deployFeed(address(someTarget));\n        assertTrue(feed != address(0));\n        assertTrue(wTarget != address(0));\n        assertEq(IFeed(feed).target(), address(someTarget));\n        assertEq(IFeed(feed).divider(), address(divider));\n        assertEq(IFeed(feed).delta(), DELTA);\n        assertEq(IFeed(feed).name(), \"Some Target Yield\");\n        assertEq(IFeed(feed).symbol(), \"ST-yield\");\n        assertEq(IFeed(feed).symbol(), \"ST-yield\");\n        uint256 scale = IFeed(feed).scale();\n        assertEq(scale, 1e17);\n    }\n\n    function testDeployFeedAndinitializeSeries() public {\n        MockToken someAirdrop = new MockToken(\"Some Airdrop\", \"SA\", 18);\n        MockToken someTarget = new MockToken(\"Some Target\", \"ST\", 18);\n        MockFactory someFactory = createFactory(address(someTarget), address(someAirdrop));\n        (address feed, ) = someFactory.deployFeed(address(someTarget));\n        assertTrue(feed != address(0));\n        uint256 scale = IFeed(feed).scale();\n        assertEq(scale, 1e17);\n        hevm.warp(block.timestamp + 1 days);\n        uint256 maturity = DateTimeFull.timestampFromDateTime(2021, 10, 1, 0, 0, 0);\n        (address zero, address claim) = alice.doInitSeries(feed, maturity);\n        assertTrue(zero != address(0));\n        assertTrue(claim != address(0));\n    }\n\n    function testCantDeployFeedIfTargetIsNotSupported() public {\n        MockToken newTarget = new MockToken(\"Not Supported\", \"NS\", 18);\n        try factory.deployFeed(address(newTarget)) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.NotSupported);\n        }\n    }\n\n    function testCantDeployFeedIfTargetIsNotSupportedOnSpecificFeed() public {\n        MockToken someAirdrop = new MockToken(\"Some Airdrop\", \"SA\", 18);\n        MockToken someTarget = new MockToken(\"Some Target\", \"ST\", 18);\n        MockFactory someFactory = createFactory(address(someTarget), address(someAirdrop));\n        try factory.deployFeed(address(someTarget)) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.NotSupported);\n        }\n        someFactory.deployFeed(address(someTarget));\n    }\n\n    function testCantDeployFeedIfAlreadyExists() public {\n        try factory.deployFeed(address(target)) {\n            fail();\n        } catch Error(string memory error) {\n            assertEq(error, Errors.FeedAlreadyExists);\n        }\n    }\n}\n"
    },
    "src/tests/test-helpers/interfaces/IFeed.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\nabstract contract IFeed {\n    function divider() external view virtual returns (address divider);\n\n    function target() external view virtual returns (address target);\n\n    function name() external view virtual returns (string memory name);\n\n    function symbol() external view virtual returns (string memory symbol);\n\n    function delta() external view virtual returns (uint256 delta);\n\n    function scale() external virtual returns (uint256 _scale);\n\n    function initialize(\n        address _target,\n        address _divider,\n        uint256 _delta\n    ) external virtual;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}