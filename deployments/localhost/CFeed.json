{
  "address": "0x21dF544947ba3E8b3c32561399E88B52Dc8b2823",
  "abi": [
    {
      "anonymous": false,
      "inputs": [],
      "name": "Initialized",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "delta",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "divider",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_target",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_divider",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_delta",
          "type": "uint256"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lscale",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "scale",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "target",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x4f942dfda8b41a81ec186f61483b84fe36c2559c99152ad62d73a686832065f9",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x21dF544947ba3E8b3c32561399E88B52Dc8b2823",
    "transactionIndex": 0,
    "gasUsed": "747476",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xea26014b4c136dcf31fc9783fa10b8261e9e2c220ba82abfb7824127e26682f0",
    "transactionHash": "0x4f942dfda8b41a81ec186f61483b84fe36c2559c99152ad62d73a686832065f9",
    "logs": [],
    "blockNumber": 13407447,
    "cumulativeGasUsed": "747476",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "885381d4adfc3f3fad2e724560f105f3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.6+commit.11564f7e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[],\"name\":\"Initialized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"delta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"divider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_divider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_delta\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lscale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"scale()\":{\"details\":\"For some Targets, such as cTokens, this is simply the exchange rate, or `supply cToken / supply underlying`For other Targets, such as AMM LP shares, specialized logic will be required\",\"returns\":{\"_value\":\"WAD Scale value\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"scale()\":{\"notice\":\"Calculate and return this feed's Scale value for the current timestamp\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/feeds/compound/CFeed.sol\":\"CFeed\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8b2abd85d0ece7e866e100e9d47ca9cbec93c87cf71a8d267b2b93eb81f7d5e9\",\"license\":\"MIT\"},\"@rari-capital/solmate/src/auth/Trust.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.0;\\n\\n/// @notice Ultra minimal authorization logic for smart contracts.\\n/// @author Inspired by Dappsys V2 (https://github.com/dapp-org/dappsys-v2/blob/main/src/auth.sol)\\nabstract contract Trust {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event UserTrustUpdated(address indexed user, bool trusted);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              TRUST STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => bool) public isTrusted;\\n\\n    constructor(address user) {\\n        isTrusted[user] = true;\\n\\n        emit UserTrustUpdated(user, true);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         TRUST MODIFIER FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setIsTrusted(address user, bool trusted) public requiresTrust {\\n        isTrusted[user] = trusted;\\n\\n        emit UserTrustUpdated(user, trusted);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              TRUST LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    modifier requiresTrust() {\\n        require(isTrusted[msg.sender], \\\"UNTRUSTED\\\");\\n\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x5626e9634132d73cb032ca9176cdbb79de7d8b6f58586804cfc0140da2e04134\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/erc20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         PERMIT/EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    bytes32 public immutable DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = value;\\n\\n        emit Approval(msg.sender, spender, value);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= value;\\n\\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(msg.sender, to, value);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public virtual returns (bool) {\\n        if (allowance[from][msg.sender] != type(uint256).max) {\\n            allowance[from][msg.sender] -= value;\\n        }\\n\\n        balanceOf[from] -= value;\\n\\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(from, to, value);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          PERMIT/EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n            )\\n        );\\n\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_PERMIT_SIGNATURE\\\");\\n\\n        allowance[recoveredAddress][spender] = value;\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          INTERNAL UTILS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply += value;\\n\\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] -= value;\\n\\n        // This is safe because a user won't ever\\n        // have a balance larger than totalSupply!\\n        unchecked {\\n            totalSupply -= value;\\n        }\\n\\n        emit Transfer(from, address(0), value);\\n    }\\n}\\n\",\"keccak256\":\"0x4824edadf3ed7ce4dc3f0fdb47b5a7a08de80aba2a657f7a68212ea34a9c81a4\",\"license\":\"AGPL-3.0-only\"},\"@rari-capital/solmate/src/erc20/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\n\\n/// @notice Safe ERC20 and ETH transfer library that safely handles missing return values.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\\nlibrary SafeERC20 {\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(ERC20.transferFrom.selector, from, to, value)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(ERC20.transfer.selector, to, value)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(ERC20.approve.selector, to, value)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x4f46a609a6507ae6e0c66ec31aaaf1c4f7b49452de253ecbd7b77de58c6a1729\",\"license\":\"AGPL-3.0-only\"},\"src/Divider.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.6;\\n\\n// External references\\nimport { SafeERC20, ERC20 } from \\\"@rari-capital/solmate/src/erc20/SafeERC20.sol\\\";\\nimport { Trust } from \\\"@rari-capital/solmate/src/auth/Trust.sol\\\";\\nimport { DateTime } from \\\"./external/DateTime.sol\\\";\\nimport { FixedMath } from \\\"./external/FixedMath.sol\\\";\\n\\n// Internal references\\nimport { Errors } from \\\"./libs/errors.sol\\\";\\nimport { Claim } from \\\"./tokens/Claim.sol\\\";\\nimport { BaseFeed as Feed } from \\\"./feeds/BaseFeed.sol\\\";\\nimport { Token as Zero } from \\\"./tokens/Token.sol\\\";\\nimport { wTarget } from \\\"./wrappers/wTarget.sol\\\";\\n\\n/// @title Sense Divider: Divide Assets in Two\\n/// @author fedealconada + jparklev\\n/// @notice You can use this contract to issue, combine, and redeem Sense ERC20 Zeros and Claims\\ncontract Divider is Trust {\\n    using SafeERC20 for ERC20;\\n    using FixedMath for uint256;\\n    using Errors for   string;\\n\\n    /// @notice Configuration\\n    uint256 public constant ISSUANCE_FEE = 0.01e18; // In percentage (1%) [WAD] // TODO: TBD\\n    uint256 public constant INIT_STAKE = 1e18; // Series initialisation stablecoin stake [WAD] // TODO: TBD\\n    uint256 public constant SPONSOR_WINDOW = 4 hours; // TODO: TBD\\n    uint256 public constant SETTLEMENT_WINDOW = 2 hours; // TODO: TBD\\n    uint256 public constant MIN_MATURITY = 2 weeks; // TODO: TBD\\n    uint256 public constant MAX_MATURITY = 14 weeks; // TODO: TBD\\n\\n    string private constant ZERO_SYMBOL_PREFIX = \\\"z\\\";\\n    string private constant ZERO_NAME_PREFIX = \\\"Zero\\\";\\n    string private constant CLAIM_SYMBOL_PREFIX = \\\"c\\\";\\n    string private constant CLAIM_NAME_PREFIX = \\\"Claim\\\";\\n\\n    /// @notice Mutable program state\\n    address public stable;\\n    address public    cup;\\n    mapping(address => bool   ) public feeds;  // feed -> approved\\n    mapping(address => uint256) public guards; // target -> max amount of Target allowed to be issued\\n    mapping(address => address) public wtargets;  // target -> target wrapper\\n    mapping(address => mapping(uint256 => Series)) public series; // feed -> maturity -> series\\n    mapping(address => mapping(uint256 => mapping(address => uint256))) public lscales; // feed -> maturity -> account -> lscale\\n    struct Series {\\n        address zero; // Zero address for this Series (deployed on Series initialization)\\n        address claim; // Claim address for this Series (deployed on Series initialization)\\n        address sponsor; // Series initializer/sponsor\\n        uint256 issuance; // Issuance date for this Series (needed for Zero redemption)\\n        uint256 reward; // Tracks the fees due to the settler on Settlement\\n        uint256 iscale; // Scale value at issuance\\n        uint256 mscale; // Scale value at maturity\\n    }\\n\\n    constructor(address _stable, address _cup) Trust(msg.sender) {\\n        stable = _stable;\\n        cup    = _cup;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /// @notice Initializes a new Series\\n    /// @dev Deploys two ERC20 contracts, one for each Zero type\\n    /// @dev Transfers some fixed amount of stable asset to this contract\\n    /// @param feed Feed to associate with the Series\\n    /// @param maturity Maturity date for the new Series, in units of unix time\\n    function initSeries(address feed, uint256 maturity) external returns (address zero, address claim) {\\n        require(feeds[feed], Errors.InvalidFeed);\\n        require(!_exists(feed, maturity), Errors.DuplicateSeries);\\n        require(_isValid(maturity), Errors.InvalidMaturity);\\n\\n        // Transfer stable asset stake from caller to this contract\\n        ERC20(stable).safeTransferFrom(msg.sender, address(this), INIT_STAKE);\\n\\n        // Deploy Zeros and Claims for this new Series\\n        (zero, claim) = _split(feed, maturity);\\n\\n        // Initialize the new Series struct\\n        Series memory newSeries = Series({\\n            zero : zero,\\n            claim : claim,\\n            sponsor : msg.sender,\\n            issuance : block.timestamp,\\n            reward : 0,\\n            iscale : Feed(feed).scale(),\\n            mscale : 0\\n        });\\n        series[feed][maturity] = newSeries;\\n\\n        emit SeriesInitialized(feed, maturity, zero, claim, msg.sender);\\n    }\\n\\n    /// @notice Settles a Series and transfer the settlement reward to the caller\\n    /// @dev The Series' sponsor has a buffer where only they can settle the Series\\n    /// @dev After the buffer, the reward becomes MEV\\n    /// @param feed Feed to associate with the Series\\n    /// @param maturity Maturity date for the new Series\\n    function settleSeries(address feed, uint256 maturity) external {\\n        require(feeds[feed], Errors.InvalidFeed);\\n        require(_exists(feed, maturity), Errors.SeriesDoesntExists);\\n        require(_canBeSettled(feed, maturity), Errors.OutOfWindowBoundaries);\\n\\n        // The maturity scale value is all a Series needs for us to consider it \\\"settled\\\"\\n        series[feed][maturity].mscale = Feed(feed).scale();\\n\\n        // Reward the caller for doing the work of settling the Series at around the correct time\\n        ERC20 target = ERC20(Feed(feed).target());\\n        target.safeTransferFrom(wtargets[address(target)], msg.sender, series[feed][maturity].reward);\\n        ERC20(stable).safeTransfer(msg.sender, INIT_STAKE);\\n\\n        emit SeriesSettled(feed, maturity, msg.sender);\\n    }\\n\\n    /// @notice Mint Zeros and Claims of a specific Series\\n    /// @param feed Feed address for the Series\\n    /// @param maturity Maturity date for the Series\\n    /// @param tBal Balance of Target to deposit\\n    /// the amount of Zeros/Claims minted will be the equivelent value in units of underlying (less fees)\\n    function issue(address feed, uint256 maturity, uint256 tBal) external {\\n        require(feeds[feed], Errors.InvalidFeed);\\n        require(_exists(feed, maturity), Errors.SeriesDoesntExists);\\n        require(!_settled(feed, maturity), Errors.IssueOnSettled);\\n\\n        ERC20 target = ERC20(Feed(feed).target());\\n        uint256 tDecimals = target.decimals();\\n        uint256 tBase = 10 ** tDecimals;\\n        uint256 fee;\\n\\n        // Ensure the caller won't hit the issuance cap with this action\\n        require(target.balanceOf(address(this)) + tBal <= guards[address(target)], Errors.GuardCapReached);\\n        target.safeTransferFrom(msg.sender, wtargets[address(target)], tBal);\\n\\n        // Take the issuance fee out of the deposited Target, and put it towards the settlement\\n        if (tDecimals != 18) {\\n            fee = (tDecimals < 18 ? ISSUANCE_FEE / (10**(18 - tDecimals)) : ISSUANCE_FEE * 10**(tDecimals - 18)).fmul(tBal, tBase);\\n        } else {\\n            fee = ISSUANCE_FEE.fmul(tBal, tBase);\\n        }\\n\\n        series[feed][maturity].reward += fee;\\n        uint256 tBalSubFee = tBal - fee;\\n\\n        // If the caller has collected on Claims before, use the scale value from that collection to determine how many Zeros/Claims to mint\\n        // so that the Claims they mint here will have the same amount of yield stored up as their existing holdings\\n        uint256 scale = lscales[feed][maturity][msg.sender];\\n\\n        // If the caller has not collected on Claims before, use the current scale value to determine how many Zeros/Claims to mint\\n        // so that the Claims they mint here are \\\"clean,\\\" in that they have no yet-to-be-collected yield\\n        if (scale == 0) {\\n            scale = Feed(feed).scale();\\n            lscales[feed][maturity][msg.sender] = scale;\\n        }\\n\\n        // Determine the amount of Underlying equal to the Target being sent in (the principal)\\n        uint256 uBal = tBalSubFee.fmul(scale, Zero(series[feed][maturity].zero).BASE_UNIT());\\n\\n        // Mint equal amounts of Zeros and Claims\\n        Zero(series[feed][maturity].zero  ).mint(msg.sender, uBal);\\n        Claim(series[feed][maturity].claim).mint(msg.sender, uBal);\\n\\n        emit Issued(feed, maturity, uBal, msg.sender);\\n    }\\n\\n    /// @notice Reconstitute Target by burning Zeros and Claims\\n    /// @dev Explicitly burns claims before maturity, and implicitly does it at/after maturity through collect()\\n    /// @param feed Feed address for the Series\\n    /// @param maturity Maturity date for the Series\\n    /// @param uBal Balance of Zeros and Claims to burn\\n    function combine(address feed, uint256 maturity, uint256 uBal) external {\\n        require(feeds[feed], Errors.InvalidFeed);\\n        require(_exists(feed, maturity), Errors.SeriesDoesntExists);\\n\\n        Zero(series[feed][maturity].zero).burn(msg.sender, uBal);\\n        _collect(msg.sender, feed, maturity, uBal, address(0));\\n        if (block.timestamp < maturity) Claim(series[feed][maturity].claim).burn(msg.sender, uBal);\\n\\n        // We use lscale since the current scale was already stored there by the _collect() call\\n        uint256 cscale = _settled(feed, maturity) ? series[feed][maturity].mscale : lscales[feed][maturity][msg.sender];\\n\\n        // Convert from units of Underlying to units of Target\\n        uint256 tBal = uBal.fdiv(cscale, 10**ERC20(Feed(feed).target()).decimals());\\n        ERC20 target = ERC20(Feed(feed).target());\\n        target.safeTransferFrom(wtargets[address(target)], msg.sender, tBal);\\n\\n        emit Combined(feed, maturity, tBal, msg.sender);\\n    }\\n\\n    /// @notice Burn Zeros of a Series once its been settled\\n    /// @dev The balance of redeemable Target is a function of the change in Scale\\n    /// @param feed Feed address for the Series\\n    /// @param maturity Maturity date for the Series\\n    /// @param uBal Amount of Zeros to burn, which should be equivelent to the amount of Underlying owed to the caller\\n    function redeemZero(address feed, uint256 maturity, uint256 uBal) external {\\n        require(feeds[feed], Errors.InvalidFeed);\\n        // If a Series is settled, we know that it must have existed as well, so that check is unnecessary\\n        require(_settled(feed, maturity), Errors.NotSettled);\\n        // Burn the caller's Zeros\\n        Zero(series[feed][maturity].zero).burn(msg.sender, uBal);\\n\\n        // Calculate the amount of Target the caller is owed (amount of Target that's\\n        // equivelent to their principal in Underlying), then send it them\\n        uint256 tBal = uBal.fdiv(series[feed][maturity].mscale, 10**ERC20(Feed(feed).target()).decimals()); // Sensitive to precision loss\\n        ERC20 target = ERC20(Feed(feed).target());\\n        target.safeTransferFrom(wtargets[address(target)], msg.sender, tBal);\\n\\n        emit Redeemed(feed, maturity, tBal);\\n    }\\n\\n    /// @notice Collect Claim excess before, at, or after maturity\\n    /// @dev Burns the claim tokens if it's currently at or after maturity as this will be the last possible collect\\n    /// @dev If `to` is set, we copy the lscale value from usr to this address\\n    /// @param usr User who's collecting for their Claims\\n    /// @param feed Feed address for the Series\\n    /// @param maturity Maturity date for the Series\\n    /// @param to address to set the lscale value from usr\\n    function collect(\\n        address usr,\\n        address feed,\\n        uint256 maturity,\\n        address to\\n    ) external onlyClaim(feed, maturity) returns (uint256 collected) {\\n        return _collect(usr,\\n            feed,\\n            maturity,\\n            Claim(msg.sender).balanceOf(usr),\\n            to\\n        );\\n    }\\n\\n    function _collect(\\n        address usr,\\n        address feed,\\n        uint256 maturity,\\n        uint256 uBal,\\n        address to\\n    ) internal returns (uint256 collected) {\\n        require(feeds[feed], Errors.InvalidFeed);\\n        require(_exists(feed, maturity), Errors.SeriesDoesntExists);\\n\\n        // Get the scale value from the last time this holder collected\\n        uint256 cscale = series[feed][maturity].mscale;\\n        uint256 lscale = lscales[feed][maturity][usr];\\n        Claim claim = Claim(series[feed][maturity].claim);\\n        ERC20 target = ERC20(Feed(feed).target());\\n\\n        // If this is the Claim holder's first time collecting and nobody sent these Claims to them,\\n        // set the \\\"last scale\\\" value to the scale at issuance for this series\\n        if (lscale == 0) lscale = series[feed][maturity].iscale;\\n\\n        // If we're past maturity, this Series must be settled before collect can be called\\n        if (_settled(feed, maturity)) {\\n            claim.burn(usr, uBal);\\n        } else {\\n            // If we're not settled and we're past maturity + the sponsor window,\\n            // anyone can settle this Series so revert until someone does\\n            if (block.timestamp > maturity + SPONSOR_WINDOW) {\\n                revert(Errors.CollectNotSettled);\\n            } else {\\n                cscale = Feed(feed).scale();\\n                lscales[feed][maturity][usr] = cscale;\\n            }\\n        }\\n\\n        // Determine how much yield has accrued since the last time this user collected, in units of Target.\\n        // (Or take the last time as issuance if they haven't yet.)\\n        // Reminder that `Underlying / Scale` = `Target`, so this equation is saying, for some amount of Underlying `u`:\\n        // \\\"Target balance that equaled `u` at last collection _minus_ Target balance that equals `u` now\\\".\\n        // Because scale must be increasing, the Target balance needed to equal `u` decreases, and that \\\"excess\\\"\\n        // is what Claim holders are collecting\\n        collected = uBal.fdiv(lscale, claim.BASE_UNIT()) - uBal.fdiv(cscale, claim.BASE_UNIT());\\n        target.safeTransferFrom(wtargets[address(target)], usr, collected);\\n\\n        wTarget(wtargets[address(target)]).distribute(feed, maturity, usr, collected); // distribute airdrop tokens\\n\\n        // If this collect is a part of a token transfer to another address, set the receiver's\\n        // last collection to this scale (as all yield is being stripped off before the Claims are sent)\\n        if (to != address(0)) {\\n            lscales[feed][maturity][to] = cscale;\\n        }\\n\\n        emit Collected(feed, maturity, collected);\\n    }\\n\\n    /* ========== ADMIN FUNCTIONS ========== */\\n\\n    /// @notice Enable or disable a feed\\n    /// @param feed Feed's address\\n    /// @param isOn Flag setting this feed to enabled or disabled\\n    function setFeed(address feed, bool isOn) external requiresTrust {\\n        require(feeds[feed] != isOn, Errors.ExistingValue);\\n        feeds[feed] = isOn;\\n        emit FeedChanged(feed, isOn);\\n    }\\n\\n    /// @notice Set target's guard\\n    /// @param target Target address\\n    /// @param cap The max target that can be deposited on the Divider\\n    function setGuard(address target, uint256 cap) external requiresTrust {\\n        guards[target] = cap;\\n        emit GuardChanged(target, cap);\\n    }\\n\\n    /// @notice Adds wrapped target to wtargets mapping\\n    /// @param wtarget Wrapped Target address\\n    function setWrapper(address wtarget) external requiresTrust {\\n        address target = wTarget(wtarget).target();\\n        require(wtargets[target] == address(0), Errors.ExistingValue);\\n        wtargets[target] = wtarget;\\n        emit WTargetAdded(wtarget);\\n    }\\n\\n    struct Backfill {\\n        address usr;   // Address of the user who's getting their lscale backfilled\\n        uint256 lscale; // Scale value to backfill for usr's lscale\\n    }\\n\\n    /// @notice Backfill a Series' Scale value at maturity if keepers failed to settle it\\n    /// @param feed Feed's address\\n    /// @param maturity Maturity date for the Series\\n    /// @param mscale Value to set as the Series' Scale value at maturity\\n    /// @param backfills Values to set on lscales mapping\\n    function backfillScale(\\n        address feed,\\n        uint256 maturity,\\n        uint256 mscale,\\n        Backfill[] memory backfills\\n    ) external requiresTrust {\\n        require(_exists(feed, maturity), Errors.SeriesDoesntExists);\\n        require(mscale > series[feed][maturity].iscale, Errors.InvalidScaleValue);\\n\\n        uint256 cutoff = maturity + SPONSOR_WINDOW + SETTLEMENT_WINDOW;\\n        // If the feed is disabled, it will allow the admin to backfill no matter the maturity\\n        require(!feeds[feed] || block.timestamp > cutoff, Errors.OutOfWindowBoundaries);\\n\\n        // Set the maturity scale for the Series (needed for `redeem` methods)\\n        series[feed][maturity].mscale = mscale;\\n        // Set user's last scale values the Series (needed for the `collect` method)\\n        for (uint i = 0; i < backfills.length; i++) {\\n            lscales[feed][maturity][backfills[i].usr] = backfills[i].lscale;\\n        }\\n\\n        // Determine where the rewards should go depending on where we are relative to the maturity date\\n        address rewardee = block.timestamp <= maturity + SPONSOR_WINDOW ? series[feed][maturity].sponsor : cup;\\n        ERC20 target = ERC20(Feed(feed).target());\\n        target.safeTransferFrom(wtargets[address(target)], cup, series[feed][maturity].reward);\\n        ERC20(stable).safeTransfer(rewardee, INIT_STAKE);\\n\\n        emit Backfilled(feed, maturity, mscale, backfills);\\n    }\\n\\n    /* ========== INTERNAL VIEWS ========== */\\n\\n    function _exists(address feed, uint256 maturity) internal view returns (bool exists) {\\n        return address(series[feed][maturity].zero) != address(0);\\n    }\\n\\n    function _settled(address feed, uint256 maturity) internal view returns (bool settled) {\\n        return series[feed][maturity].mscale > 0;\\n    }\\n\\n    function _canBeSettled(address feed, uint256 maturity) internal view returns (bool canBeSettled) {\\n        require(!_settled(feed, maturity), Errors.AlreadySettled);\\n        uint256 cutoff = maturity + SPONSOR_WINDOW + SETTLEMENT_WINDOW;\\n        // If the sender is the sponsor for the Series\\n        if (msg.sender == series[feed][maturity].sponsor) {\\n            return maturity - SPONSOR_WINDOW <= block.timestamp && cutoff >= block.timestamp;\\n        } else {\\n            return maturity + SPONSOR_WINDOW < block.timestamp && cutoff >= block.timestamp;\\n        }\\n    }\\n\\n    function _isValid(uint256 maturity) internal view returns (bool valid) {\\n        if (maturity < block.timestamp + MIN_MATURITY || maturity > block.timestamp + MAX_MATURITY) return false;\\n\\n        (, , uint256 day, uint256 hour, uint256 minute, uint256 second) = DateTime.timestampToDateTime(maturity);\\n        if (day != 1 || hour != 0 || minute != 0 || second != 0) return false;\\n        return true;\\n    }\\n\\n    /* ========== INTERNAL HELPERS ========== */\\n\\n    function _split(address feed, uint256 maturity) internal returns (address zero, address claim) {\\n        ERC20 target = ERC20(Feed(feed).target());\\n        uint8 decimals = target.decimals();\\n        (, string memory m, string memory y) = DateTime.toDateString(maturity);\\n        string memory datestring = string(abi.encodePacked(m, \\\"-\\\", y));\\n\\n        string memory zname = string(abi.encodePacked(target.name(), \\\" \\\", datestring, \\\" \\\", ZERO_NAME_PREFIX, \\\" \\\", \\\"by Sense\\\"));\\n        string memory zsymbol = string(abi.encodePacked(ZERO_SYMBOL_PREFIX, target.symbol(), \\\":\\\", datestring));\\n        zero = address(new Zero(zname, zsymbol, decimals));\\n\\n        string memory cname = string(abi.encodePacked(target.name(), \\\" \\\", datestring, \\\" \\\", CLAIM_NAME_PREFIX, \\\" \\\", \\\"by Sense\\\"));\\n        string memory csymbol = string(abi.encodePacked(CLAIM_SYMBOL_PREFIX, target.symbol(), \\\":\\\", datestring));\\n        claim = address(new Claim(maturity, address(this), feed, cname, csymbol, decimals));\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyClaim(address feed, uint256 maturity) {\\n        require(series[feed][maturity].claim == msg.sender, \\\"Can only be invoked by the Claim contract\\\");\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Backfilled(address indexed feed, uint256 indexed maturity, uint256 mscale, Backfill[] backfills);\\n    event Collected(address indexed feed, uint256 indexed maturity, uint256 collected);\\n    event Combined(address indexed feed, uint256 indexed maturity, uint256 balance, address indexed sender);\\n    event GuardChanged(address indexed target, uint256 indexed cap);\\n    event FeedChanged(address indexed feed, bool isOn);\\n    event Issued(address indexed feed, uint256 indexed maturity, uint256 balance, address indexed sender);\\n    event Redeemed(address indexed feed, uint256 indexed maturity, uint256 redeemed);\\n    event SeriesInitialized(address indexed feed, uint256 indexed maturity, address zero, address claim, address indexed sponsor);\\n    event SeriesSettled(address indexed feed, uint256 indexed maturity, address indexed settler);\\n    event WTargetAdded(address indexed wtarget);\\n}\\n\",\"keccak256\":\"0xd89acffcce7afeed019eb4a7ebe2aab292b156cfacaa7c4efb20673635c9b63d\",\"license\":\"UNLICENSED\"},\"src/external/DateTime.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\n// ----------------------------------------------------------------------------\\n// DateTime Library v2.0\\n//\\n// A gas-efficient Solidity date and time library\\n//\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n//\\n// Tested date range 1970/01/01 to 2345/12/31\\n//\\n// Conventions:\\n// Unit      | Range         | Notes\\n// :-------- |:-------------:|:-----\\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\n// year      | 1970 ... 2345 |\\n// month     | 1 ... 12      |\\n// day       | 1 ... 31      |\\n// hour      | 0 ... 23      |\\n// minute    | 0 ... 59      |\\n// second    | 0 ... 59      |\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\n//\\n//\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\n// ----------------------------------------------------------------------------\\n\\nlibrary DateTime {\\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\\n    uint256 constant SECONDS_PER_MINUTE = 60;\\n    int256 constant OFFSET19700101 = 2440588;\\n\\n    function timestampToDate(uint256 timestamp)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function timestampToDateTime(uint256 timestamp)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day,\\n            uint256 hour,\\n            uint256 minute,\\n            uint256 second\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        uint256 secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n        secs = secs % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n        second = secs % SECONDS_PER_MINUTE;\\n    }\\n\\n    function toDateString(uint256 _timestamp)\\n        internal\\n        pure\\n        returns (\\n            string memory d,\\n            string memory m,\\n            string memory y\\n        )\\n    {\\n        (uint256 year, uint256 month, uint256 day) = timestampToDate(_timestamp);\\n        d = uintToString(day);\\n        m = uintToString(month);\\n        y = uintToString(year);\\n    }\\n\\n    /// Taken from https://stackoverflow.com/questions/47129173/how-to-convert-uint-to-string-in-solidity\\n    function uintToString(uint256 _i) internal pure returns (string memory _uintAsString) {\\n        if (_i == 0) return \\\"0\\\";\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len;\\n        while (_i != 0) {\\n            k = k - 1;\\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate the number of days from 1970/01/01 to year/month/day using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // days = day\\n    //      - 32075\\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\n    //      - offset\\n    // ------------------------------------------------------------------------\\n    function _daysFromDate(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day\\n    ) internal pure returns (uint256 _days) {\\n        require(year >= 1970);\\n        int256 _year = int256(year);\\n        int256 _month = int256(month);\\n        int256 _day = int256(day);\\n\\n        int256 __days = _day -\\n            32075 +\\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\\n            4 +\\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\\n            12 -\\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\\n            4 -\\n            OFFSET19700101;\\n\\n        _days = uint256(__days);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // int L = days + 68569 + offset\\n    // int N = 4 * L / 146097\\n    // L = L - (146097 * N + 3) / 4\\n    // year = 4000 * (L + 1) / 1461001\\n    // L = L - 1461 * year / 4 + 31\\n    // month = 80 * L / 2447\\n    // dd = L - 2447 * month / 80\\n    // L = month / 11\\n    // month = month + 2 - 12 * L\\n    // year = 100 * (N - 49) + year + L\\n    // ------------------------------------------------------------------------\\n    function _daysToDate(uint256 _days)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        int256 __days = int256(_days);\\n\\n        int256 L = __days + 68569 + OFFSET19700101;\\n        int256 N = (4 * L) / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int256 _year = (4000 * (L + 1)) / 1461001;\\n        L = L - (1461 * _year) / 4 + 31;\\n        int256 _month = (80 * L) / 2447;\\n        int256 _day = L - (2447 * _month) / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint256(_year);\\n        month = uint256(_month);\\n        day = uint256(_day);\\n    }\\n}\\n\",\"keccak256\":\"0x852ab78e6a462a640e15b5326e35cddb224ca0023772708cf4f45395ae6f22bc\",\"license\":\"MIT\"},\"src/external/FixedMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.6;\\n\\n/// @title Fixed point arithmetic library\\n/// @author Taken from https://github.com/yieldprotocol/yield-utils-v2/blob/main/contracts/math/WDiv.sol & https://github.com/yieldprotocol/yield-utils-v2/blob/main/contracts/math/WMul.sol\\nlibrary FixedMath {\\n    /// Taken from https://github.com/usmfum/USM/blob/master/contracts/FixedMath.sol\\n    /// @dev Multiply an amount by a fixed point factor with 18 decimals, rounds down\\n    function fmul(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        z = x * y;\\n        unchecked {\\n            z /= baseUnit;\\n        }\\n    }\\n\\n    /// Taken from https://github.com/usmfum/USM/blob/master/contracts/FixedMath.sol\\n    /// @dev Divide an amount by a fixed point factor with 18 decimals, rounds down\\n    function fdiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        z = (x * baseUnit) / y;\\n    }\\n}\\n\",\"keccak256\":\"0x69f46aec10024ac55700dc5aa162f281c0c95042b126fe3b91526d902316386f\",\"license\":\"GPL-3.0-or-later\"},\"src/feeds/BaseFeed.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.6;\\n\\n// External references\\nimport { Initializable } from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport { ERC20 } from \\\"@rari-capital/solmate/src/erc20/ERC20.sol\\\";\\nimport { FixedMath } from \\\"../external/FixedMath.sol\\\";\\n\\n// Internal references\\nimport { Divider } from \\\"../Divider.sol\\\";\\nimport { Errors } from \\\"../libs/errors.sol\\\";\\n\\n/// @title Assign time-based value to target assets\\n/// @dev In most cases, the only function that will be unique to each feed type is `scale`\\nabstract contract BaseFeed is Initializable {\\n    using FixedMath for uint256;\\n\\n    address public target;\\n    address public divider; // TODO: must be hardcoded!\\n    uint256 public delta;\\n    string public name;\\n    string public symbol;\\n    LScale public lscale;\\n\\n    struct LScale {\\n        uint256 timestamp; // timestamp of the last scale value\\n        uint256 value; // last scale value\\n    }\\n\\n    function initialize(\\n        address _target,\\n        address _divider,\\n        uint256 _delta\\n    ) external virtual initializer {\\n        // TODO: only factory?\\n        // TODO: add input validation?\\n        divider = _divider;\\n        delta = _delta;\\n        target = _target;\\n        name = string(abi.encodePacked(ERC20(target).name(), \\\" Yield\\\"));\\n        symbol = string(abi.encodePacked(ERC20(target).symbol(), \\\"-yield\\\"));\\n        emit Initialized();\\n    }\\n\\n    /// @notice Calculate and return this feed's Scale value for the current timestamp\\n    /// @dev For some Targets, such as cTokens, this is simply the exchange rate,\\n    /// or `supply cToken / supply underlying`\\n    /// @dev For other Targets, such as AMM LP shares, specialized logic will be required\\n    /// @return _value WAD Scale value\\n    function scale() external virtual returns (uint256 _value) {\\n        _value = _scale();\\n        uint256 lvalue = lscale.value;\\n        require(_value >= lvalue, Errors.InvalidScaleValue);\\n        uint256 timeDiff = block.timestamp - lscale.timestamp;\\n        if (timeDiff > 0 && lvalue != 0) {\\n            uint256 growthPerSec = (_value - lvalue).fdiv(lvalue * timeDiff, 10**ERC20(target).decimals());\\n            if (growthPerSec > delta) revert(Errors.InvalidScaleValue);\\n        }\\n        if (_value != lscale.value) {\\n            // update value only if different than previous\\n            lscale.value = _value;\\n            lscale.timestamp = block.timestamp;\\n        }\\n    }\\n\\n    /// @notice Actual scale value check that must be overriden by child contracts\\n    function _scale() internal virtual returns (uint256 _value);\\n\\n    event Initialized();\\n}\\n\",\"keccak256\":\"0x0ee1ad30f69042da90f11096d79c21656177d9686d0a9588a8a84e740d9ada4c\",\"license\":\"UNLICENSED\"},\"src/feeds/compound/CFeed.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.6;\\n\\n// External references\\nimport { FixedMath } from \\\"../../external/FixedMath.sol\\\";\\n\\n// Internal references\\nimport { BaseFeed } from \\\"../BaseFeed.sol\\\";\\n\\ninterface CTokenInterface {\\n    // @notice cToken is convertible into an ever increasing quantity of the underlying asset, as interest accrues in\\n    // the market. This function returns the exchange rate between a cToken and the underlying asset.\\n    // @dev: returns the current exchange rate as an uint, scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\\n    function exchangeRateCurrent() external returns (uint256);\\n\\n    function decimals() external returns (uint256);\\n\\n    function underlying() external returns (address);\\n}\\n\\n// @title feed contract for cTokens\\ncontract CFeed is BaseFeed {\\n    using FixedMath for uint256;\\n\\n    function _scale() internal virtual override returns (uint256 _value) {\\n        CTokenInterface t = CTokenInterface(target);\\n        uint256 decimals = 10 + CTokenInterface(t.underlying()).decimals();\\n        _value = t.exchangeRateCurrent() / (1 * 10**decimals);\\n    }\\n}\\n\",\"keccak256\":\"0xfe91d4d37b385f102ef36c9e9e90bd9a8963999a10b86e8f4a764e9d850df5b5\",\"license\":\"UNLICENSED\"},\"src/libs/errors.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.6;\\n\\n/// @notice Program error types\\nlibrary Errors {\\n    string constant AlreadySettled = \\\"Series has already been settled\\\";\\n    string constant CollectNotSettled = \\\"Cannot collect if Series is at or after maturity and it has not been settled\\\";\\n    string constant DuplicateSeries = \\\"Series with given maturity already exists\\\";\\n    string constant ExistingValue = \\\"New value must be different than previous\\\";\\n    string constant FeedAlreadyExists = \\\"Feed already exists\\\";\\n    string constant GuardCapReached = \\\"Issuance cap reached\\\";\\n    string constant IssueOnSettled = \\\"Cannot issue if Series is settled\\\";\\n    string constant InvalidFeed = \\\"Invalid feed address or feed is not enabled\\\";\\n    string constant InvalidMaturity = \\\"Maturity date is not valid\\\";\\n    string constant InvalidScaleValue = \\\"Scale value is invalid\\\";\\n    string constant NotAuthorized = \\\"UNTRUSTED\\\"; // We copy the error message used by solmate's `Trust` auth lib\\n    string constant NotEnoughClaims = \\\"Not enough claims to collect given target balance\\\";\\n    string constant SeriesDoesntExists = \\\"Series does not exist\\\";\\n    string constant NotSettled = \\\"Series must be settled\\\";\\n    string constant NotSupported = \\\"Target is not supported\\\";\\n    string constant OutOfWindowBoundaries = \\\"Can not settle Series outside the time window boundaries\\\";\\n    string constant TransferFromFailed = \\\"TRANSFER_FROM_FAILED\\\";\\n    string constant ZeroBalance = \\\"Balance must be greater than 0\\\";\\n}\\n\",\"keccak256\":\"0x8614cabb35b0ecd94f193a654e3ebd7f4f02f86bce7d433b7c0024fb797501a0\",\"license\":\"UNLICENSED\"},\"src/tokens/Claim.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.6;\\n\\n// Internal references\\nimport { Divider } from \\\"../Divider.sol\\\";\\nimport { Token } from \\\"./Token.sol\\\";\\n\\n/// @title Claim token contract that allows excess collection pre-maturity\\ncontract Claim is Token {\\n    uint256 public maturity;\\n    address public divider;\\n    address public feed;\\n\\n    constructor(\\n        uint256 _maturity,\\n        address _divider,\\n        address _feed,\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) Token(_name, _symbol, _decimals) {\\n        maturity = _maturity;\\n        divider = _divider;\\n        feed = _feed;\\n    }\\n\\n    function collect() external returns (uint256 _collected) {\\n        return Divider(divider).collect(msg.sender, feed, maturity, address(0));\\n    }\\n\\n    function transfer(address to, uint256 value) public override returns (bool) {\\n        Divider(divider).collect(msg.sender, feed, maturity, to);\\n        super.transfer(to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public override returns (bool) {\\n        Divider(divider).collect(from, feed, maturity, to);\\n        super.transferFrom(from, to, value);\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x71019135aa984b657b15de2119301dee4f8284e3b76aee49bdbb906f01dde673\",\"license\":\"UNLICENSED\"},\"src/tokens/Token.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.6;\\n\\n// External references\\nimport { ERC20 } from \\\"@rari-capital/solmate/src/erc20/ERC20.sol\\\";\\nimport { Trust } from \\\"@rari-capital/solmate/src/auth/Trust.sol\\\";\\n\\ncontract Token is ERC20, Trust {\\n    uint256 public immutable BASE_UNIT;\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) ERC20(_name, _symbol, _decimals) Trust(msg.sender) {\\n        BASE_UNIT = 10**_decimals;\\n    }\\n\\n    /// @param usr The address to send the minted tokens\\n    /// @param amount The amount to be minted\\n    function mint(address usr, uint256 amount) public requiresTrust {\\n        _mint(usr, amount);\\n        emit Mint(usr, amount);\\n    }\\n\\n    /// @param usr The address from where to burn tokens from\\n    /// @param amount The amount to be burned\\n    function burn(address usr, uint256 amount) public requiresTrust {\\n        _burn(usr, amount);\\n        emit Burn(usr, amount);\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Mint(address indexed usr, uint256 amount);\\n    event Burn(address indexed usr, uint256 amount);\\n}\\n\",\"keccak256\":\"0x968b2c41dc0ead0dfd8194d00b503d556d115912da1f4541f38c80bd84edacb1\",\"license\":\"UNLICENSED\"},\"src/wrappers/wTarget.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.6;\\n\\n// External references\\nimport { ERC20, SafeERC20 } from \\\"@rari-capital/solmate/src/erc20/SafeERC20.sol\\\";\\nimport { Trust } from \\\"@rari-capital/solmate/src/auth/Trust.sol\\\";\\nimport { FixedMath } from \\\"../external/FixedMath.sol\\\";\\n\\n// Internal\\nimport { Divider } from \\\"../Divider.sol\\\";\\nimport { BaseFeed as Feed } from \\\"../feeds/BaseFeed.sol\\\";\\n\\n/// @notice\\ncontract wTarget is Trust {\\n    using SafeERC20 for ERC20;\\n    using FixedMath for uint256;\\n\\n    /// @notice Configuration\\n    uint256 MAX_INT = 2**256 - 1;\\n\\n    /// @notice Mutable program state\\n    address public target;\\n    address public airdropToken;\\n    address public divider;\\n    mapping(address => uint256) public tBalances; // usr -> amount of airdrop tokens distributed\\n    mapping(address => uint256) public distributed; // usr -> amount of airdrop tokens distributed\\n\\n    constructor(\\n        address _target,\\n        address _divider,\\n        address _airdropToken\\n    ) Trust(msg.sender) {\\n        target = _target;\\n        airdropToken = _airdropToken;\\n        divider = _divider;\\n        ERC20(target).approve(divider, MAX_INT);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /// @notice Distributes airdropped tokens to Claim holders proportionally based on Claim balance\\n    /// @param _feed Feed to associate with the Series\\n    /// @param _maturity Maturity date\\n    /// @param _usr User to distribute airdrop tokens to\\n    function distribute(\\n        address _feed,\\n        uint256 _maturity,\\n        address _usr,\\n        uint256 collected\\n    ) external {\\n        (, address claim, , , , , ) = Divider(divider).series(_feed, _maturity);\\n        // uint256 scale = Divider(msg.sender).lscales(_feed, _maturity, _usr);\\n        // uint256 tBal = ERC20(_zero).balanceOf(_usr).fdiv(scale, 10**ERC20(target).decimals());\\n        // uint amount = (tBal / ERC20(target).balanceOf(address(this))) *\\n        // ERC20(airdropToken).balanceOf(address(this)) - distributed[_usr];\\n        uint256 amount = ERC20(claim).totalSupply() == 0\\n            ? 0\\n            : (ERC20(claim).balanceOf(_usr) / ERC20(claim).totalSupply()) *\\n                (ERC20(airdropToken).balanceOf(address(this)) - distributed[_usr]);\\n        // uint amount = ERC20(claim).totalSupply() == 0\\n        // ? 0\\n        // : (ERC20(claim).balanceOf(_usr) / ERC20(claim).totalSupply()) *\\n        // ERC20(airdropToken).balanceOf(address(this)) - distributed[_usr];\\n        emit Hi(ERC20(claim).totalSupply());\\n        emit Hi(ERC20(claim).balanceOf(_usr));\\n        emit Hi((ERC20(claim).balanceOf(_usr) / ERC20(claim).totalSupply()));\\n        emit Hi(ERC20(airdropToken).balanceOf(address(this)));\\n        emit Hi(amount);\\n\\n        distributed[_usr] += amount;\\n        ERC20(airdropToken).transfer(_usr, amount);\\n        emit Distributed(_usr, airdropToken, amount);\\n    }\\n\\n    /* ========== EVENTS ========== */\\n    event Distributed(address indexed usr, address indexed token, uint256 indexed amount);\\n    event Hi(uint256 h);\\n}\\n\",\"keccak256\":\"0xad9c42820982e9bd5e9ece207a19447537041474e526143352b11df7f6994db6\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610c91806100206000396000f3fe608060405234801561001057600080fd5b50600436106100785760003560e01c806306fdde031461007d57806312b495a81461009b5780631794bb3c146100b2578063378efa37146100c75780636b0706ed146100f257806395d89b4114610115578063d4b839921461011d578063f51e181a14610136575b600080fd5b61008561013e565b6040516100929190610a10565b60405180910390f35b6100a460025481565b604051908152602001610092565b6100c56100c0366004610892565b6101cc565b005b6001546100da906001600160a01b031681565b6040516001600160a01b039091168152602001610092565b600554600654610100919082565b60408051928352602083019190915201610092565b61008561045f565b6000546100da906201000090046001600160a01b031681565b6100a461046c565b6003805461014b90610bdc565b80601f016020809104026020016040519081016040528092919081815260200182805461017790610bdc565b80156101c45780601f10610199576101008083540402835291602001916101c4565b820191906000526020600020905b8154815290600101906020018083116101a757829003601f168201915b505050505081565b600054610100900460ff16806101e5575060005460ff16155b61024d5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084015b60405180910390fd5b600054610100900460ff1615801561026f576000805461ffff19166101011790555b600180546001600160a01b0319166001600160a01b038581169190911790915560028390556000805462010000600160b01b03191662010000878416810291909117808355604080516306fdde0360e01b8152905192909104909316926306fdde03926004808301939192829003018186803b1580156102ee57600080fd5b505afa158015610302573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261032a91908101906108d3565b60405160200161033a91906109e6565b6040516020818303038152906040526003908051906020019061035e9291906107d5565b50600060029054906101000a90046001600160a01b03166001600160a01b03166395d89b416040518163ffffffff1660e01b815260040160006040518083038186803b1580156103ad57600080fd5b505afa1580156103c1573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526103e991908101906108d3565b6040516020016103f991906109bc565b6040516020818303038152906040526004908051906020019061041d9291906107d5565b506040517f5daa87a0e9463431830481fd4b6e3403442dfb9a12b9c07597e9f61d50b633c890600090a18015610459576000805461ff00191690555b50505050565b6004805461014b90610bdc565b600061047661060d565b60065460408051808201909152601681527514d8d85b19481d985b1d59481a5cc81a5b9d985b1a5960521b602082015291925090818310156104cb5760405162461bcd60e51b81526004016102449190610a10565b506005546000906104dc9042610b99565b90506000811180156104ed57508115155b156105f55760006105a36105018385610b7a565b600060029054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b15801561054f57600080fd5b505afa158015610563573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105879190610999565b61059290600a610acc565b61059c8688610b99565b91906107b6565b90506002548111156105f357604080518082018252601681527514d8d85b19481d985b1d59481a5cc81a5b9d985b1a5960521b6020820152905162461bcd60e51b81526102449190600401610a10565b505b6006548314610608576006839055426005555b505090565b600080600060029054906101000a90046001600160a01b031690506000816001600160a01b0316636f307dc36040518163ffffffff1660e01b8152600401602060405180830381600087803b15801561066557600080fd5b505af1158015610679573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069d919061086e565b6001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381600087803b1580156106d757600080fd5b505af11580156106eb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061070f9190610980565b61071a90600a610a43565b905061072781600a610ac0565b610732906001610b7a565b826001600160a01b031663bd6d894d6040518163ffffffff1660e01b8152600401602060405180830381600087803b15801561076d57600080fd5b505af1158015610781573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107a59190610980565b6107af9190610a5b565b9250505090565b6000826107c38386610b7a565b6107cd9190610a5b565b949350505050565b8280546107e190610bdc565b90600052602060002090601f0160209004810192826108035760008555610849565b82601f1061081c57805160ff1916838001178555610849565b82800160010185558215610849579182015b8281111561084957825182559160200191906001019061082e565b50610855929150610859565b5090565b5b80821115610855576000815560010161085a565b60006020828403121561088057600080fd5b815161088b81610c43565b9392505050565b6000806000606084860312156108a757600080fd5b83356108b281610c43565b925060208401356108c281610c43565b929592945050506040919091013590565b6000602082840312156108e557600080fd5b815167ffffffffffffffff808211156108fd57600080fd5b818401915084601f83011261091157600080fd5b81518181111561092357610923610c2d565b604051601f8201601f19908116603f0116810190838211818310171561094b5761094b610c2d565b8160405282815287602084870101111561096457600080fd5b610975836020830160208801610bb0565b979650505050505050565b60006020828403121561099257600080fd5b5051919050565b6000602082840312156109ab57600080fd5b815160ff8116811461088b57600080fd5b600082516109ce818460208701610bb0565b650b5e5a595b1960d21b920191825250600601919050565b600082516109f8818460208701610bb0565b6508165a595b1960d21b920191825250600601919050565b6020815260008251806020840152610a2f816040850160208701610bb0565b601f01601f19169190910160400192915050565b60008219821115610a5657610a56610c17565b500190565b600082610a7857634e487b7160e01b600052601260045260246000fd5b500490565b600181815b80851115610ab8578160001904821115610a9e57610a9e610c17565b80851615610aab57918102915b93841c9390800290610a82565b509250929050565b600061088b8383610ad7565b600061088b60ff8416835b600082610ae657506001610b74565b81610af357506000610b74565b8160018114610b095760028114610b1357610b2f565b6001915050610b74565b60ff841115610b2457610b24610c17565b50506001821b610b74565b5060208310610133831016604e8410600b8410161715610b52575081810a610b74565b610b5c8383610a7d565b8060001904821115610b7057610b70610c17565b0290505b92915050565b6000816000190483118215151615610b9457610b94610c17565b500290565b600082821015610bab57610bab610c17565b500390565b60005b83811015610bcb578181015183820152602001610bb3565b838111156104595750506000910152565b600181811c90821680610bf057607f821691505b60208210811415610c1157634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b0381168114610c5857600080fd5b5056fea2646970667358221220f98aec2458e33861a975b8abc9f9301b35fcea5123c3aa6b6d1ed4f54f58659164736f6c63430008060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100785760003560e01c806306fdde031461007d57806312b495a81461009b5780631794bb3c146100b2578063378efa37146100c75780636b0706ed146100f257806395d89b4114610115578063d4b839921461011d578063f51e181a14610136575b600080fd5b61008561013e565b6040516100929190610a10565b60405180910390f35b6100a460025481565b604051908152602001610092565b6100c56100c0366004610892565b6101cc565b005b6001546100da906001600160a01b031681565b6040516001600160a01b039091168152602001610092565b600554600654610100919082565b60408051928352602083019190915201610092565b61008561045f565b6000546100da906201000090046001600160a01b031681565b6100a461046c565b6003805461014b90610bdc565b80601f016020809104026020016040519081016040528092919081815260200182805461017790610bdc565b80156101c45780601f10610199576101008083540402835291602001916101c4565b820191906000526020600020905b8154815290600101906020018083116101a757829003601f168201915b505050505081565b600054610100900460ff16806101e5575060005460ff16155b61024d5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084015b60405180910390fd5b600054610100900460ff1615801561026f576000805461ffff19166101011790555b600180546001600160a01b0319166001600160a01b038581169190911790915560028390556000805462010000600160b01b03191662010000878416810291909117808355604080516306fdde0360e01b8152905192909104909316926306fdde03926004808301939192829003018186803b1580156102ee57600080fd5b505afa158015610302573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261032a91908101906108d3565b60405160200161033a91906109e6565b6040516020818303038152906040526003908051906020019061035e9291906107d5565b50600060029054906101000a90046001600160a01b03166001600160a01b03166395d89b416040518163ffffffff1660e01b815260040160006040518083038186803b1580156103ad57600080fd5b505afa1580156103c1573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526103e991908101906108d3565b6040516020016103f991906109bc565b6040516020818303038152906040526004908051906020019061041d9291906107d5565b506040517f5daa87a0e9463431830481fd4b6e3403442dfb9a12b9c07597e9f61d50b633c890600090a18015610459576000805461ff00191690555b50505050565b6004805461014b90610bdc565b600061047661060d565b60065460408051808201909152601681527514d8d85b19481d985b1d59481a5cc81a5b9d985b1a5960521b602082015291925090818310156104cb5760405162461bcd60e51b81526004016102449190610a10565b506005546000906104dc9042610b99565b90506000811180156104ed57508115155b156105f55760006105a36105018385610b7a565b600060029054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b15801561054f57600080fd5b505afa158015610563573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105879190610999565b61059290600a610acc565b61059c8688610b99565b91906107b6565b90506002548111156105f357604080518082018252601681527514d8d85b19481d985b1d59481a5cc81a5b9d985b1a5960521b6020820152905162461bcd60e51b81526102449190600401610a10565b505b6006548314610608576006839055426005555b505090565b600080600060029054906101000a90046001600160a01b031690506000816001600160a01b0316636f307dc36040518163ffffffff1660e01b8152600401602060405180830381600087803b15801561066557600080fd5b505af1158015610679573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069d919061086e565b6001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381600087803b1580156106d757600080fd5b505af11580156106eb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061070f9190610980565b61071a90600a610a43565b905061072781600a610ac0565b610732906001610b7a565b826001600160a01b031663bd6d894d6040518163ffffffff1660e01b8152600401602060405180830381600087803b15801561076d57600080fd5b505af1158015610781573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107a59190610980565b6107af9190610a5b565b9250505090565b6000826107c38386610b7a565b6107cd9190610a5b565b949350505050565b8280546107e190610bdc565b90600052602060002090601f0160209004810192826108035760008555610849565b82601f1061081c57805160ff1916838001178555610849565b82800160010185558215610849579182015b8281111561084957825182559160200191906001019061082e565b50610855929150610859565b5090565b5b80821115610855576000815560010161085a565b60006020828403121561088057600080fd5b815161088b81610c43565b9392505050565b6000806000606084860312156108a757600080fd5b83356108b281610c43565b925060208401356108c281610c43565b929592945050506040919091013590565b6000602082840312156108e557600080fd5b815167ffffffffffffffff808211156108fd57600080fd5b818401915084601f83011261091157600080fd5b81518181111561092357610923610c2d565b604051601f8201601f19908116603f0116810190838211818310171561094b5761094b610c2d565b8160405282815287602084870101111561096457600080fd5b610975836020830160208801610bb0565b979650505050505050565b60006020828403121561099257600080fd5b5051919050565b6000602082840312156109ab57600080fd5b815160ff8116811461088b57600080fd5b600082516109ce818460208701610bb0565b650b5e5a595b1960d21b920191825250600601919050565b600082516109f8818460208701610bb0565b6508165a595b1960d21b920191825250600601919050565b6020815260008251806020840152610a2f816040850160208701610bb0565b601f01601f19169190910160400192915050565b60008219821115610a5657610a56610c17565b500190565b600082610a7857634e487b7160e01b600052601260045260246000fd5b500490565b600181815b80851115610ab8578160001904821115610a9e57610a9e610c17565b80851615610aab57918102915b93841c9390800290610a82565b509250929050565b600061088b8383610ad7565b600061088b60ff8416835b600082610ae657506001610b74565b81610af357506000610b74565b8160018114610b095760028114610b1357610b2f565b6001915050610b74565b60ff841115610b2457610b24610c17565b50506001821b610b74565b5060208310610133831016604e8410600b8410161715610b52575081810a610b74565b610b5c8383610a7d565b8060001904821115610b7057610b70610c17565b0290505b92915050565b6000816000190483118215151615610b9457610b94610c17565b500290565b600082821015610bab57610bab610c17565b500390565b60005b83811015610bcb578181015183820152602001610bb3565b838111156104595750506000910152565b600181811c90821680610bf057607f821691505b60208210811415610c1157634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b0381168114610c5857600080fd5b5056fea2646970667358221220f98aec2458e33861a975b8abc9f9301b35fcea5123c3aa6b6d1ed4f54f58659164736f6c63430008060033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "scale()": {
        "details": "For some Targets, such as cTokens, this is simply the exchange rate, or `supply cToken / supply underlying`For other Targets, such as AMM LP shares, specialized logic will be required",
        "returns": {
          "_value": "WAD Scale value"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "scale()": {
        "notice": "Calculate and return this feed's Scale value for the current timestamp"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 85,
        "contract": "src/feeds/compound/CFeed.sol:CFeed",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 88,
        "contract": "src/feeds/compound/CFeed.sol:CFeed",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 3284,
        "contract": "src/feeds/compound/CFeed.sol:CFeed",
        "label": "target",
        "offset": 2,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 3286,
        "contract": "src/feeds/compound/CFeed.sol:CFeed",
        "label": "divider",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 3288,
        "contract": "src/feeds/compound/CFeed.sol:CFeed",
        "label": "delta",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 3290,
        "contract": "src/feeds/compound/CFeed.sol:CFeed",
        "label": "name",
        "offset": 0,
        "slot": "3",
        "type": "t_string_storage"
      },
      {
        "astId": 3292,
        "contract": "src/feeds/compound/CFeed.sol:CFeed",
        "label": "symbol",
        "offset": 0,
        "slot": "4",
        "type": "t_string_storage"
      },
      {
        "astId": 3295,
        "contract": "src/feeds/compound/CFeed.sol:CFeed",
        "label": "lscale",
        "offset": 0,
        "slot": "5",
        "type": "t_struct(LScale)3300_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(LScale)3300_storage": {
        "encoding": "inplace",
        "label": "struct BaseFeed.LScale",
        "members": [
          {
            "astId": 3297,
            "contract": "src/feeds/compound/CFeed.sol:CFeed",
            "label": "timestamp",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 3299,
            "contract": "src/feeds/compound/CFeed.sol:CFeed",
            "label": "value",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}